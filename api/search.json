[{"id":"593191d2ee5e83bc4ca2a8a8cae1a811","title":"前端做了快两年了，盘点一下我的前端技术栈","content":"前言前言很简单，年终了，自己写了快两年前端（虽然刚毕业），但是大致总结一下哈哈哈哈\n我觉得这个话题蛮有意思的，可以看看大家的技术广度，可以进行分享和学习以及讨论\n所以这里说一下我对我的前端技术，做一下盘点和总结\n因为我的开发年限有限，所以我觉得我的盘点更适合0-3年的前端人群，所以技术范畴没有高年限大佬那么广，请见谅~\n个人技术栈我对我的较为熟悉的、主要的前端技术栈做个介绍，然后分段进行一下总结\nVue、TS、小程序、UniAPP、ThreeJS、Node后端、鸿蒙（目前我先放在前端这里，如果你说归属于移动端，那也没问题）\nVue在国内Vue和React的争论一直存在，但是我觉得并无优劣之分，都是很优秀很好的框架，与原生相比，二者都方便了我的开发\n并且二者的生态也很好，有很多周边的库，以及衍生的上层框架\n我觉得讨论好坏是意义不大的，如果你觉得不好的话，可以不去使用自己不心仪的框架，并且大可以去自己做一个更好的开源框架，或者是哪里让你觉得不舒服了，大可以提个PR\n我觉得讨论这个意义真的不大，但是我们可以去讨论一下框架的实际作用，在我们工作或者开发层面有没有帮助\n在国内，Vue的使用范围是不用多说的，不管它是不是培训机构或者是什么别的原因普及的，但是在国内，Vue足够熟练的话，大概率是能有个工作的（当然，并不完全，毕竟环境如此严峻）\n在国外的话，Vue也有不少，但是远不及国内这么普遍，这是一个不争的事实，所以如果你真的想去国外，或者是找远程的话，学React我觉得是比较有必要的，当然，这只是个建议\n而且就是在国内，要求React和Vue都会的的好像也慢慢变多了\n所以我真的觉得，这已经不是需不需要学的了，好像二者都要会似乎是必须技能了？但是也不用太担心，不考虑源码层面，其实上手另一框架进行开发是很快的~\nNuxt关于Nuxt，大家都知道它是Vue的一个上层框架，处理SSR问题的，目前是Nuxt3的版本\n首先，我没什么资格讨论这个框架的优劣\n我说一下我的开发体验，约定大于配置的原则贯穿了这个框架，但是也因此有一定的学习成本，而且在国内大部分的公司，好像没用上Nuxt，至少在招聘要求上，Nuxt好像不怎么提，但是在一些大厂我是知道在用SSR的，之前我在某厂的时候用的Next\n我并不清楚大家在公司是否业务上会用到这个框架，但是我之前在国企给公司做官网的时候，提出用Nuxt做，被无情否决了，原因有几方面吧\n这是我当时的开发任务表\n\n\n成本问题，公司人员为了这官网需要学习一个新的框架吗，而且资源并不多，稳定性谁也无法保证\n真的需要这个SSR吗\nNuxt全栈对于一个技术主管是Java出身的人，毫无优势\n\n后来我从公司离职了，现在我也不知道用了什么技术栈做的官网，不排除JSP的可能性，这里大家会说JSP远古时代的东西了，但是技术主管也是从那个时代过来的，而且JSP在服务端渲染上还是鼻祖级别\n那么Nuxt好吗？我觉得对学Vue的人来说，真的是个不错的框架，当然除了SSR，你做官网也可以有SSG的选择，但是Nuxt作为一个框架来说更为完善，我觉得目前更适合个人网站层面的开发\n可惜的是，我在Github浏览的时候，Nuxt好的项目比较少，尤其是Nuxt3的项目，当然，这是在上半年的时候了，而且目前市面上Nuxt教程也不足，为学习带来一些不小的挑战\n同时Next的资源会更多一些\n总的来说，我觉得SSR框架是很好的趋势，也很有学习的必要~\nTS今年骂TS的人格外多，什么什么取代TS的文章都很火，遗憾的是，我还并没有去使用JSDoc,我无法进行比较层面上的讨论，所以我只能说一些我关于TS的看法\n我个人觉得，你可以把JS和TS看成是两门语言\n在封装层面，我觉得TS对我的帮助是比较大的，因为在平时开发中，我封装组件以及hook比较频繁，我觉得TS带给我的体验层面是不错的\n在页面开发层面，其实TS大部分是做一些提示，甚至在写.vue组件的时候，看到TS的地方并不是很多，看到的也是引入封装过一些限制\n有一个东西比较有意思，就是Typescript类型体操方面，这可能算是一个拔高的地方？在面试中会遇到？我并不是很清楚，但是我看的其实比较头疼。真的不想看，而且我面试没被问过类型体操。。\n说实话，并没有仔细地去研究这方面，因为就我现在的开发过程中，复杂的类型体操过于加大了我的开发难度，而且实在用不上，当然，可能是我开发的项目过于简单，可能大佬们在大项目的开发过程中已经熟练于心了\n那么TS要学吗？我的建议是需要的，因为公司项目很多都在用，但是就我接触的项目中来说，TS的使用并不复杂，合理地运用TS会让项目更有健壮性，可以放心食用~\n当然，如果你觉得js足够，那也没有任何问题，js就是这么一个奇妙的语言~\n小程序、uniAPP这二者我放在一起了，比较类似\n小程序开发似乎是前端必备的一个技能了，目前主要是两种开发方式\n微信原生开发、UniAPP开发\n其实如果是单单开发微信小程序的话，我觉得原生的体验会好一些，我觉得这比较好理解，简单来说，微信原生小程序就是干小程序的，是官方的，而Uni会有一些限制，而且在调试的时候还要配合小程序的开发工具\n但是如果你考虑多端的话，那么答案也比较简单了，肯定是uni\n我其实是uni的粉丝，uni对于我这种个人开发者可以说是福音，它提供了一个完整的全栈生态，如果你说小程序也可以用云开发，没问题，但是在我当时使用的时候云开发的体验和功能方面的确不是uni，而且uni全栈的生态做的的确很好\n而且uni对我这种想独立做产品的独立开发者来说，的确很方便\n有很多人说小程序、说uni哪哪有问题，都是bug，真难用\n其实，这也是我想说的。。这二者的开发体验相较于正常的pc的确没法比\n但是不可否认的是，小程序在国内的用户使用度太高了，我曾经做自己产品的时候，让很多人帮忙填了问卷，就是产品的形式，大致是下面几种\n\nApp\nH5\nPC\n小程序\n\nApp和小程序占了90%，而二者之间小程序比App还高了一些\n所以我觉得小程序是没有办法的办法，如果有一天小程序真的没有用户了，那我真的放俩挂鞭庆祝一下\n同时我需要吐槽的是小程序的组件库的确很少，基本上就选Vant吧，Tdesign小程序版的真的不好用，别的我也没用过，也不想试了。。要是varlet能做小程序的就好了(狗头)\n那么学还是不学呢？我的建议是如果需要用了再学即可，二者的学习成本不高，大部分可以直接做项目入手，文档也比较完善\nThreejs今年比较热门的话题了，前端可视化，数字孪生，3D大屏，貌似很多人不知道卷什么，看3D这玩意高级，就都卷ThreeJs去了（babylonjs爆哭，为啥没有卷我）\n很多人觉得3D很难，没错，的确很难，但是难的是openGL，并不是three，难的是高级用法，例如着色器，而不是做个智慧厂房\n拿我来说，你让我做个那种炫酷的高大上的粒子效果，还有很多国外的炫酷小游戏，炫酷的特效，那对不起，我真不太行，但是你拿个现成模型，让我做个厂房，地下室，管道，这其实是不难的。。这也是我当时做的东西\n而国内大部分的公司也就是要后者而已，所以没必要担心自己学不会，网上资料这么多，而且大家都有资源，没必要过于担心\n同时，现在可视化会和零代码或者是低代码配合在一起，比如帆软的产品\n再或者是专注于可视化产品解决方案的公司，以thingjs举例\n我觉得是比较鲜明的例子，可以没事看看\n没有打广告，就是大家可以去关注一下现在市面上可视化的一些产品，从而进行思考\nNode后端这是我最想说的一个话题\n我理解的Node后端的框架大致是下面这些（包括但不完全）\nexpress、koa、koa2、egg、nest\n这是我学过并应用过的一些，我说说我的看法\n前端有必要有一些后端的思维\n有必要学习一下这种Node后端的框架\n但是如果你没什么基础，没必要学习太复杂的\n在国内，express、koa、egg其实应用已经不少，甚至我之前在公司的时候也会去用express、koa去写插件\n而且最关键的是，expres、koa这种的框架学习成本不高，并且已经足够你有一定的后端思维了\n而nest，我其实不是特别推荐初级前端去学习，至少在国内的话，我觉得是这样的，但是国外大可以去选择\n首先，nest的上手难度对于前端来说不低，作为Java出身的我，看到nest真的很亲切，但是更觉得nest在国内的受众不太行\n虽然工作的年限不长，但是其实我在好多公司待过，有大厂、有国企，但是在国内的公司，很难去选择nest去做公司后端架构（很少，但是不完全）\n90%以上会选择Java、甚至是Go等等，而且会使用express、koa去做插件，但是基本上不会去选择nest\n可能会被很多nest的喷，因为现在nest天天被推荐，其实我并不否认，nest真的是个很好的框架，他很优秀，但是我只是觉得它不适合国内\n你可能会说，nest可以做完整的系统，分布式啥的都没问题，但是国内还是直接用spring全家桶\n你说一说nest对比spring的优势在哪呢，尤其是在国内是后端偏技术主导的情况下\n当然如果你的公司技术选择了nest，那真的很棒，是有助于技术提升的！\n当然如果你真的想去学习更系统的Node后端，那么可以去学，或者说你公司真的用到了，也可以去学，你会收获很多东西\n我觉得资深的前端可能更适合，因为他们可能没什么可学的了。。但是对于初级来说，真的适合吗\n同时目前有些大佬出的课其实是很不错，质量很高，就不说具体名字了，毕竟这里不是打广告\n鸿蒙这里我把鸿蒙放在前端的范畴了，是因为我觉得我作为一个前端爱好者，入手鸿蒙很丝滑，并且觉得没什么门槛\n当然，flutter的小伙伴也这么觉得，所以你们说这算是移动端我也没什么意见~\n最近我出了一套鸿蒙的教学，开了一个专栏，起因是最近鸿蒙在掘金很火，但是教学偏少，于是就出了一些文章带着大家入门一下\n就我个人觉得吧，目前鸿蒙其实是有不少问题的，文档有问题，生态不完善，真机卡顿等问题，开发体验真的蛮差的\n所以我推荐可以当做爱好进行学习，但是说要是当饭碗来学习，至少得看明年Next版本怎么样才能继续说下去\n因为我不是培训机构，是一个比较客观的角度，所以实话实说我觉得作为一个前端来说，学上面的东西远比学习鸿蒙性价比来的高\n虽然我会继续做鸿蒙的专栏，但是并不代表我就很推荐去学，因为就是鸿蒙哪天真的市场真的起来了，你现学也来得及~\n而且那时候生态也比较完善了，对我来说，我只是觉得很感兴趣，而且比较享受这种探索的感觉，才去做的\n其它有很多没细说的技术，因为其实我觉得区别不大，比如React和Next，我觉得就是对比Vue和Nuxt\n还有一些了解并不深的东西，比如低代码，微前端\n很遗憾，我并没有接触过这二者，所以无法进行建议和评价（但是貌似口碑都不太好？）\n还有就是webcomponent，其实这真的是个不错的东西，但是受众真的很小（这不是个新东西，这么多年了也没多火）\n我觉得是国内更注重产出多一些，而不是技术探索方面\n还有比较热门的Rust，也很不错，国外和开源上面广受好评，并且很适合基建方面，但是对于咱们这小开发来说，倒也先不用在意\n还有关于前端单测方面，这个其实我用的很多，但是基本是在开源项目当中，因为很多开源项目你不走单测的话，PR是不给过的，现在我主要是vitest，比jest要好用不少，但是这玩意，大家在平时公司开发的话，能用到多少呢，公司有没有正规的CR都不一定\n关于monorepo也不是啥新东西了，也谈不上趋势不趋势的\n还有一个是组件库的问题，尤其是Vue的，最近ElementPlus不知道为什么天天被喷\n其实现在来看ElementPlus的确是有一些过度封装的意思，但是我觉得目前ElementPlus依旧还是Vue3组件库的典范，当然还有很多组件库很优秀，不一一列举了，如果你觉得ElementPlus不好的话，大可以自己去搞一个，开源出来，给XDM开开眼，而且别的组件库我也都用过，别说有多多好用了。。反正我最开始用的是AntdVue我的使用体验。。。（当然，也很优秀！）\n我想说的是，人家开源出来给你简化开发过程的，你觉得不好可以提issue，提PR，而不是整天说这个不好，那个不好，没太大意义\n结尾和建议这里更多是对初级一些的前端朋友，跟我差不多年份的\n高级、资深的佬就当看个乐就行\n如果你会Vue的话，建议学一下React，工作几率会变高的\n面试八股越来越少了，就是八股也是偏难一些的八股了，基本就是挖项目了，或者是场景题\n当然，大厂的话还是那样，会多考一些计网和操作系统\n可以去试着看一些源码，并不是Vue或者是React的，因为可能看起来并不容易，但是可以去看一些组件库的项目，比较容易懂一些，学一些思路和封装我觉得对能力是很有提升的\n工作难找，我发现初级的难找，佬也难找，所以也没必要过于焦虑，只能继续学下去\n国外远程比较火，技术栈偏向React全栈（React、Next、nest），看了一些佬的文章，看的那些招聘网站技术栈基本都是这样的\n别想着学Java啥的。。没必要\n加油吧，学无止境~\n读评论1\n\n2\n\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n","slug":"前端做了快两年了，盘点一下我的前端技术栈","date":"2024-02-12T03:24:42.000Z","categories_index":"好文摘录","tags_index":"个人成长","author_index":"一小池勺"},{"id":"b42317f34f9d4e8f2b9e27ddda7b5bbc","title":"湖人官宣！正式加盟！丁威迪发声潸然泪下","content":"北京时间2月11日，洛杉矶湖人官方宣布，球队正式签下完全自由球员、后卫斯潘赛-丁威迪。至此，丁威迪就正式成为了一名湖人，得以回到家乡洛杉矶打球，完成职业生涯成为湖人的梦想。\n\n据悉，湖人与丁威迪签下的是一份价值150万美元至赛季结束的合同。殊不知，丁威迪为了能加盟湖人他可是足足损失了近400万美元！因为达拉斯独行侠最多能为他提供一份价值530万的合同，但面对金钱的巨大诱惑，丁威迪最终还是极其冷静地选择了拒绝独行侠，转而加盟洛杉矶湖人联手詹姆斯浓眉冲击总冠军！\n\n交易截止日，丁威迪被老东家布鲁克林篮网交易至多伦多猛龙，但猛龙面对可能需要支付丁威迪150万美元奖金的情况下，毫不犹豫地选择买断其合同。如此一来，丁威迪在度过48小时澄清期后得以恢复自由身。在面对多支球队的热烈追求下，他果断地选择了加盟湖人开启职业生涯新篇章。\n\n赛季至今，丁威迪替篮网出战了48场比赛，场均可以得到12.6分3.3篮板6助攻0.8抢断，三分命中率32%。他的加盟将能为湖人提供进攻火力，有望成为球队二阵容的得分大杀器！近日，湖人当家球星勒布朗詹姆斯在谈到丁威迪时，对其寄予了厚望，老詹认为丁威迪这么一个老将能为球队带来巨大能量，他期待有丁威迪的湖人比赛。\n试问，丁威迪为何即便会损失近400万美元也要加盟湖人？究竟是因为詹眉冲冠的诱惑还是另有原因？这恐怕也是大家都想知道的答案。此前，丁威迪在采访时谈到自己和科比的关系，他表示自己从小就是科比球迷，科比是洛杉矶的老大，科比也曾不断鼓励自己，自己和科比的关系早已经超越了家人，说到动情时丁威迪不禁潸然泪下！而他之所以会突然放弃之前所穿的8号球衣改穿26号，这其实也跟偶像科比有着最直接关系。在科比出事后，丁威迪改穿26号（24+2）是因为科比（24号）和GIGi（2号）。\n由此足以见得，丁威迪绝对是位性情中人，加盟湖人应该也与科比有关！偶像离开了，丁威迪就用选择用另外一种方式回馈他生前所在的球队，与偶像同在！\n\n2024 2 12\n","slug":"湖人官宣！正式加盟！丁威迪发声潸然泪下","date":"2024-02-12T00:19:29.000Z","categories_index":"NBA","tags_index":"湖人","author_index":"一小池勺"},{"id":"86a4064166753da9cd1727d393773670","title":"写给前端的算法进阶指南，我是如何两个月零基础刷200题","content":"前言最近国内大厂面试中，出现 LeetCode 真题考察的频率越来越高了。我也观察到有越来越多的前端同学开始关注算法这个话题。\n但是算法是一个门槛很高的东西，在一个算法新手的眼里，它的智商门槛要求很高。事实上是这个样子的吗？如果你怀疑自己的智商不够去学习算法，那么你一定要先看完这篇文章：《天生不聪明》，也正是这篇文章激励了我开始了算法之路。\n这篇文章，我会先总结几个必学的题目分类，给出这个分类下必做例题的详细题解，并且在文章的末尾给出每个分类下必刷的题目的获取方式。\n一定要耐心看到底，会有重磅干货。\n心路我从 5 月份准备离职的时候开始学习算法，在此之前对于算法我是零基础，在最开始我对于算法的感受也和大家一样，觉得自己智商可能不够，望而却步。但是看了一些大佬对于算法和智商之间的关系，我发现算法好像也是一个通过练习可以慢慢成长的学科，而不是只有智商达到了某个点才能有入场券，所以我开始了我的算法之路。通过视频课程 + 分类刷题 + 总结题解 + 回头复习的方式，我在两个月的时间里把力扣的解题数量刷到了200题。对于一个算法新人来说，这应该算是一个还可以的成绩，这篇文章，我把我总结的一些学习心得，和一些经典例题分享给大家。\n\n学习方式\n分类刷题：很多第一次接触力扣的同学对于刷题的方法不太了解，有的人跟着题号刷，有的人跟着每日一题刷，但是这种漫无目的的刷题方式一般都会在中途某一天放弃，或者刷了很久但是却发现没什么沉淀。这里不啰嗦，直接点明一个所有大佬都推荐的刷题方法：把自己的学习阶段分散成几个时间段去刷不同分类的题型，比如第一周专门解链表相关题型，第二周专门解二叉树相关题型。这样你的知识会形成一个体系，通过一段时间的刻意练习把这个题型相关的知识点强化到你的脑海中，不容易遗忘。\n\n适当放弃：很多同学遇到一个难题，非得埋头钻研，干他 2 个小时。最后挫败感十足，久而久之可能就放弃了算法之路。要知道算法是个沉淀了几十年的领域，题解里的某个算法可能是某些教授研究很多年的心血，你想靠自己一个新手去想出来同等优秀的解法，岂不是想太多了。所以要学会适当放弃，一般来说，比较有目的性（面试）刷题的同学，他面对一道新的题目毫无头绪的话，会在 10 分钟之内直接放弃去看题解，然后记录下来，反复复习，直到这个解法成为自己的知识为止。这是效率最高的学习办法。\n\n接受自己是新手：没错，说的难听一点，接受自己不是天才这个现实。你在刷题的过程中会遇到很多困扰你的时候，比如相同的题型已经看过例题，稍微变了条件就解不出来。或者对于一个 easy 难度的题毫无头绪。或者甚至看不懂别人的题解（没错我经常）相信我，这很正常，不能说明你不适合学习算法，只能说明算法确实是一个博大精深的领域，把自己在其他领域的沉淀抛开来，接受自己是新手这个事实，多看题解，多请教别人。\n\n\n分类大纲\n算法的复杂度分析。\n\n排序算法，以及他们的区别和优化。\n\n数组中的双指针、滑动窗口思想。\n\n利用 Map 和 Set 处理查找表问题。\n\n链表的各种问题。\n\n利用递归和迭代法解决二叉树问题。\n\n栈、队列、DFS、BFS。\n\n回溯法、贪心算法、动态规划。\n\n\n题解接下来我会放出几个分类的经典题型，以及我对应的讲解，当做开胃菜，并且在文章的末尾我会给出获取每个分类推荐你去刷的题目的合集，记得看到底哦。\n查找表问题两个数组的交集 II-350\n给定两个数组，编写一个函数来计算它们的交集。\nbash示例 1:  \n  \n输入: nums1 = [1,2,2,1], nums2 = [2,2]  \n输出: [2,2]  \n\n示例 2:  \n  \n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]  \n输出: [4,9]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n为两个数组分别建立 map，用来存储 num -&gt; count 的键值对，统计每个数字出现的数量。\n然后对其中一个 map 进行遍历，查看这个数字在两个数组中分别出现的数量，取出现的最小的那个数量（比如数组 1 中出现了 1 次，数组 2 中出现了 2 次，那么交集应该取 1 次），push 到结果数组中即可。\njavascript/**  \n * @param &#123;number[]&#125; nums1  \n * @param &#123;number[]&#125; nums2  \n * @return &#123;number[]&#125;  \n */  \nlet intersect = function (nums1, nums2) &#123;  \n  let map1 = makeCountMap(nums1)  \n  let map2 = makeCountMap(nums2)  \n  let res = []  \n  for (let num of map1.keys()) &#123;  \n    const count1 = map1.get(num)  \n    const count2 = map2.get(num)  \n  \n    if (count2) &#123;  \n      const pushCount = Math.min(count1, count2)  \n      for (let i = 0; i &lt; pushCount; i++) &#123;  \n        res.push(num)  \n      &#125;  \n    &#125;  \n  &#125;  \n  return res  \n&#125;  \n  \nfunction makeCountMap(nums) &#123;  \n  let map = new Map()  \n  for (let i = 0; i &lt; nums.length; i++) &#123;  \n    let num = nums[i]  \n    let count = map.get(num)  \n    if (count) &#123;  \n      map.set(num, count + 1)  \n    &#125; else &#123;  \n      map.set(num, 1)  \n    &#125;  \n  &#125;  \n  return map  \n&#125;双指针问题最接近的三数之和-16\n给定一个包括  n 个整数的数组  nums  和 一个目标值  target。找出  nums  中的三个整数，使得它们的和与  target  最接近。返回这三个数的和。假定每组输入只存在唯一答案。\nbash示例：\n\n输入：nums = [-1,2,1,-4], target = 1\n\n输出：2\n\n解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)提示：\n3 &lt;= nums.length &lt;= 10^3``-10^3 &lt;= nums[i] &lt;= 10^3``-10^4 &lt;= target &lt;= 10^4\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/3sum-closest\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n先按照升序排序，然后分别从左往右依次选择一个基础点 i（0 &lt;= i &lt;= nums.length - 3），在基础点的右侧用双指针去不断的找最小的差值。\n假设基础点是 i，初始化的时候，双指针分别是：\n\n**left**：i + 1，基础点右边一位。\n\nright: nums.length - 1 数组最后一位。\n\n\n然后求此时的和，如果和大于 target，那么可以把右指针左移一位，去试试更小一点的值，反之则把左指针右移。\n在这个过程中，不断更新全局的最小差值 min，和此时记录下来的和 res。\n最后返回 res 即可。\njavascript/**  \n * @param &#123;number[]&#125; nums  \n * @param &#123;number&#125; target  \n * @return &#123;number&#125;  \n */  \nlet threeSumClosest = function (nums, target) &#123;  \n  let n = nums.length  \n  if (n === 3) &#123;  \n    return getSum(nums)  \n  &#125;  \n  // 先升序排序 此为解题的前置条件  \n  nums.sort((a, b) =&gt; a - b)  \n  \n  let min = Infinity // 和 target 的最小差  \n  let res  \n  \n  // 从左往右依次尝试定一个基础指针 右边至少再保留两位 否则无法凑成3个  \n  for (let i = 0; i &lt;= nums.length - 3; i++) &#123;  \n    let basic = nums[i]  \n    let left = i + 1 // 左指针先从 i 右侧的第一位开始尝试  \n    let right = n - 1 // 右指针先从数组最后一项开始尝试  \n  \n    while (left &lt; right) &#123;  \n      let sum = basic + nums[left] + nums[right] // 三数求和  \n      // 更新最小差  \n      let diff = Math.abs(sum - target)  \n      if (diff &lt; min) &#123;  \n        min = diff  \n        res = sum  \n      &#125;  \n      if (sum &lt; target) &#123;  \n        // 求出的和如果小于目标值的话 可以尝试把左指针右移 扩大值  \n        left++  \n      &#125; else if (sum &gt; target) &#123;  \n        // 反之则右指针左移  \n        right--  \n      &#125; else &#123;  \n        // 相等的话 差就为0 一定是答案  \n        return sum  \n      &#125;  \n    &#125;  \n  &#125;  \n  \n  return res  \n&#125;  \n  \nfunction getSum(nums) &#123;  \n  return nums.reduce((total, cur) =&gt; total + cur, 0)  \n&#125;滑动窗口问题无重复字符的最长子串-3\n给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。\n示例  1\nbash输入: &quot;abcabcbb&quot;  \n输出: 3  \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2\nbash输入: &quot;bbbbb&quot;  \n输出: 1  \n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3\nbash输入: &quot;pwwkew&quot;  \n输出: 3  \n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。  \n     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n这题是比较典型的滑动窗口问题，定义一个左边界 left 和一个右边界 right，形成一个窗口，并且在这个窗口中保证不出现重复的字符串。\n这需要用到一个新的变量 freqMap，用来记录窗口中的字母出现的频率数。在此基础上，先尝试取窗口的右边界再右边一个位置的值，也就是 str[right + 1]，然后拿这个值去 freqMap 中查找：\n\n这个值没有出现过，那就直接把 right ++，扩大窗口右边界。\n\n如果这个值出现过，那么把 left ++，缩进左边界，并且记得把 str[left] 位置的值在 freqMap 中减掉。\n\n\n循环条件是 left &lt; str.length，允许左边界一直滑动到字符串的右界。\njavascript/**  \n * @param &#123;string&#125; s  \n * @return &#123;number&#125;  \n */  \nlet lengthOfLongestSubstring = function (str) &#123;  \n  let n = str.length  \n  // 滑动窗口为s[left...right]  \n  let left = 0  \n  let right = -1  \n  let freqMap = &#123;&#125; // 记录当前子串中下标对应的出现频率  \n  let max = 0 // 找到的满足条件子串的最长长度  \n  \n  while (left &lt; n) &#123;  \n    let nextLetter = str[right + 1]  \n    if (!freqMap[nextLetter] &amp;&amp; nextLetter !== undefined) &#123;  \n      freqMap[nextLetter] = 1  \n      right++  \n    &#125; else &#123;  \n      freqMap[str[left]] = 0  \n      left++  \n    &#125;  \n    max = Math.max(max, right - left + 1)  \n  &#125;  \n  \n  return max  \n&#125;链表问题两两交换链表中的节点-24\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例:\nbash给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n这题本意比较简单，1 -&gt; 2 -&gt; 3 -&gt; 4 的情况下可以定义一个递归的辅助函数 helper，这个辅助函数对于节点和它的下一个节点进行交换，比如 helper(1) 处理 1 -&gt; 2，并且把交换变成 2 -&gt; 1 的尾节点 1的next继续指向 helper(3)也就是交换后的 4 -&gt; 3。\n边界情况在于，如果顺利的作了两两交换，那么交换后我们的函数返回出去的是 交换后的头部节点，但是如果是奇数剩余项的情况下，没办法做交换，那就需要直接返回 原本的头部节点。这个在 helper函数和主函数中都有体现。\njavascriptlet swapPairs = function (head) &#123;  \n  if (!head) return null  \n  let helper = function (node) &#123;  \n    let tempNext = node.next  \n    if (tempNext) &#123;  \n      let tempNextNext = node.next.next  \n      node.next.next = node  \n      if (tempNextNext) &#123;  \n        node.next = helper(tempNextNext)  \n      &#125; else &#123;  \n        node.next = null  \n      &#125;  \n    &#125;  \n    return tempNext || node  \n  &#125;  \n  \n  let res = helper(head)  \n  \n  return res || head  \n&#125;深度优先遍历问题二叉树的所有路径-257\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n说明:  叶子节点是指没有子节点的节点。\n示例\nbash输入:  \n  \n   1  \n /   \\  \n2     3  \n \\  \n  5  \n  \n输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]  \n  \n解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-tree-paths\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n用当前节点的值去拼接左右子树递归调用当前函数获得的所有路径。\n也就是根节点拼上以左子树为根节点得到的路径，加上根节点拼上以右子树为根节点得到的所有路径。\n直到叶子节点，仅仅返回包含当前节点的值的数组。\njavascriptlet binaryTreePaths = function (root) &#123;  \n  let res = []  \n  if (!root) &#123;  \n    return res  \n  &#125;  \n  \n  if (!root.left &amp;&amp; !root.right) &#123;  \n    return [`$&#123;root.val&#125;`]  \n  &#125;  \n  \n  let leftPaths = binaryTreePaths(root.left)  \n  let rightPaths = binaryTreePaths(root.right)  \n  \n  leftPaths.forEach((leftPath) =&gt; &#123;  \n    res.push(`$&#123;root.val&#125;-&gt;$&#123;leftPath&#125;`)  \n  &#125;)  \n  rightPaths.forEach((rightPath) =&gt; &#123;  \n    res.push(`$&#123;root.val&#125;-&gt;$&#123;rightPath&#125;`)  \n  &#125;)  \n  \n  return res  \n&#125;广度优先遍历（BFS）问题在每个树行中找最大值-515\nhttps://leetcode-cn.com/problems/find-largest-value-in-each-tree-row\n您需要在二叉树的每一行中找到最大的值。\nbash输入:  \n  \n          1  \n         / \\  \n        3   2  \n       / \\   \\  \n      5   3   9  \n  \n输出: [1, 3, 9]\n这是一道典型的 BFS 题目，BFS 的套路其实就是维护一个 queue 队列，在读取子节点的时候同时把发现的孙子节点 push 到队列中，但是先不处理，等到这一轮队列中的子节点处理完成以后，下一轮再继续处理的就是孙子节点了，这就实现了层序遍历，也就是一层层的去处理。\n但是这里有一个问题卡住我了一会，就是如何知道当前处理的节点是哪个层级的，在最开始的时候我尝试写了一下二叉树求某个 index 所在层级的公式，但是发现这种公式只能处理「平衡二叉树」。\n后面看题解发现他们都没有专门维护层级，再仔细一看才明白层级的思路：\n其实就是在每一轮 while 循环里，再开一个 for 循环，这个 for 循环的终点是「提前缓存好的 length 快照」，也就是进入这轮 while 循环时，queue 的长度。其实这个长度就恰好代表了「一个层级的长度」。\n缓存后，for 循环里可以安全的把子节点 push 到数组里而不影响缓存的当前层级长度。\n另外有一个小 tips，在 for 循环处理完成后，应该要把 queue 的长度截取掉上述的缓存长度。一开始我使用的是 queue.splice(0, len)，结果速度只击败了 33%的人。后面换成 for 循环中去一个一个shift来截取，速度就击败了 77%的人。\njavascript/**  \n * @param &#123;TreeNode&#125; root  \n * @return &#123;number[]&#125;  \n */  \nlet largestValues = function (root) &#123;  \n  if (!root) return []  \n  let queue = [root]  \n  let maximums = []  \n  \n  while (queue.length) &#123;  \n    let max = Number.MIN_SAFE_INTEGER  \n    // 这里需要先缓存length 这个length代表当前层级的所有节点  \n    // 在循环开始后 会push新的节点 length就不稳定了  \n    let len = queue.length  \n    for (let i = 0; i &lt; len; i++) &#123;  \n      let node = queue[i]  \n      max = Math.max(node.val, max)  \n  \n      if (node.left) &#123;  \n        queue.push(node.left)  \n      &#125;  \n      if (node.right) &#123;  \n        queue.push(node.right)  \n      &#125;  \n    &#125;  \n  \n    // 本「层级」处理完毕，截取掉。  \n    for (let i = 0; i &lt; len; i++) &#123;  \n      queue.shift()  \n    &#125;  \n  \n    // 这个for循环结束后 代表当前层级的节点全部处理完毕  \n    // 直接把计算出来的最大值push到数组里即可。  \n    maximums.push(max)  \n  &#125;  \n  \n  return maximums  \n&#125;栈问题有效的括号-20\n给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n\n左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\n\n示例 1\nbash输入: &quot;()&quot;  \n输出: true示例 2\nbash输入: &quot;()[]&#123;&#125;&quot;  \n输出: true示例 3\nbash输入: &quot;(]&quot;  \n输出: false示例 4\nbash输入: &quot;([)]&quot;  \n输出: false示例 5\nbash输入: &quot;&#123;[]&#125;&quot;  \n输出: truehttps://leetcode-cn.com/problems/valid-parentheses\n\n提前记录好左括号类型 (, &#123;, [和右括号类型), &#125;, ]的映射表，当遍历中遇到左括号的时候，就放入栈 stack 中（其实就是数组），当遇到右括号时，就把 stack 顶的元素 pop 出来，看一下是否是这个右括号所匹配的左括号（比如 ( 和 ) 是一对匹配的括号）。\n当遍历结束后，栈中不应该剩下任何元素，返回成功，否则就是失败。\njavascript/**  \n * @param &#123;string&#125; s  \n * @return &#123;boolean&#125;  \n */  \nlet isValid = function (s) &#123;  \n  let sl = s.length  \n  if (sl % 2 !== 0) return false  \n  let leftToRight = &#123;  \n    &quot;&#123;&quot;: &quot;&#125;&quot;,  \n    &quot;[&quot;: &quot;]&quot;,  \n    &quot;(&quot;: &quot;)&quot;,  \n  &#125;  \n  // 建立一个反向的 value -&gt; key 映射表  \n  let rightToLeft = createReversedMap(leftToRight)  \n  // 用来匹配左右括号的栈  \n  let stack = []  \n  \n  for (let i = 0; i &lt; s.length; i++) &#123;  \n    let bracket = s[i]  \n    // 左括号 放进栈中  \n    if (leftToRight[bracket]) &#123;  \n      stack.push(bracket)  \n    &#125; else &#123;  \n      let needLeftBracket = rightToLeft[bracket]  \n      // 左右括号都不是 直接失败  \n      if (!needLeftBracket) &#123;  \n        return false  \n      &#125;  \n  \n      // 栈中取出最后一个括号 如果不是需要的那个左括号 就失败  \n      let lastBracket = stack.pop()  \n      if (needLeftBracket !== lastBracket) &#123;  \n        return false  \n      &#125;  \n    &#125;  \n  &#125;  \n  \n  if (stack.length) &#123;  \n    return false  \n  &#125;  \n  return true  \n&#125;  \n  \nfunction createReversedMap(map) &#123;  \n  return Object.keys(map).reduce((prev, key) =&gt; &#123;  \n    const value = map[key]  \n    prev[value] = key  \n    return prev  \n  &#125;, &#123;&#125;)  \n&#125;递归与回溯直接看我写的这两篇文章即可，递归与回溯甚至是平常业务开发中最常见的算法场景之一了，所以我重点总结了两篇文章。\n《前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合。》[1]\n前端「N 皇后」递归回溯经典问题图解[2]\n动态规划打家劫舍 - 198\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\nbash示例 1:  \n  \n输入: [1,2,3,1]\n\n输出: 4\n\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  \n  偷窃到的最高金额 = 1 + 3 = 4 。  \n\n示例 2:  \n  \n输入: [2,7,9,3,1]  \n\n输出: 12  \n\n解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。  \n  偷窃到的最高金额 = 2 + 9 + 1 = 12 。来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/house-robber 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n动态规划的一个很重要的过程就是找到「状态」和「状态转移方程」，在这个问题里，设 i 是当前屋子的下标，状态就是 以 i 为起点偷窃的最大价值\n在某一个房子面前，盗贼只有两种选择：偷或者不偷。\n\n偷的话，价值就是「当前房子的价值」+「下两个房子开始盗窃的最大价值」\n\n不偷的话，价值就是「下一个房子开始盗窃的最大价值」\n\n\n在这两个值中，选择最大值记录在 dp[i]中，就得到了以 i 为起点所能偷窃的最大价值。。\n动态规划的起手式，找基础状态，在这题中，以终点为起点的最大价值一定是最好找的，因为终点不可能再继续往后偷窃了，所以设 n 为房子的总数量， dp[n - 1] 就是 nums[n - 1]，小偷只能选择偷窃这个房子，而不能跳过去选择下一个不存在的房子。\n那么就找到了动态规划的状态转移方程：\nbash// 抢劫当前房子  \nrobNow = nums[i] + dp[i + 2] // 「当前房子的价值」 + 「i + 2 下标房子为起点的最大价值」  \n  \n// 不抢当前房子，抢下一个房子  \nrobNext = dp[i + 1] //「i + 1 下标房子为起点的最大价值」  \n  \n// 两者选择最大值  \ndp[i] = Math.max(robNow, robNext)并且从后往前求解。\njavascriptfunction (nums) &#123;  \n  if (!nums.length) &#123;  \n    return 0;  \n  &#125;  \n  let dp = [];  \n  \n  for (let i = nums.length - 1; i &gt;= 0; i--) &#123;  \n    let robNow = nums[i] + (dp[i + 2] || 0)  \n    let robNext = dp[i + 1] || 0  \n  \n    dp[i] = Math.max(robNow, robNext)  \n  &#125;  \n  \n  return dp[0];  \n&#125;;最后返回 以 0 为起点开始打劫的最大价值 即可。\n贪心算法问题分发饼干-455\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值  gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;&#x3D; gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n注意：\n你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。\nbash示例 1:  \n  \n输入: [1,2,3], [1,1]  \n  \n输出: 1  \n  \n解释:  \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。  \n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。  \n所以你应该输出1。  \n\n示例 2:  \n  \n输入: [1,2], [1,2,3]  \n  \n输出: 2  \n  \n解释:  \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。  \n你拥有的饼干数量和尺寸都足以让所有孩子满足。  \n所以你应该输出2.来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/assign-cookies 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n把饼干和孩子的需求都排序好，然后从最小的饼干分配给需求最小的孩子开始，不断的尝试新的饼干和新的孩子，这样能保证每个分给孩子的饼干都恰到好处的不浪费，又满足需求。\n利用双指针不断的更新 i 孩子的需求下标和 j饼干的值，直到两者有其一达到了终点位置：\n\n如果当前的饼干不满足孩子的胃口，那么把 j++ 寻找下一个饼干，不用担心这个饼干被浪费，因为这个饼干更不可能满足下一个孩子（胃口更大）。\n\n如果满足，那么 i++; j++; count++ 记录当前的成功数量，继续寻找下一个孩子和下一个饼干。\n\n\njavascript/**  \n * @param &#123;number[]&#125; g  \n * @param &#123;number[]&#125; s  \n * @return &#123;number&#125;  \n */  \nlet findContentChildren = function (g, s) &#123;  \n  g.sort((a, b) =&gt; a - b)  \n  s.sort((a, b) =&gt; a - b)  \n  \n  let i = 0  \n  let j = 0  \n  \n  let count = 0  \n  while (j &lt; s.length &amp;&amp; i &lt; g.length) &#123;  \n    let need = g[i]  \n    let cookie = s[j]  \n  \n    if (cookie &gt;= need) &#123;  \n      count++  \n      i++  \n      j++  \n    &#125; else &#123;  \n      j++  \n    &#125;  \n  &#125;  \n  \n  return count  \n&#125;必做题目其实写了这么多，以上分类所提到的题目，只是当前分类下比较适合作为例题来讲解的题目而已，在整个 LeetCode 学习过程中只是冰山一角。这些题可以作为你深入这个分类的一个入门例题，但是不可避免的是，你必须去下苦功夫刷每个分类下的其他经典题目。\n如果你信任我，你也可以在我维护的题解仓库的 Issues 中[3]获取各个分类下必做题目的详细题解（拿到了记得收藏），我跟着一个ACM 亚洲区奖牌获得者给出的提纲，整理了100+道必做题目的详细题解。\n那么什么叫必做题目呢？\n\n它核心考察算法思想，而不是奇巧淫技。\n\n它考察的知识点，可以举一反三的应用到很多相似题目上。\n\n面试热门题，大厂喜欢考这个题目，说明这个知识点很重要。\n\n\n当然你也可以去知乎等平台搜索相关的问题，也会有很多人总结，但是比我总结的全的不多见。100 多题说多也不多，说少也不少。认真学习、解答、吸收这些题目大概要花费1 个月左右的时间。但是相信我，1 个月以后你在算法方面会脱胎换骨，应对国内大厂的算法面试也会变得游刃有余。\n总结关于算法在工程方面有用与否的争论，已经是一个经久不衰的话题了。这里不讨论这个，我个人的观念是绝对有用的，只要你不是一个甘于只做简单需求的人，你一定会在后续开发架构、遇到难题的过程中或多或少的从你的算法学习中受益。\n再说的功利点，就算是为了面试，刷算法能够进入大厂也是你职业生涯的一个起飞点，大厂给你带来的的环境、严格的 Code Review、完善的导师机制和协作流程也是你作为工程师所梦寐以求的。\n希望这篇文章能让你不再继续害怕算法面试，跟着我一起攻下这座城堡吧，大家加油！\n参考资料[1]\n《前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合。》: https://juejin.im/post/5ee6d9026fb9a047e60815f1\n[2]\n前端「N 皇后」递归回溯经典问题图解: https://juejin.im/post/5eeafa406fb9a058b51e60c0\n[3]\n我维护的题解仓库的 Issues 中: https://github.com/sl1673495/leetcode-javascript/issues\n\n结语学如逆水行舟，不进则退\n2024 2 11\n","slug":"写给前端的算法进阶指南，我是如何两个月零基础刷200题","date":"2024-02-11T12:16:01.000Z","categories_index":"好文摘录","tags_index":"个人成长","author_index":"一小池勺"},{"id":"e77a14690b250ca8b028ed7676a06b30","title":"天生不聪明","content":"本文是我和慕课网合作的第一篇文字内容。文末有慕课网支持的重磅福利。天生聪明的你，一定不要错过。\n\n因为我在慕课网上讲了几门算法课程，所以经常收到一些同学的提问。除了技术性的问题，一个很常见的问题就是：老师，我觉得算法好难，自己不够聪明，要花好长时间才能理解一个算法，刷题效率也很低，半天能过一道题就不错了，我该怎么办？\n关于如何学习算法，如何刷题，或者到底要不要刷题，有时间我再写更多的文章总结。有兴趣的同学，可以先参考我之前的文章《如果高效学习有什么秘诀的话，那就都在这里了》，相信也会有不小的收获。这篇文章，我想探讨一下 “聪明” 这个话题。\n1\n和大多数人一样，我也是一个从小渴望聪明的孩纸。可是，依然和大多数人一样，我的身边有着无数比我聪明，让我无时无刻不意识到，自己是如此之笨的孩纸。那些聪明的别人家的孩子，或者反应更快，或者理解力强；奥数不用学就将近满分，英语课文读一遍就能背下来；更重要的是，在大家都情窦初开的年纪，他们把起妹来还花样百出，妙语连珠，见多识广，这实在是太！让！人！懊！恼！了！\n于是，我在初中下决心好好学习一下怎么变聪明——通过这个举动，你可以看出我是多么不聪明的孩纸。我到家门口的新华书店，用可以买5本机器猫漫画的“巨款”，买了一本类似叫做《如何变聪明》的书。然后，就没有然后了。那本书讲的是什么，我现在已经完全忘记了。但是我敢肯定的是，我没有看完它。因为，我意识到了，这本告诉我如何变聪明的书，是无论如何都不能让我变聪明的。或许那时，我是绝望的，坚信自己只能这么不聪明下去了。但是现在回头看，我发现自己很可能在那时，就接近了一个真理。\n2\n随着年龄的长大，我慢慢发现了一个现象。那些小时候我认为极度聪明的小伙伴们，长大以后，似乎并没有像我曾经坚信的那样，干出一番大成就。当然，我这么说为时过早。我的那些小伙伴们都还年轻，人家可能10年后20年后就会干出一番大成就，甚至拯救全人类。只不过，在现阶段，大多数人的成就，在我看来，和他们的聪明程度是不成正比的。\n有一天，我和老婆闲聊，说起了这个话题。老婆是心理学博士。而“聪明”这个话题，其实是心理学领域一直在研究的话题。可能一般人对心理学的认识都是《无间道》里的陈慧琳那个角色，洋气的称呼叫shrink，坐在那里倾听人的烦恼，缓解别人的情绪，而已。\n但其实，心理学所包含的内容比“心理疾病”或者“情绪失调”要广袤的多。简单来说，只要和你的大脑的思考有关，就是心理学家感兴趣的话题。而“学习”这个事情，是所有人都必然会经历的一种大脑活动，自然也是心理学家的研究重点。在心理学，更专业的术语叫“认知能力”。我们是如何认知的？什么在影响我们的认知？怎么提高我们的认知？这些统统是心理学研究的范畴。而对于“聪明”这个因素，早就被一票野心勃勃想解开人类大脑之谜的心理学家们关注多年了。\n3\n在心理学界，最经典的和聪明相关的研究，应该是属于斯坦福大学的心理学教授Carol S. Dweck的。\nDweck教授对聪明的研究，首先从一个很简单的问题开始，聪明到底来源于哪里？有的人认为聪明是天生的；有的认为聪明是后天的。这两种说法都有道理，但我们却无法实际去检验。我们很难对一个人为定义的抽象概念——聪明，去客观地探讨它的来源。所以，Dweck教授将关注点放到了另一个地方：不同的人认为聪明源自哪里？\n于是，Dweck教授找来了57个三岁的孩子，用尽一切手段，尽量客观的来获得这些小孩子对聪明的看法：聪明到底是天生的？还是后天学习来的？当有了这个样本以后，Dweck教授的团队跟踪这些小孩子直至小学四年级——整整七年。结果发现：认为聪明是后天学习来的孩子，学习成绩明显的高于相信聪明是天生的孩子。\n可能有的同学会质疑。毕竟三岁的孩子，在表达对如此抽象的问题上，会有不小的偏差。尽管Dweck教授在研究过程中已经使用各种手段，想尽办法获得孩子们的真实想法了，但还是会显得说服力不够强。所以，Dweck教授进行了新的一轮实验。这次，实验对象是美国的初中生。\n和中国一样，大多数美国学生，在进入初中阶段，数学成绩会产生大幅度下降。这其中的原因很多，有学习内容产生巨大变化的原因，也有学生进入青春期的原因。这些原因不是Dweck教授关注的重点。Dweck教授关注的是，不同学生对聪明的看法不同，是否会在这个阶段造成他们数学成绩的差异？\n于是Dweck教授找来了373名美国刚上初一的学生，询问他们对聪明的看法。初一的学生已经可以完全清楚地表达自己的观点了，甚至很多学生已经有了相当成熟的体系性思考。Dweck教授拿到这373名学生对聪明的看法之后，跟踪他们直至初二结束。结果发现：相信聪明是天生的学生，数学成绩持续下降；而那些相信聪明是后天的学习可以弥补的学生，数学成绩是不降反升的！\n4\n上述实验，只是Dweck教授观察得到的结论。只是观察，是无法满足科学家们的好奇心的。所有的科学家都是好奇宝宝，像小孩子一样，观察完以后，一定要用手捅捅自己的研究对象。Dweck教授开始了她的下一个实验。\n这次，Dweck教授找来了99个数学成绩在初一有所下滑的学生，把他们分成两组，分别给他们“开小灶”。不过，对于这两组学生，开小灶的内容是截然不同的。\n对于第一组同学，Dweck教授给他们上“补习班”——讲解具体的数学知识点。数学考不好？来来来，课后我们多做点儿练习。\n对于第二组同学，Dweck教授则给他们用近八周的时间，开展了一场别开生面的“认知神经科学”基础课。课程的内容，主要就是向大家传授当前认知神经科学的最新研究成果：人类的大脑是如何学习到知识的？答案是通过不断的思考。在不断地学习和思考的过程中，人的大脑内部产生着剧烈的神经活动，迫使脑神经之间建立了更多的连接。随着神经元之间连接越来越多，我们对问题的认识也就越来越深刻，遇到类似问题反应也会越来越快。不仅如此，甚至还能触类旁通，举一反三，乃至和其他的领域结合，产生创新性的想法。这表现出来，就是你更聪明了。\n换句话说，Dweck教授在想尽办法，用科学的事实，告诉第二组学生：聪明是可以靠不断的学习，思考获得的。至于你们学什么，怎么学，我不管，你们看着办！\n在给这两组学生加完“小灶”之后，Dweck教授又跟踪了一年这两组学生的成绩，第一组学生的成绩继续持续下降；而第二组学生的数学成绩停止了下降，甚至有所提升。\nDweck的实验告诉了我们，我们对聪明的看法，会影响，甚至是严重影响我们的表现！\n5\n为了凿实这个实验结论，Dweck教授做了一组最为经典的实验。\n他找来了400个五年级的小学生，让他们做一套智力测验。之后，Dweck教授把这400个学生分成两组。不管他们的成绩如何，Dweck教授都对第一组的同学说：这个测试非常难，你能拿到这个成绩，说明你特别聪明；而对第二组的同学说：这个测试非常难，你能拿到这个成绩，说明你特别努力。\n然后，Dweck教授让这400个学生再做一次智力测试。这次，所有的同学有了选择：他们可以选择做一套和上次一样难的测试；也可以选择做一套更难，更具有挑战，但被Dweck教授形容为也是更有趣的测试。结果，被夸努力的学生，有92%选择了比上次更难的挑战；而被夸聪明的学生，则只有33%选择了比上次更难的挑战。\n为什么？或许是因为“偶像包袱”。被夸聪明的同学，怕自己做了更难的问题，错误太多，就显得自己不是那么聪明了。\n最后，Dweck教授让这400名学生做第三次智力测试。这次测试的问题，和第一次的难度相同。结果，被夸努力的学生，整体成绩上升了近30%，而被夸聪明的同学，整体成绩下降了20%。\n为什么？被夸努力的学生，大部分同学都接受了更难得挑战。做过难的问题，再做普通的题，普通的题就变得简单了。至于被夸聪明的同学，或许是因为患得患失，生怕自己做错了被别人说其实你不聪明，结果，成绩反而下降了。\nDweck教授因为这一系列著名的实验，极大地改变和完善了人们对学习，自我认知，教育等领域的看法。她获得了美国心理学界的至高荣誉——心理学杰出科学贡献奖；同时获得了教育研究领域的“诺贝尔奖”——一丹奖。她现在是美国文理学院的院士。虽然她的研究也有不小的争议，但现在，她仍然坚持在自己的领域为世界做着贡献。\n\n6\n相信大多数同学都看懂了，Dweck教授的实验，告诉了我们一个血淋淋的事实——人们对聪明的看法，会极大地影响人们的行为。聪明有没有天生的成分？大多数心理学家，认知科学家和脑科学家还在研究。但是，Dweck教授告诉我们的是：聪明不是固定的。只要你相信聪明是靠努力可以弥补的，并且努力下去，你就会变聪明。\n我们现在可以回到文章开头的问题了：觉得算法好难，自己不够聪明，要花好长时间才能理解一个算法，刷题效率也很低，半天能过一道题就不错了，我该怎么办？\n对此，我的回答是：对不起，我没有更好的方法。并且，我坚信，不仅我没有，这个世界上根本不存在这样的一个方法。我经常使用反证法来阐述这个问题：假设这个世界存在一个简单、可行、快速、高效的学会算法的方法，那么，所有的人早就使用这个方法学习算法了，所有的人也早就成为算法大神了，算法也就不是什么让人头疼的事情了。可这是和现实不相符的。所以，这个方法不存在。\n以上证明不仅适用于算法学习，对各个领域的学习都适用。\n但是，如果能给你一点安慰的话，我想实话告诉你：在我刚开始接触算法的时候，我也觉得算法好难，自己不够聪明，要花很长时间才能理解一个算法，刷题效率也特别低，别说半天一道题了，一个礼拜死磕一道题都是家常便饭。\n或许，你我都是天生不聪明的人。\n不过，好在，天生不聪明似乎并没有什么关系。因为，只要你相信聪明是靠努力可以弥补的，并且努力下去，你终将变得很“聪明”。甚至，你会超越这种“聪明”，理解一个很嘻哈又很深刻的道理：聪明不是什么大不了不起的事儿。\n据统计，无论是诺贝尔奖的获奖者，还是美国总统，平均智商都和普通人没有有显著差距。而和普通人智商有巨大差异的群体，门萨高智商俱乐部应该是典型了。可惜，很少听说门萨高智商俱乐部的成员，在任何领域，是的，任何领域，对世界，对社会有重大的贡献。\n除了一堆稀奇古怪的智力题。\n7\n我用了这么长的文章，回答了一个问题。其实最后答案是一句废话：要努力。换句文绉绉的表示法，就是：万事无他，唯手熟尔。\n当然，我也承认，只是努力，可能并不够。或者说，至少，还有改进的余地。人生是一个维度极其丰富的过程，用任何一个单一维度去解释它，都是极其幼稚可笑的。比如，我就认为，另外一个非常重要的维度，叫做“选择”。我们经常听到互联网上的一种声音：选择大于努力。对于这个观点怎么看？大家可以期待一下我的一篇文章，我会聊聊我对于“选择”的看法。\n但是，在这篇文章里，作为计算机专业的同学，如果想学好算法，将来成为一个计算机科学领域的大神，并且你已经深刻地明白了努力就能更聪明，却不知如何选择从哪里开始努力的话… 咳咳咳，我建议大家从选择我在慕课网上的算法课程开始。\n《玩转数据结构》《算法与数据结构》 两门课程，以经典算法和数据结构的底层实现为主，通过对经典算法和数据结构从零到一，一步一步的底层实现，让大家真正理解每一个算法和数据结构。从最简单的动态数组，链表，栈和队列，排序；到复杂的红黑树，AVL树，线段树，一应俱全。\n《Python3入门机器学习》，则是系统讲解当下大热的机器学习领域的基础算法。有很多同学横向比较了很多平台的机器学习课程以后，偷偷告诉我，我的机器学习课程是最好的，让我受宠若惊。\n至于《看得见的算法》，则带领大家使用Java语言，用可视化的形式，真正使用算法，编写出了很多有趣的小Demo，比如迷宫的自动生成\n\n结语乖乖，要自信，要勇敢\n你要知道，如果你告诉你自己不聪明\n其实会在很大程度上影响你日常学习工作过程中的很多的行为\n所以呀\n自信点、勇敢点\n努力吧\n学如逆水行舟，不进则退\n2024 02 11\n","slug":"天生不聪明","date":"2024-02-11T05:17:40.000Z","categories_index":"好文摘录","tags_index":"个人成长","author_index":"一小池勺"},{"id":"a20f42ee8373946d2898ea566c51817c","title":"821.字符串的最短距离-力扣（LeetCode）","content":"题目详情简单\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。返回一个整数数组 answer ，其中 answer.length &#x3D;&#x3D; s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n示例\n示例 1：\n\n输入：\nbashs = &quot;loveleetcode&quot;, c = &quot;e&quot;输出：\nbash[3,2,1,0,1,0,0,1,2,2,1,0]解释：\n字符 ‘e’ 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(0 - 3) &#x3D; 3 。\n距下标 1 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(1 - 3) &#x3D; 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 ‘e’ 都离它最近，但距离是一样的 abs(4 - 3) &#x3D;&#x3D; abs(4 - 5) &#x3D; 1 。\n距下标 8 最近的 ‘e’ 出现在下标 6 ，所以距离为 abs(8 - 6) &#x3D; 2 。\n\n示例 2：\n\n输入：\nbashs = &quot;aaab&quot;, c = &quot;b&quot;输出：\nbash[3,2,1,0]提示\n1 &lt;&#x3D; s.length &lt;&#x3D; 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n题解javascript/**\n  @ 一小池勺 \n * @param &#123;string&#125; s\n * @param &#123;character&#125; c\n * @return &#123;number[]&#125;\n  @ 2024 1 30\n */\nvar shortestToChar = function(S, C) &#123;\n  const resultArray = new Array(S.length).fill(0)\n  let NowTargetCharC_Index = 0\n\n  // 一次遍历\n  const charArray = Array.from(S) // 将字符串转换为数组\n  charArray.forEach((item, index) =&gt; &#123;\n    if(item === C) &#123;\n      resultArray[index] = 0\n      NowTargetCharC_Index = index\n    &#125; else &#123;\n      // 针对当前的 i 元素 =&gt; 进行前后距离比较\n      resultArray[index] = Math.min(Math.abs(S.indexOf(C, index) - index), Math.abs(S.indexOf(C, NowTargetCharC_Index) - index))\n    &#125;\n  &#125;)\n\n  return resultArray\n&#125;代码思路\n创建一个与字符串长度相同的数组resultArray，并将其填充为0。\n\n初始化变量NowTargetCharC_Index为0，用于记录当前目标字符C的索引位置。\n\n将字符串转换为字符数组charArray。\n\n使用forEach方法遍历charArray中的每个字符。\n\n如果当前字符等于目标字符C，将resultArray相应索引位置的值设置为0，并更新NowTargetCharC_Index为当前索引。\n\n如果当前字符不等于目标字符C，通过indexOf方法分别计算当前索引位置到目标字符C的前一个索引位置和后一个索引位置的距离，并将较小的距离赋值给resultArray相应索引位置。\n\n返回resultArray作为结果。\n\n\n","slug":"821-字符串的最短距离-力扣（LeetCode）","date":"2024-02-07T09:59:44.000Z","categories_index":"LeetCode","tags_index":"LeetCode 解题报告","author_index":"一小池勺"},{"id":"90b0cd7f9ee3294d68bd40236729dc06","title":"前端框架开发【九】实现过渡动画","content":"1. 基本过渡动画1.1. 认识过渡动画在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验：\n\nReact框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group\n\nVue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果\n\n\n我们来看一个案例：\n\nHello World的显示和隐藏\n\n通过下面的代码实现，是不会有任何动画效果的\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;show = !show&quot;&gt;  \n        Toogle  \n        &lt;/button&gt;  \n          \n        &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;没有动画的情况下，整个内容的显示和隐藏会非常的生硬：\n\n如果我们希望给单元素或者组件实现过渡动画，可以使用 transition 内置组件来完成动画；\n\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡：\n\n条件渲染 (使用 v-if)\n\n条件展示 (使用 v-show)\n\n动态组件\n\n组件根节点\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;show = !show&quot;&gt;  \n        Toogle  \n        &lt;/button&gt;  \n          \n        &lt;transition name=&quot;fade&quot;&gt;  \n        &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n.fade-enter-from,  \n.fade-leave-to &#123;  \nopacity: 0;  \n&#125;  \n  \n.fade-enter-to,  \n.fade-leave-from &#123;  \nopacity: 1;  \n&#125;  \n  \n.fade-enter-active,  \n.fade-leave-active &#123;  \ntransition: opacity 1s ease;  \n&#125;  \n&lt;/style&gt;我们会发现，Vue自动给h2元素添加了动画，这是什么原因呢？\n当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：\n\n1.自动嗅探目标元素是否应用了CSS过渡或者动画，如果是在恰当的时机添加&#x2F;删除 CSS类名\n\n2.如果 transition 组件提供了JavaScript钩子函数，这些钩子函数将在恰当的时机被调用\n\n3.如果没有找到JavaScript钩子并且也没有检测到CSS过渡&#x2F;动画，DOM插入、删除操作将会立即执行\n\n\n1.2. 过渡动画的class我们会发现上面提到了很多个class，事实上Vue就是帮助我们在这些class之间来回切换完成的动画：\n\nv-enter-from：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n\nv-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n\nv-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡&#x2F;动画完成之后移除。\n\nv-leave-from：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n\nv-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n\nv-leave-to：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡&#x2F;动画完成之后移除。\n\n\n\nclass的name命名规则如下：\n\n如果我们使用的是一个没有name的transition，那么所有的class是以 - 作为默认前缀；\n\n如果我们添加了一个name属性，比如 &lt;transtion name=&quot;why&quot;&gt;，那么所有的class会以 why- 开头；\n\n\n我们可以在上面的案例中增加位移的动画：\ncss  .fade-enter-from &#123;  \n    transform: translateX(-60px);  \n  &#125;  \n  \n  .fade-leave-to &#123;  \n    transform: translateX(60px);  \n  &#125;1.3. css动画的实现前面我们是通过transition来实现的动画效果，另外我们也可以通过animation来实现。\nhtml&lt;template&gt;  \n    &lt;div class=&quot;app&quot;&gt;  \n        &lt;button @click=&quot;show = !show&quot;&gt;  \n        Toogle  \n        &lt;/button&gt;  \n          \n        &lt;transition name=&quot;bounce&quot;&gt;  \n            &lt;h2 v-if=&quot;show&quot;&gt;  \n            但是太阳，他每时每刻都是夕阳也都是旭日。当他熄灭着走下山去收尽苍凉残照之际，正是他在另一面燃烧着爬上山巅布散烈烈朝辉之时。那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。  \n            &lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n.app &#123;  \nwidth: 500px;  \nmargin: 0 auto;  \n&#125;  \n  \n.bounce-enter-active &#123;  \nanimation: bounce-in 0.5s;  \n&#125;  \n  \n.bounce-leave-active &#123;  \nanimation: bounce-in 0.5s reverse;  \n&#125;  \n  \n@keyframes bounce-in &#123;  \n0% &#123;  \ntransform: scale(0)  \n&#125;  \n50% &#123;  \ntransform: scale(1.25)  \n&#125;  \n100% &#123;  \ntransform: scale(1);  \n&#125;  \n&#125;  \n&lt;/style&gt;1.4. transition常见属性1.4.1. 同时使用过渡和动画Vue为了知道过渡的完成，内部是在监听  transitionend 或 animationend，到底使用哪一个取决于元素应用的CSS规则：\n\n如果我们只是使用了其中的一个，那么Vue能自动识别类型并设置监听；\n\n但是如果我们同时使用了过渡和动画呢？\n\n并且在这个情况下可能某一个动画执行结束时，另外一个动画还没有结束；\n\n在这种情况下，我们可以设置 type 属性为 animation 或者 transition 来明确的告知Vue监听的类型；\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;div&gt;  \n        &lt;button @click=&quot;show = !show&quot;&gt;  \n        Toogle  \n        &lt;/button&gt;  \n        &lt;/div&gt;  \n          \n        &lt;transition name=&quot;why&quot;  \n        type=&quot;transition&quot;  \n        @after-enter=&quot;afterEnter&quot;&gt;  \n            &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        afterEnter() &#123;  \n            console.log(&quot;进入完成&quot;);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n  \nh2 &#123;  \ndisplay: inline-block;  \n&#125;  \n  \n.why-enter-from,  \n.why-leave-to &#123;  \nopacity: 0;  \n&#125;  \n  \n.why-enter-to,  \n.why-leave-from &#123;  \nopacity: 1;  \n&#125;  \n  \n.why-enter-active,  \n.why-leave-active &#123;  \ntransition: opacity 1s ease;  \n&#125;  \n  \n.why-enter-active &#123;  \nanimation: move 5s ease;  \n&#125;  \n  \n@keyframes move &#123;  \n0% &#123;  \ntransform: scale(0)  \n&#125;  \n  \n50% &#123;  \ntransform: scale(1.25)  \n&#125;  \n  \n100% &#123;  \ntransform: scale(1)  \n&#125;  \n&#125;  \n&lt;/style&gt;1.4.2. 显示的指定过渡时间我们也可以显示的来指定过渡的时间，通过 duration 属性。\nduration可以设置两种类型的值：\n\nnumber类型：同时设置进入和离开的过渡时间\n\nobject类型：分别设置进入和离开的过渡时间\n\n\nnumber类型的值：\nhtml&lt;transition name=&quot;why&quot;  \ntype=&quot;transition&quot;  \n@after-enter=&quot;afterEnter&quot;  \n:duration=&quot;3000&quot;&gt;  \n&lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n&lt;/transition&gt;object类型的值：\nhtml&lt;transition name=&quot;why&quot;  \ntype=&quot;transition&quot;  \n@after-enter=&quot;afterEnter&quot;  \n:duration=&quot;&#123;enter: 800, leave: 1000&#125;&quot;&gt;  \n&lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n&lt;/transition&gt;1.4.3. 过渡的模式mode我们来看当前的动画在两个元素之间切换的时候存在的问题：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;div&gt;  \n            &lt;button @click=&quot;show = !show&quot;&gt;  \n            Toogle  \n            &lt;/button&gt;  \n        &lt;/div&gt;  \n          \n        &lt;transition name=&quot;why&quot;&gt;  \n            &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n            &lt;h2 v-else&gt;你好啊,李银河&lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;我们会发现 Hello World 和 你好啊，李银河是同时存在的：\n\n这是因为默认情况下进入和离开动画是同时发生的\n\n如果确实我们希望达到这个的效果，那么是没有问题\n\n\n但是如果我们不希望同时执行进入和离开动画，那么我们需要设置transition的过渡模式：\n\nin-out: 新元素先进行过渡，完成之后当前元素过渡离开\n\nout-in: 当前元素先进行过渡，完成之后新元素过渡进入\n\n\n1.4.4. 动态组件的切换上面的示例同样适用于我们的动态组件：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;div&gt;  \n            &lt;button @click=&quot;show = !show&quot;&gt;  \n            Toogle  \n            &lt;/button&gt;  \n        &lt;/div&gt;  \n          \n        &lt;transition name=&quot;why&quot;&gt;  \n            &lt;component :is=&quot;show ? &#39;home&#39;: &#39;about&#39;&quot;&gt;&lt;/component&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;1.4.5. appear初次渲染默认情况下，首次渲染的时候是没有动画的，如果我们希望给他添加上去动画，那么就可以增加另外一个属性appear：\nhtml&lt;transition name=&quot;why&quot; appear&gt;  \n    &lt;component :is=&quot;show ? &#39;home&#39;: &#39;about&#39;&quot;&gt;&lt;/component&gt;  \n&lt;/transition&gt;2. 结合第三方库2.1. 结合animate库2.1.1. 认识animate.css如果我们手动一个个来编写这些动画，那么效率是比较低的，所以在开发中我们可能会引用一些第三方库的动画库，比如animate.css。\n什么是animate.css呢？\n\nAnimate.css is a library of ready-to-use, cross-browser animations for use in your web projects. Great for emphasis, home pages, sliders, and attention-guiding hints.\n\nAnmate.css是一个已经准备好的、跨平台的动画库为我们的web项目，对于强调、主页、滑动、注意力引导非常有用\n\n\n如何使用Animate库呢？\n\n第一步：需要安装animate.css库\n\n第二步：导入animate.css库的样式\n\n第三步：使用animation动画或者animate提供的类\n\n\n安装animate.css：\nbashnpm install animate.css在main.js中导入animate.css：\njavascriptimport &quot;animate.css&quot;;2.1.2. 自定义过渡类名我们可以通过以下 attribute 来自定义过渡类名：\n\nenter-from-class\n\nenter-active-class\n\nenter-to-class\n\nleave-from-class\n\nleave-active-class\n\nleave-to-class\n\n\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css. 结合使用十分有用。\n2.1.3. animate.css使用animate.css的原理非常简单，就是帮我们提前写好了很多的动画而已：\n可以查看animate.css的源代码\ncss@keyframes bounce &#123;  \n  from,  \n  20%,  \n  53%,  \n  to &#123;  \n    -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);  \n    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);  \n    -webkit-transform: translate3d(0, 0, 0);  \n    transform: translate3d(0, 0, 0);  \n  &#125;  \n  \n  40%,  \n  43% &#123;  \n    -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);  \n    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);  \n    -webkit-transform: translate3d(0, -30px, 0) scaleY(1.1);  \n    transform: translate3d(0, -30px, 0) scaleY(1.1);  \n  &#125;  \n  \n  70% &#123;  \n    -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);  \n    animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);  \n    -webkit-transform: translate3d(0, -15px, 0) scaleY(1.05);  \n    transform: translate3d(0, -15px, 0) scaleY(1.05);  \n  &#125;  \n  \n  80% &#123;  \n    -webkit-transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);  \n    transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);  \n    -webkit-transform: translate3d(0, 0, 0) scaleY(0.95);  \n    transform: translate3d(0, 0, 0) scaleY(0.95);  \n  &#125;  \n  \n  90% &#123;  \n    -webkit-transform: translate3d(0, -4px, 0) scaleY(1.02);  \n    transform: translate3d(0, -4px, 0) scaleY(1.02);  \n  &#125;  \n&#125;  \n.animate__bounce &#123;  \n  -webkit-animation-name: bounce;  \n  animation-name: bounce;  \n  -webkit-transform-origin: center bottom;  \n  transform-origin: center bottom;  \n&#125;接下来在使用的时候我们有两种用法：\n\n用法一：直接使用animate库中定义的 keyframes 动画\n\n用法二：直接使用animate库提供给我们的类\n\n\n方式一：直接使用动画名称\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;div&gt;  \n            &lt;button @click=&quot;show = !show&quot;&gt;  \n            Toogle  \n            &lt;/button&gt;  \n        &lt;/div&gt;  \n          \n        &lt;transition name=&quot;why&quot;&gt;  \n            &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \nh2 &#123;  \ndisplay: inline-block;  \n&#125;  \n  \n.why-enter-active &#123;  \nanimation: flip 1s;  \n&#125;  \n  \n.why-leave-active &#123;  \nanimation: flip 1s reverse;  \n&#125;  \n&lt;/style&gt;方式二：使用动画的类名\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;div&gt;  \n            &lt;button @click=&quot;show = !show&quot;&gt;  \n            Toogle  \n            &lt;/button&gt;  \n        &lt;/div&gt;  \n          \n        &lt;transition name=&quot;why&quot;  \n        enter-active-class=&quot;animate__animated animate__lightSpeedInRight&quot;  \n        leave-active-class=&quot;animate__animated animate__lightSpeedOutRight&quot;&gt;  \n            &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;2.2. 结合gsap库2.2.1. 认识gsap库某些情况下我们希望通过JavaScript来实现一些动画的效果，这个时候我们可以选择使用gsap库来完成。\n什么是gsap呢？\n\nGSAP是The GreenSock Animation Platform（GreenSock动画平台）的缩写\n\n它可以通过JavaScript为CSS属性、SVG、Canvas等设置动画，并且是浏览器兼容的\n\n\n这个库应该如何使用呢？\n\n第一步：需要安装gsap库\n\n第二步：导入gsap库\n\n第三步：使用对应的api即可\n\n\n我们先对库来进行一个安装：\nbashnpm install gsap2.2.2. JavaScript钩子在使用动画之前，我们先来看一下transition组件给我们提供的JavaScript钩子，这些钩子可以帮助我们监听动画执行到什么阶段了。\nhtml&lt;transition  \n@before-enter=&quot;beforeEnter&quot;  \n@enter=&quot;enter&quot;  \n@after-enter=&quot;afterEnter&quot;  \n@enter-cancelled=&quot;enterCancelled&quot;  \n@before-leave=&quot;beforeLeave&quot;  \n@leave=&quot;leave&quot;  \n@after-leave=&quot;afterLeave&quot;  \n@leave-cancelled=&quot;leaveCancelled&quot;  \n:css=&quot;false&quot;  \n&gt;  \n&lt;!-- ... --&gt;  \n&lt;/transition&gt;javascript&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        beforeEnter() &#123;  \n            console.log(&quot;beforeEnter&quot;);  \n        &#125;,  \n        enter(el, done) &#123;  \n            console.log(&quot;enter&quot;);  \n            done();  \n        &#125;,  \n        afterEnter() &#123;  \n            console.log(&quot;afterEnter&quot;)  \n        &#125;,  \n        enterCancelled() &#123;  \n            console.log(&quot;enterCancelled&quot;)  \n        &#125;,  \n          \n        beforeLeave() &#123;  \n            console.log(&quot;beforeLeave&quot;)  \n        &#125;,  \n        leave(el, done) &#123;  \n            console.log(&quot;leave&quot;);  \n            done();  \n        &#125;,  \n        afterLeave() &#123;  \n            console.log(&quot;afterLeave&quot;)  \n        &#125;,  \n        leaveCancelled() &#123;  \n            console.log(&quot;leaveCancelled&quot;)  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;当我们使用JavaScript来执行过渡动画时，需要进行 done 回调，否则它们将会被同步调用，过渡会立即完成。\n添加 :css=&quot;false&quot;，也会让 Vue 会跳过 CSS 的检测，除了性能略高之外，这可以避免过渡过程中 CSS 规则的影响。\n2.2.3. gsap库使用那么接下来我们就可以结合gsap库来完成动画效果：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;div&gt;  \n        &lt;button @click=&quot;show = !show&quot;&gt;  \n        Toogle  \n        &lt;/button&gt;  \n        &lt;/div&gt;  \n          \n        &lt;transition  \n        name=&quot;why&quot;  \n        @enter=&quot;enter&quot;  \n        @leave=&quot;leave&quot;&gt;  \n            &lt;h2 v-if=&quot;show&quot;&gt;Hello World&lt;/h2&gt;  \n        &lt;/transition&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport gsap from &#39;gsap&#39;;  \n  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            show: true  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        enter(el, done) &#123;  \n            gsap.from(el, &#123;  \n            scale: 0,  \n            x: 200,  \n            onComplete: done  \n            &#125;)  \n    &#125;,  \n      \n    leave(el, done) &#123;  \n            gsap.to(el, &#123;  \n            scale: 0,  \n            x: 200,  \n            onComplete: done  \n            &#125;)  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n  \nh2 &#123;  \ndisplay: inline-block;  \n&#125;  \n&lt;/style&gt;2.2.4. gsap数字变化在一些项目中，我们会见到数字快速变化的动画效果，这个动画可以很容易通过gsap来实现：\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;input type=&quot;number&quot; v-model.number=&quot;counter&quot; step=&quot;100&quot;&gt;  \n        &lt;h2&gt;&#123;&#123;animatedNumber&#125;&#125;&lt;/h2&gt;  \n        &lt;!-- 下面的写法也是可以的 --&gt;  \n        &lt;h2&gt;&#123;&#123;showNumber.toFixed(0)&#125;&#125;&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport gsap from &#39;gsap&#39;;  \n  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            counter: 0,  \n            showNumber: 0  \n        &#125;  \n    &#125;,  \n    computed: &#123;  \n        animatedNumber() &#123;  \n            return this.showNumber.toFixed(0);  \n        &#125;  \n    &#125;,  \n    watch: &#123;  \n        counter(newValue) &#123;  \n            gsap.to(this, &#123;duration: 1, showNumber: newValue&#125;)  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;3. 列表的过渡目前为止，过渡动画我们只要是针对单个元素或者组件的：\n\n要么是单个节点；\n\n要么是统一时间渲染多个节点中的一个；\n\n\n那么如果希望渲染的是一个列表，并且该列表中添加删除数据也希望有动画执行呢？\n\n这个时候我们要使用 &lt;transition-group&gt; 组件来完成；\n\n使用&lt;transition-group&gt; 有如下的特点：\n\n默认情况下，它不会渲染一个元素的包裹器，但是你可以指定一个元素并以 tag attribute 进行渲染；\n\n过渡模式不可用，因为我们不再相互切换特有的元素；\n\n内部元素总是需要提供唯一的 key attribute 值；\n\nCSS 过渡的类将会应用在内部的元素中，而不是这个组&#x2F;容器本身；\n\n\n3.1. 列表过渡的基本使用我们来做一个案例：\n\n案例是一列数字，可以继续添加或者删除数字；\n\n在添加和删除数字的过程中，对添加的或者移除的数字添加动画；\n\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;addNum&quot;&gt;添加数字&lt;/button&gt;  \n        &lt;button @click=&quot;removeNum&quot;&gt;删除数字&lt;/button&gt;  \n          \n        &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;  \n            &lt;span v-for=&quot;item in numbers&quot; :key=&quot;item&quot; class=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;  \n        &lt;/transition-group&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            numbers: [1, 2, 3, 4, 5, 6, 7, 8],  \n            nextNum: 10  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        randomIndex() &#123;  \n        return Math.floor(Math.random() * this.numbers.length)  \n        &#125;,  \n          \n        addNum() &#123;  \n            this.numbers.splice(this.randomIndex(), 0, this.nextNum++)  \n        &#125;,  \n        removeNum() &#123;  \n            this.numbers.splice(this.randomIndex(), 1);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n.item &#123;  \ndisplay: inline-block;  \nmargin-right: 10px;  \n&#125;  \n  \n.list-enter-active,  \n.list-leave-active &#123;  \ntransition: all 1s ease;  \n&#125;  \n  \n.list-enter-from,  \n.list-leave-to &#123;  \nopacity: 0;  \ntransform: translateY(30px)  \n&#125;  \n&lt;/style&gt;3.2. 列表过渡的移动动画在上面的案例中虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：\n\n我们可以通过使用一个新增的 v-move 的class来完成动画；\n\n它会在元素改变位置的过程中应用；\n\n像之前的名字一样，我们可以通过name来自定义前缀；\n\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;addNum&quot;&gt;添加数字&lt;/button&gt;  \n        &lt;button @click=&quot;removeNum&quot;&gt;删除数字&lt;/button&gt;  \n        &lt;button @click=&quot;shuffleNum&quot;&gt;打乱数字&lt;/button&gt;  \n          \n        &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;  \n            &lt;span v-for=&quot;item in numbers&quot; :key=&quot;item&quot; class=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;  \n        &lt;/transition-group&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport _ from &#39;lodash&#39;;  \n  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            numbers: [1, 2, 3, 4, 5, 6, 7, 8],  \n            nextNum: 10  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        randomIndex() &#123;  \n            return Math.floor(Math.random() * this.numbers.length)  \n        &#125;,  \n          \n        addNum() &#123;  \n            this.numbers.splice(this.randomIndex(), 0, this.nextNum++)  \n        &#125;,  \n        removeNum() &#123;  \n            this.numbers.splice(this.randomIndex(), 1);  \n        &#125;,  \n        shuffleNum() &#123;  \n            this.numbers = _.shuffle(this.numbers)  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n.item &#123;  \ndisplay: inline-block;  \nmargin-right: 10px;  \n&#125;  \n  \n.list-enter-active,  \n.list-leave-active &#123;  \ntransition: all 1s ease;  \n&#125;  \n  \n.list-leave-active &#123;  \nposition: absolute;  \n&#125;  \n  \n.list-enter-from,  \n.list-leave-to &#123;  \nopacity: 0;  \ntransform: translateY(30px)  \n&#125;  \n  \n.list-move &#123;  \ntransition: transform 1s ease;  \n&#125;  \n&lt;/style&gt;3.3. 列表的交错过渡案例我们来通过gsap的延迟delay属性，做一个交替消失的动画：\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;input v-model=&quot;query&quot;&gt;  \n        &lt;transition-group name=&quot;list&quot;  \n        tag=&quot;ul&quot;  \n        @beforeEnter=&quot;beforeEnter&quot;  \n        @enter=&quot;enter&quot;  \n        @leave=&quot;leave&quot;&gt;  \n            &lt;li v-for=&quot;(item, index) in showNames&quot; :key=&quot;item&quot; :data-index=&quot;index&quot;&gt;  \n            &#123;&#123;item&#125;&#125;  \n            &lt;/li&gt;  \n        &lt;/transition-group&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport gsap from &#39;gsap&#39;;  \n  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            query: &quot;&quot;,  \n            names: [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;, &quot;dna&quot;, &quot;why&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;curry&quot;]  \n        &#125;  \n    &#125;,  \n    computed: &#123;  \n            showNames() &#123;  \n                return this.names.filter(item =&gt; &#123;  \n                return item.toLowerCase().indexOf(this.query.toLowerCase()) !== -1  \n            &#125;)  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        beforeEnter(el) &#123;  \n            el.style.opacity = 0;  \n            el.style.height = 0;  \n        &#125;,  \n        enter(el, done) &#123;  \n            gsap.to(el, &#123;  \n            opacity: 1,  \n            height: &quot;1.6em&quot;,  \n            delay: el.dataset.index * 0.5,  \n            onComplete: done  \n            &#125;)  \n        &#125;,  \n        leave(el, done) &#123;  \n            gsap.to(el, &#123;  \n            opacity: 0,  \n            height: 0,  \n            delay: el.dataset.index * 0.5,  \n            onComplete: done  \n            &#125;)  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;\n结语学如逆水行舟，不进则退\n2023 9 20&#96;\n","slug":"前端框架开发【九】实现过渡动画","date":"2023-09-20T02:57:36.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"75ececb7f3bd832b01ecf732c87bbc8a","title":"前端框架开发【八】组件化知识补充","content":"1. 动态组件比如我们现在想要实现了一个功能：\n点击一个tab-bar，切换不同的组件显示\n\n这个案例我们可以通过两种不同的实现思路来实现：\n\n方式一：通过v-if来判断，显示不同的组件\n\n方式二：动态组件的方式\n\n\n1.1. v-if 显示不同组件我们可以先通过v-if来判断显示不同的组件，这个可以使用我们之前讲过的知识来实现：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button v-for=&quot;tab in tabs&quot;  \n            :key=&quot;tab&quot;  \n            :class=&quot;&#123;active: currentTab === tab&#125;&quot;  \n            @click=&quot;tabClick(tab)&quot;&gt;  \n        &#123;&#123;tab&#125;&#125;  \n        &lt;/button&gt;  \n          \n        &lt;template v-if=&quot;currentTab === &#39;home&#39;&quot;&gt;  \n            &lt;home&gt;&lt;/home&gt;  \n        &lt;/template&gt;  \n        &lt;template v-else-if=&quot;currentTab === &#39;about&#39;&quot;&gt;  \n            &lt;about&gt;&lt;/about&gt;  \n        &lt;/template&gt;  \n        &lt;template v-else&gt;  \n            &lt;category&gt;&lt;/category&gt;  \n        &lt;/template&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport Home from &quot;./pages/Home.vue&quot;;  \nimport About from &quot;./pages/About.vue&quot;;  \nimport Category from &quot;./pages/Category.vue&quot;;  \n  \nexport default &#123;  \n    components: &#123;  \n        Home, About, Category  \n    &#125;,  \n    data() &#123;  \n        return &#123;  \n            tabs: [&quot;home&quot;, &quot;about&quot;, &quot;category&quot;],  \n            currentTab: &quot;home&quot;  \n        &#125;  \n        &#125;,  \n        methods: &#123;  \n            tabClick(tab) &#123;  \n                this.currentTab = tab;  \n            &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n.active &#123;  \ncolor: red;  \n&#125;  \n&lt;/style&gt;1.2. 动态组件的实现动态组件是使用 component 组件，通过一个特殊的attribute is  来实现：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button v-for=&quot;tab in tabs&quot;  \n        :key=&quot;tab&quot;  \n        :class=&quot;&#123;active: currentTab === tab&#125;&quot;  \n        @click=&quot;tabClick(tab)&quot;&gt;  \n        &#123;&#123;tab&#125;&#125;  \n        &lt;/button&gt;  \n        &lt;component :is=&quot;currentTab&quot;&gt;&lt;/component&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;这个currentTab的值需要是什么内容呢？\n\n可以是通过component函数注册的组件\n\n在一个组件对象的components对象中注册的组件\n\n\n1.3. 动态组件的传值如果是动态组件我们可以给它们传值和监听事件吗？\n\n也是一样的；\n\n只是我们需要将属性和监听事件放到component上来使用；\n\n\nApp.vue的代码如下：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button v-for=&quot;tab in tabs&quot;  \n        :key=&quot;tab&quot;  \n        :class=&quot;&#123;active: currentTab === tab&#125;&quot;  \n        @click=&quot;tabClick(tab)&quot;&gt;  \n        &#123;&#123;tab&#125;&#125;  \n        &lt;/button&gt;  \n          \n        &lt;component \n        name=&quot;why&quot;  \n        :age=&quot;18&quot;  \n        @pageClick=&quot;pageClick&quot;  \n        :is=&quot;currentTab&quot;/&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport Home from &quot;./pages/Home.vue&quot;;  \nimport About from &quot;./pages/About.vue&quot;;  \nimport Category from &quot;./pages/Category.vue&quot;;  \n  \nexport default &#123;  \n    components: &#123;  \n        Home, About, Category  \n    &#125;,  \n    data() &#123;  \n        return &#123;  \n        tabs: [&quot;home&quot;, &quot;about&quot;, &quot;category&quot;],  \n        currentTab: &quot;home&quot;  \n    &#125;  \n    &#125;,  \n    methods: &#123;  \n        tabClick(tab) &#123;  \n        this.currentTab = tab;  \n        &#125;,  \n        pageClick(payload) &#123;  \n            console.log(&quot;pageClick&quot;, payload);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n.active &#123;  \ncolor: red;  \n&#125;  \n&lt;/style&gt;Home.vue 组件代码如下：\nhtml&lt;template&gt;  \n    &lt;div @click=&quot;pageClick&quot;&gt;  \n    Home组件: &#123;&#123;name&#125;&#125;-&#123;&#123;age&#125;&#125;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    props: &#123;  \n        name: String,  \n        age: Number  \n    &#125;,  \n    emits: [&quot;pageClick&quot;],  \n    methods: &#123;  \n        pageClick() &#123;  \n            this.$emit(&quot;pageClick&quot;, &quot;Home组件&quot;);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;1.4. keep-alive 使用1.4.1. 认识keep-alive我们先对之前的案例中About组件进行改造：\n在其中增加了一个按钮，点击可以递增的功能\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        About组件  \n        &lt;button @click=&quot;counter++&quot;&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            counter: 0  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;比如我们将counter点到10，那么在切换到home再切换回来about时，状态是否可以保持呢？\n\n答案是否定的；\n\n这是因为默认情况下，我们在切换组件后，about组件会被销毁掉，再次回来时会重新创建组件；\n\n\n但是，在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个内置组件：keep-alive。\nhtml&lt;keep-alive&gt;  \n    &lt;component name=&quot;why&quot;  \n    :age=&quot;18&quot;  \n    @pageClick=&quot;pageClick&quot;  \n    :is=&quot;currentTab&quot;/&gt;  \n&lt;/keep-alive&gt;1.4.2. keep-alive属性keep-alive有一些属性\n\ninclude - string | RegExp | Array。只有名称匹配的组件会被缓存\n\nexclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存\n\nmax - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁\n\n\ninclude 和 exclude prop 允许组件有条件地缓存：\n\n二者都可以用逗号分隔字符串、正则表达式或一个数组来表示\n\n匹配首先检查组件自身的 name 选项\n\n如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)\n\n\n\nhtml&lt;!-- 逗号分隔字符串 --&gt;  \n&lt;keep-alive include=&quot;a,b&quot;&gt;  \n    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;  \n&lt;/keep-alive&gt;  \n  \n&lt;!-- regex (使用 `v-bind`) --&gt;  \n&lt;keep-alive :include=&quot;/a|b/&quot;&gt;  \n    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;  \n&lt;/keep-alive&gt;  \n  \n&lt;!-- Array (使用 `v-bind`) --&gt;  \n&lt;keep-alive :include=&quot;[&#39;a&#39;, &#39;b&#39;]&quot;&gt;  \n    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;  \n&lt;/keep-alive&gt;1.4.3. 缓存的生命周期对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的：\n\n但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件\n\n这个时候我们可以使用activated 和 deactivated 这两个生命周期钩子函数来监听\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        About组件  \n        &lt;button @click=&quot;counter++&quot;&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    name: &quot;about&quot;,  \n    data() &#123;  \n        return &#123;  \n            counter: 0  \n        &#125;  \n    &#125;,  \n    // 当重新进入活跃状态时会回调  \n    activated() &#123;  \n        console.log(&quot;about activated&quot;)  \n    &#125;,  \n    // 当离开活跃状态时会回调  \n    deactivated() &#123;  \n        console.log(&quot;about deactivated&quot;)  \n    &#125;  \n&#125;  \n&lt;/script&gt;2. 异步组件2.1. webpack的代码分包默认的打包过程：\n\n默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组件模块打包到一起（比如一个app.js文件中）\n\n这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢\n\n\n打包时，代码的分包：\n\n所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js\n\n这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容\n\n\n那么webpack中如何可以对代码进行分包呢？\n默认情况下，我们直接使用import来依赖一个模块时，是不会进行分包的：\njavascriptimport &#123;sum&#125; from &#39;./utils/math&#39;;  \n  \nconsole.log(sum(20, 30));如果我们希望进行分包，那么可以使用import函数：\njavascriptimport(&quot;./utils/math&quot;).then((&#123; sum &#125;) =&gt; &#123;  \n  console.log(sum(20, 30));  \n&#125;);\n2.2. vue中实现异步组件如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数：defineAsyncComponent。\ndefineAsyncComponent接受两种类型的参数：\n\n类型一：工厂函数，该工厂函数需要返回一个Promise对象\n\n类型二：接受一个对象类型，对异步函数进行配置\n\n\n工厂函数类型一的写法：\njavascriptimport &#123; defineAsyncComponent &#125; from &#39;vue&#39;;  \nconst AsyncHome = defineAsyncComponent(() =&gt; import(&quot;./AsyncHome.vue&quot;));  \n  \nexport default &#123;  \n    components: &#123;  \n        AsyncHome  \n    &#125;  \n&#125;对象类型类型二的写法：\njavascript&lt;script&gt;  \nimport &#123; defineAsyncComponent &#125; from &quot;vue&quot;;  \n// const AsyncHome = defineAsyncComponent(() =&gt; import(&quot;./AsyncHome.vue&quot;));  \n  \nimport Loading from &quot;./Loading.vue&quot;;  \nimport Error from &quot;./Error.vue&quot;;  \nconst AsyncHome = defineAsyncComponent(&#123;  \n    // 工厂函数  \n    loader: () =&gt; import(&quot;./AsyncHome.vue&quot;),  \n    // 加载过程中显示的组件  \n    loadingComponent: Loading,  \n    // 加载失败时显示的组件  \n    errorComponent: Error,  \n    // 在显示 loadingComponent 之前的延迟 | 默认值：200（单位 ms）  \n    delay: 200,  \n    // 如果提供了 timeout ，并且加载组件的时间超过了设定值，将显示错误组件  \n    // 默认值：Infinity（即永不超时，单位 ms）  \n    timeout: 3000,  \n    // 定义组件是否可挂起 | 默认值：true  \n    suspensible: false,  \n/**  \n*  \n* @param &#123;*&#125; error 错误信息对象  \n* @param &#123;*&#125; retry 一个函数，用于指示当 promise 加载器 reject 时，加载器是否应该重试  \n* @param &#123;*&#125; fail 一个函数，指示加载程序结束退出  \n* @param &#123;*&#125; attempts 允许的最大重试次数  \n*/  \nonError(error, retry, fail, attempts) &#123;  \n    if (error.message.match(/fetch/) &amp;&amp; attempts &lt;= 3) &#123;  \n            // 请求发生错误时重试，最多可尝试 3 次  \n            retry();  \n        &#125; else &#123;  \n            // 注意，retry/fail 就像 promise 的 resolve/reject 一样：  \n            // 必须调用其中一个才能继续错误处理。  \n            fail();  \n        &#125;  \n    &#125;,  \n&#125;);  \n  \nexport default &#123;  \n    components: &#123;  \n        AsyncHome,  \n    &#125;,  \n&#125;;  \n&lt;/script&gt;2.3. 异步组件和Suspense\n\n\n\n\n\n\n\n\n注意，目前（2021-06-08）Suspense显示的是一个实验性的特性，API随时可能会修改。\nSuspense是一个内置的全局组件，该组件有两个插槽：\n\ndefault：如果default可以显示，那么显示default的内容\n\nfallback：如果default无法显示，那么会显示fallback插槽的内容\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;suspense&gt;  \n            &lt;template #default&gt;  \n                &lt;async-home&gt;&lt;/async-home&gt;  \n            &lt;/template&gt;  \n            &lt;template #fallback&gt;  \n                &lt;loading/&gt;  \n            &lt;/template&gt;  \n        &lt;/suspense&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;3. 模板引用3.1. $refs某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例：\n\n在Vue开发中我们是不推荐进行DOM操作的\n\n这个时候，我们可以给元素或者组件绑定一个ref的attribute属性\n\n\n组件实例有一个$refs属性：\n\n它一个对象Object，持有注册过 ref attribute 的所有 DOM 元素和组件实例。\n\nApp.vue的实现：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h2 ref=&quot;title&quot;&gt;哈哈哈&lt;/h2&gt;  \n        &lt;hello-world ref=&quot;helloCpn&quot;&gt;&lt;/hello-world&gt;  \n          \n        &lt;button @click=&quot;visitElement&quot;&gt;访问元素或者组件&lt;/button&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport HelloWorld from &#39;./HelloWorld.vue&#39;;  \n  \nexport default &#123;  \n    components: &#123;  \n        HelloWorld  \n    &#125;,  \n    methods: &#123;  \n        visitElement() &#123;  \n            // 访问元素  \n            console.log(this.$refs.title);  \n            // 访问组件实例  \n            this.$refs.helloCpn.showMessage();  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;HelloWorld.vue实现：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n      \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    methods: &#123;  \n        showMessage() &#123;  \n            console.log(&quot;我是HelloWorld组件的showMessage方法&quot;);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;3.2. $parent我们可以通过$parent来访问父元素。\nHelloWorld.vue的实现：\n\n这里我们也可以通过$root来实现，因为App是我们的根组件；\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;visitParent&quot;&gt;访问父组件&lt;/button&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    methods: &#123;  \n        showMessage() &#123;  \n            console.log(&quot;我是HelloWorld组件的showMessage方法&quot;);  \n        &#125;,  \n        visitParent() &#123;  \n            console.log(this.$parent.message);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;注意：在Vue3中已经移除了$children的属性，所以不可以使用了。\n4. 生命周期4.1. 生命周期图片什么是生命周期呢？\n\n每个组件都会经历从创建、挂载、更新、卸载等一系列的过程\n\n在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服务器数据）\n\n但是我们如何可以知道目前组件正在哪一个过程呢？Vue给我们提供了组件的生命周期函数\n\n\n生命周期函数：\n\n生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调\n\n通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段\n\n那么我们就可以在该生命周期中编写属于自己的逻辑代码了\n\n\n\n4.2. 生命周期演练我们通过一个App和Home来演练所有的生命周期函数。\nApp.vue组件对象：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;toggle&quot;&gt;切换&lt;/button&gt;  \n        &lt;div v-if=&quot;isShow&quot;&gt;  \n            &lt;home&gt;&lt;/home&gt;  \n        &lt;/div&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport Home from &#39;./Home.vue&#39;;  \n  \nexport default &#123;  \n    components: &#123;  \n        Home  \n    &#125;,  \n    data() &#123;  \n        return &#123;  \n            isShow: true  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        toggle() &#123;  \n            this.isShow = !this.isShow;  \n            console.log(this.isShow);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;Home.vue组件对象：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;button @click=&quot;changeMessage&quot;&gt;修改message&lt;/button&gt;  \n        &lt;h2 ref=&quot;titleRef&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            message: &quot;Hello World&quot;  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        changeMessage() &#123;  \n            this.message = &quot;你好啊,李银河&quot;;  \n        &#125;  \n    &#125;,  \n    beforeUpdate() &#123;  \n        console.log(&quot;beforeUpdate&quot;);  \n        console.log(this.$refs.titleRef.innerHTML);  \n    &#125;,  \n    updated() &#123;  \n        console.log(&quot;updated&quot;);  \n        console.log(this.$refs.titleRef.innerHTML);  \n    &#125;,  \n    beforeCreate() &#123;  \n        console.log(&quot;beforeCreate&quot;);  \n    &#125;,  \n    created() &#123;  \n        console.log(&quot;created&quot;);  \n    &#125;,  \n    beforeMount() &#123;  \n        console.log(&quot;beforeMount&quot;);  \n    &#125;,  \n    mounted() &#123;  \n        console.log(&quot;mounted&quot;);  \n    &#125;,  \n    beforeUnmount() &#123;  \n        console.log(&quot;beforeUnmount&quot;);  \n    &#125;,  \n    unmounted() &#123;  \n        console.log(&quot;unmounted&quot;);  \n    &#125;  \n&#125;  \n&lt;/script&gt;5. 组件的 v-model5.1. 组件的v-model前面我们在input中可以使用v-model来完成双向绑定：\n\n这个时候往往会非常方便，因为v-model默认帮助我们完成了两件事\n\nv-bind:value的数据绑定和@input的事件监听\n\n\n如果我们现在封装了一个组件，其他地方在使用这个组件时，是否也可以使用v-model来同时完成这两个功能呢？\n\n也是可以的，vue也支持在组件上使用v-model\n\n当我们在组件上使用的时候，等价于如下的操作：\n\n我们会发现和input元素不同的只是属性的名称和事件触发的名称而已\n\n\n那么，为了我们的MyInput组件可以正常的工作，这个组件内的 &lt;input&gt; 必须：\n\n将其 value attribute 绑定到一个名叫 modelValue 的 prop 上\n\n在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出\n\n\nMyInput.vue的组件代码如下：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;input :value=&quot;modelValue&quot; @input=&quot;inputChange&quot;&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    props: [&quot;modelValue&quot;],  \n    emits: [&quot;update:modelValue&quot;],  \n    methods: &#123;  \n        inputChange(event) &#123;  \n            this.$emit(&quot;update:modelValue&quot;, event.target.value);  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;在App.vue中，我们在使用MyInput可以直接使用v-model：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;my-input v-model=&quot;message&quot;/&gt;  \n        &lt;button @click=&quot;changeMessage&quot;&gt;修改message&lt;/button&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport MyInput from &#39;./MyInput.vue&#39;;  \n  \nexport default &#123;  \n    components: &#123;  \n        MyInput  \n    &#125;,  \n    data() &#123;  \n        return &#123;  \n            message: &quot;&quot;  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        changeMessage() &#123;  \n            this.message = &quot;Hello World&quot;  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;5.2. computed实现在上面的案例中，我们可能会想到一种实现方法：直接将Props中的属性双向绑定到input上\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;input v-model=&quot;modelValue&quot;&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    props: [&quot;modelValue&quot;]  \n&#125;  \n&lt;/script&gt;上面这种方式可以实现组件的双向绑定吗？答案是不可以\n\n因为我们在内部修改了props之后，外界并不知道我们对props的修改，所以并不会将事件传递出去；\n\n另外，在开发中直接修改props中的属性不是一个好的习惯，不要这样去做；\n\n\n那么，我们依然希望在组件内部按照双向绑定的做法去完成，应该如何操作呢？我们可以使用计算属性的setter和getter来完成。\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;input v-model=&quot;value&quot;&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    props: [&quot;modelValue&quot;],  \n    emits: [&quot;update:modelValue&quot;],  \n    computed: &#123;  \n        value: &#123;  \n            get() &#123;  \n                return this.modelValue;  \n            &#125;,  \n            set(value) &#123;  \n                this.$emit(&quot;update:modelValue&quot;, value)  \n            &#125;  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;5.3. 绑定多个属性我们现在通过v-model是直接绑定了一个属性，如果我们希望绑定多个属性呢？也就是我们希望在一个组件上使用多个v-model是否可以实现呢？\n\n我们知道，默认情况下的v-model其实是绑定了 modelValue 属性和 @update:modelValue的事件；\n\n如果我们希望绑定更多，可以给v-model传入一个参数，那么这个参数的名称就是我们绑定属性的名称；\n\n\n我们先看一下在App.vue中我是如何使用的：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;my-input v-model=&quot;message&quot; v-model:title=&quot;title&quot;/&gt;  \n        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;  \n        &lt;button @click=&quot;changeMessage&quot;&gt;修改message&lt;/button&gt;  \n        &lt;hr&gt;  \n        &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;  \n        &lt;button @click=&quot;changeTitle&quot;&gt;修改title&lt;/button&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport MyInput from &#39;./MyInput.vue&#39;;  \n  \nexport default &#123;  \n    components: &#123;  \n        MyInput  \n    &#125;,  \n    data() &#123;  \n        return &#123;  \n            message: &quot;&quot;,  \n            title: &quot;&quot;  \n        &#125;  \n    &#125;,  \n    methods: &#123;  \n        changeMessage() &#123;  \n            this.message = &quot;Hello World&quot;  \n        &#125;,  \n        changeTitle() &#123;  \n            this.title = &quot;Hello Title&quot;  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;注意：这里我是绑定了两个属性的\nhtml&lt;my-input v-model=&quot;message&quot; v-model:title=&quot;title&quot;/&gt;v-model:title相当于做了两件事：\n\n绑定了title属性；\n\n监听了 @update:title的事件；\n\n\n所以，我们MyInput中的实现如下：\nhtml&lt;template&gt;  \n    &lt;div&gt;    \n        &lt;input :value=&quot;modelValue&quot; @input=&quot;input1Change&quot;&gt;    \n        &lt;input :value=&quot;title&quot; @input=&quot;input2Change&quot;&gt;  \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;  \nexport default &#123;   \n    props: [&quot;modelValue&quot;, &quot;title&quot;],    \n    emits: [&quot;update:modelValue&quot;, &quot;update:title&quot;],    \n    methods: &#123;      \n        input1Change(event) &#123;        \n            this.$emit(&quot;update:modelValue&quot;, event.target.value);      \n        &#125;,      \n        input2Change(event) &#123;        \n            this.$emit(&quot;update:title&quot;, event.target.value);      \n        &#125;    \n    &#125;  \n&#125;\n&lt;/script&gt;6. Options API代码复用其实在Vue2当中的Options API中已经有了一些代码复用的方式，当然这些API在Vue3中依然是保留的。\n1.1. Mixin混入1.1.1. 认识Mixin目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。\n在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成。\n\nMixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能\n\n一个Mixin对象可以包含任何组件选项\n\n当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中\n\n\n比如我们封装一个mixin的对象在sayHelloMixin.js文件中：\njavascriptconst sayHelloMixin = &#123;  \n  created() &#123;  \n    this.sayHello();  \n  &#125;,  \n  methods: &#123;  \n    sayHello() &#123;  \n      console.log(&quot;Hello Page Component&quot;);  \n    &#125;  \n  &#125;  \n&#125;  \n  \nexport default sayHelloMixin;之后，在Home.vue中通过mixins的选项进行混入：\nhtml&lt;template&gt;  \n    &lt;div&gt;&lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport sayHelloMixin from &#39;../mixins/sayHello&#39;;  \n  \nexport default &#123;  \n    mixins: [sayHelloMixin]\n&#125;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;  \n  \n&lt;/style&gt;1.1.2. Mixin合并如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？\n\n这里分成不同的情况来进行处理；\n\n情况一：如果是data函数的返回值对象\n\n返回值对象默认情况下会进行合并；\n\n如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据；\n\n\nmixin中的代码：\njavascriptconst sayHelloMixin = &#123;  \n  data() &#123;  \n    return &#123;  \n      name: &quot;mixin&quot;,  \n      age: 18  \n    &#125;  \n  &#125;  \n&#125;  \n  \nexport default sayHelloMixin;Home.vue中的代码：\njavascriptimport sayHelloMixin from &#39;../mixins/sayHello&#39;;  \n  \nexport default &#123;  \n    mixins: [sayHelloMixin],  \n    data() &#123;  \n        return &#123;  \n            message: &quot;Hello World&quot;,  \n            // 冲突时会保留组件中的name  \n            name: &quot;home&quot;  \n        &#125;  \n    &#125;  \n&#125; 情况二：如果是生命周期钩子函数\n\n生命周期的钩子函数会被合并到数组中，都会被调用；\n\nmixin中的代码：\njavascriptconst sayHelloMixin = &#123;  \n  created() &#123;  \n    console.log(&quot;mixin created&quot;)  \n  &#125;  \n&#125;  \n  \nexport default sayHelloMixin;Home.vue中的代码：\njavascriptimport sayHelloMixin from &#39;../mixins/sayHello&#39;;  \n  \nexport default &#123;  \n    mixins: [sayHelloMixin],  \n    created() &#123;  \n        console.log(&quot;home created&quot;);  \n    &#125;  \n&#125;  情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。\n\n比如都有methods选项，并且都定义了方法，那么它们都会生效\n\n但是如果对象的key相同，那么会取组件对象的键值对\n\n比如下面的代码中，最终methods对象会被合并成一个对象\n\n\nmixin中的代码：\njavascriptconst sayHelloMixin = &#123;  \n  methods: &#123;  \n    sayHello() &#123;  \n      console.log(&quot;Hello Page Component&quot;);  \n    &#125;,  \n    foo() &#123;  \n      console.log(&quot;mixin foo function&quot;);  \n    &#125;  \n  &#125;  \n&#125;  \n  \nexport default sayHelloMixin;Home.vue中的代码：\njavascriptimport sayHelloMixin from &#39;../mixins/sayHello&#39;;  \n  \nexport default &#123;  \n    mixins: [sayHelloMixin],  \n    methods: &#123;  \n        foo() &#123;  \n            console.log(&quot;mixin foo function&quot;);  \n        &#125;,  \n        bar() &#123;  \n            console.log(&quot;bar function&quot;);  \n        &#125;  \n    &#125;  \n&#125;1.1.3. 全局Mixin如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin：\n\n全局的Mixin可以使用 应用app的方法 mixin 来完成注册\n\n一旦注册，那么全局混入的选项将会影响每一个组件\n\n\njavascriptimport &#123; createApp &#125; from &quot;vue&quot;;  \nimport App from &quot;./14_Mixin混入/App.vue&quot;;  \n  \nconst app = createApp(App);  \napp.mixin(&#123;  \n  created() &#123;  \n    console.log(&quot;global mixin created&quot;);  \n  &#125;  \n&#125;)  \napp.mount(&quot;#app&quot;);1.2. extends另外一个类似于Mixin的方式是通过extends属性：\n\n允许声明扩展另外一个组件，类似于Mixins\n\n我们开发一个HomePage.vue的组件对象：\njavascriptexport default &#123;  \n    data() &#123;  \n        return &#123;  \n            message: &quot;Hello Page&quot;  \n        &#125;  \n    &#125;  \n&#125;  在Home.vue中我们可以继承自HomePage.vue：\n\n注意：只可以继承自对象中的属性，不可以继承模板和样式等\n\njavascriptimport BasePage from &#39;./BasePage.vue&#39;;  \n  \nexport default &#123;  \n    extends: BasePage  \n&#125;  在开发中extends用的非常少，在Vue2中比较推荐使用Mixin，而在Vue3中推荐使用Composition API。\n\n结语学如逆水行舟，不进则退\n2023 9 17&#96;\n","slug":"前端框架开发【八】组件化知识补充","date":"2023-09-17T02:57:25.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"0701903dd32364615550461e63b1accc","title":"前端框架开发【七】组件的插槽使用","content":"1. 插槽的使用1.1. 认识插槽slot在开发中，我们会经常封装一个个可复用的组件：\n\n前面我们会通过props传递给组件一些数据，让组件来进行展示\n\n但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素\n\n比如某种情况下我们使用组件希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片\n\n我们应该让使用者可以决定某一块区域到底存放什么内容\n\n\n举个栗子：假如我们定制一个通用的导航组件 - NavBar\n\n这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定\n\n左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示\n\n中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等\n\n右边可能是一个文字，也可能是一个图标，也可能什么都不显示\n\n\n\n这个时候我们就可以来定义插槽slot：\n\n插槽的使用过程其实是抽取共性、保留不同。\n\n我们会将共同的元素、内容依然在组件内进行封装。\n\n同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素。\n\n\n如何使用slot呢 ？\n\nVue中将 &lt;slot&gt; 元素作为承载分发内容的出口\n\n在封装组件中，使用特殊的元素&lt;slot&gt;就可以为封装组件开启一个插槽\n\n该插槽插入什么内容取决于父组件如何使用\n\n\n1.2. 插槽的使用1.2.1. 插槽的基本使用我们一个组件MySlotCpn.vue：\n该组件中有一个插槽，我们可以在插槽中放入需要显示的内容\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h2&gt;MySlotCpn开始&lt;/h2&gt;  \n        &lt;slot&gt;&lt;/slot&gt;  \n        &lt;h2&gt;MySlotCpn结尾&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;我们在App.vue中使用它们：\n我们可以插入普通的内容、html元素、组件元素，都可以是可以的\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;my-slot-cpn&gt;  \n        &lt;!-- 1.普通的内容 --&gt;  \n        Hello World  \n        &lt;!-- 2.html元素 --&gt;  \n        &lt;button&gt;我是按钮&lt;/button&gt;  \n        &lt;!-- 3.组件元素 --&gt;  \n        &lt;my-button&gt;&lt;/my-button&gt;  \n        &lt;/my-slot-cpn&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;1.2.2. 插槽的默认内容有时候我们希望在使用插槽时，如果没有插入对应的内容，那么我们需要显示一个默认的内容：\n当然这个默认的内容只会在没有提供插入的内容时，才会显示\n\n1.2.3. 具名插槽的使用如果一个组件中含有多个插槽，我们插入多个内容时是什么效果？\n我们会发现默认情况下每个插槽都会获取到我们插入的内容来显示\n\n事实上，我们希望达到的效果是插槽对应的显示，这个时候我们就可以使用 具名插槽：\n\n具名插槽顾名思义就是给插槽起一个名字，&lt;slot&gt; 元素有一个特殊的 attribute：name\n\n一个不带 name 的slot，也会带有隐含的名字 default\n\n\nhtml&lt;template&gt;  \n    &lt;div class=&quot;nav-bar&quot;&gt;  \n        &lt;div class=&quot;left&quot;&gt;  \n        &lt;slot&gt;&lt;/slot&gt;  \n    &lt;/div&gt;  \n    &lt;div class=&quot;center&quot;&gt;  \n        &lt;slot&gt;&lt;/slot&gt;  \n        &lt;/div&gt;  \n    &lt;div class=&quot;right&quot;&gt;  \n        &lt;slot&gt;&lt;/slot&gt;  \n        &lt;/div&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;nav-bar&gt;  \n            &lt;template v-slot:left&gt;  \n                &lt;button&gt;左边按钮&lt;/button&gt;  \n            &lt;/template&gt;  \n            &lt;template v-slot:center&gt;  \n                &lt;h2&gt;中间标题&lt;/h2&gt;  \n            &lt;/template&gt;  \n            &lt;template v-slot:right&gt;  \n                &lt;i&gt;右边i元素&lt;/i&gt;  \n            &lt;/template&gt;  \n        &lt;/nav-bar&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;插槽的使用过程如下：\nNavBar.vue\nhtml&lt;template&gt;\n    &lt;div class=&quot;nav-bar&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;\n            &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;slot name=&quot;center&quot;&gt;&lt;/slot&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;\n            &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;App.vue\nhtml&lt;template&gt;\n    &lt;div&gt;\n        &lt;nav-bar&gt;\n            &lt;template v-slot:left&gt;\n                &lt;button&gt;左边按钮&lt;/button&gt;\n            &lt;/template&gt;\n            &lt;template v-slot:center&gt;\n                &lt;h2&gt;中间标题&lt;/h2&gt;\n            &lt;/template&gt;\n            &lt;template&gt;\n                &lt;i&gt;右边i元素&lt;/i&gt;\n            &lt;/template&gt;\n        &lt;/nav-bar&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n动态插槽名：\n\n目前我们使用的插槽名称都是固定的\n\n比如 v-slot:left、v-slot:center等等\n\n我们可以通过 v-slot:[dynamicSlotName]方式动态绑定一个名称\n\n\n\n具名插槽使用的时候缩写：\n\n跟 v-on 和 v-bind 一样，v-slot 也有缩写\n\n即把参数之前的所有内容 (v-slot:) 替换为字符 #\n\n\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n    &lt;nav-bar&gt;  \n    &lt;template #left&gt;  \n        &lt;button&gt;左边按钮&lt;/button&gt;  \n    &lt;/template&gt;  \n    &lt;template #center&gt;  \n        &lt;h2&gt;中间标题&lt;/h2&gt;  \n    &lt;/template&gt;  \n    &lt;template #right&gt;  \n        &lt;i&gt;右边i元素&lt;/i&gt;  \n    &lt;/template&gt;  \n    &lt;/nav-bar&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;2. 作用域插槽2.1. 渲染作用域在Vue中有渲染作用域的概念：\n\n父级模板里的所有内容都是在父级作用域中编译的\n\n子模板里的所有内容都是在子作用域中编译的\n\n\n如何理解呢？我们来看一个案例：\n\n在我们的案例中ChildCpn自然是可以让问自己作用域中的title内容的\n\n但是在App中，是访问不了ChildCpn中的内容的，因为它们是跨作用域的访问\n\n\n\n2.2. 作用域插槽但是有时候我们希望插槽可以访问到子组件中的内容是非常重要的：\n\n当一个组件被用来渲染一个数组元素时，我们使用插槽，并且希望插槽来显示每项的内容\n\n这个Vue给我们提供了作用域插槽\n\n\n我们来看下面的一个案例：\n\n1.在App.vue中定义好数据\n\n2.传递给ShowNames组件中\n\n3.ShowNames组件中遍历names数据\n\n4.定义插槽的prop\n\n5.通过v-slot:default的方式获取到slot的props\n\n6.使用slotProps中的item和index\n\n\n\n具体的代码如下：\nApp.vue代码：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;show-names :names=&quot;names&quot;&gt;  \n            &lt;template v-slot:default=&quot;slotProps&quot;&gt;  \n            &lt;span&gt;&#123;&#123;slotProps.item&#125;&#125;-&#123;&#123;slotProps.index&#125;&#125;&lt;/span&gt;  \n            &lt;/template&gt;  \n        &lt;/show-names&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport ShowNames from &#39;./ShowNames.vue&#39;;  \n  \nexport default &#123;  \n    components: &#123;  \n        ShowNames,  \n    &#125;,  \n    data() &#123;  \n        return &#123;  \n            names: [&quot;why&quot;, &quot;kobe&quot;, &quot;james&quot;, &quot;curry&quot;]  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;ShowNames.vue代码：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;template v-for=&quot;(item, index) in names&quot; :key=&quot;item&quot;&gt;  \n        &lt;!-- 插槽prop --&gt;  \n        &lt;slot :item=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt;  \n        &lt;/template&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n    props: &#123;  \n        names: &#123;  \n        type: Array,  \n            default: () =&gt; []  \n        &#125;  \n    &#125;  \n&#125;  \n&lt;/script&gt;2.3. 独占默认插槽如果我们的插槽是默认插槽default，那么在使用的时候 v-slot:default=&quot;slotProps&quot;可以简写为v-slot=&quot;slotProps&quot;：\nhtml&lt;show-names :names=&quot;names&quot;&gt;  \n    &lt;template v-slot=&quot;slotProps&quot;&gt;  \n        &lt;span&gt;&#123;&#123;slotProps.item&#125;&#125;-&#123;&#123;slotProps.index&#125;&#125;&lt;/span&gt;  \n    &lt;/template&gt;  \n&lt;/show-names&gt;并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 v-slot 直接用在组件上：\nhtml&lt;show-names :names=&quot;names&quot; v-slot=&quot;slotProps&quot;&gt;  \n    &lt;span&gt;&#123;&#123;slotProps.item&#125;&#125;-&#123;&#123;slotProps.index&#125;&#125;&lt;/span&gt;  \n&lt;/show-names&gt;但是，如果我们有默认插槽和具名插槽，那么按照完整的template来编写：\n\n只要出现多个插槽，请始终为所有的插槽使用完整的基于 &lt;template&gt; 的语法：\n\n\n结语学如逆水行舟，不进则退\n2023 9 16&#96;\n","slug":"前端框架开发【七】组件的插槽使用","date":"2023-09-16T02:57:09.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"6b9ec4178ad2a1311eb0bf0f5277e1b3","title":"前端框架开发【六】组件之间通信","content":"1. 认识组件嵌套1.1. App单独开发前面我们是将所有的逻辑放到一个App.vue中：\n\n在之前的案例中，我们只是创建了一个组件App；\n\n如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；\n\n所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；\n\n再将这些组件组合嵌套在一起，最终形成我们的应用程序\n\n\n我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h2&gt;Header&lt;/h2&gt;  \n        &lt;h2&gt;NavBar&lt;/h2&gt;  \n    &lt;/div&gt;  \n    &lt;div&gt;  \n    &lt;h2&gt;Banner&lt;/h2&gt;  \n    &lt;ul&gt;  \n        &lt;li&gt;商品列表1&lt;/li&gt;  \n        &lt;li&gt;商品列表2&lt;/li&gt;  \n        &lt;li&gt;商品列表3&lt;/li&gt;  \n        &lt;li&gt;商品列表4&lt;/li&gt;  \n        &lt;li&gt;商品列表5&lt;/li&gt;  \n    &lt;/ul&gt;  \n    &lt;/div&gt;  \n    &lt;div&gt;  \n        &lt;h2&gt;Footer&lt;/h2&gt;  \n        &lt;h2&gt;免责声明&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nexport default &#123;  \n  \n&#125;;  \n&lt;/script&gt;  \n  \n&lt;style scoped&gt;&lt;/style&gt;我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。\n所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。\n1.2. 组件的拆分我们可以按照如下的方式进行拆分：\n\nHeader.vue组件\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h2&gt;Header&lt;/h2&gt;  \n        &lt;h2&gt;NavBar&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;Main.vue组件\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;banner&gt;&lt;/banner&gt;  \n        &lt;product-list&gt;&lt;/product-list&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;ProductList组件\nhtml&lt;template&gt;  \n    &lt;ul&gt;  \n        &lt;li&gt;商品列表1&lt;/li&gt;  \n        &lt;li&gt;商品列表2&lt;/li&gt;  \n        &lt;li&gt;商品列表3&lt;/li&gt;  \n        &lt;li&gt;商品列表4&lt;/li&gt;  \n        &lt;li&gt;商品列表5&lt;/li&gt;  \n    &lt;/ul&gt;  \n&lt;/template&gt;Footer.vue组件\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h2&gt;Footer&lt;/h2&gt;  \n        &lt;h2&gt;免责声明&lt;/h2&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。\n1.3. 组件的通信上面的嵌套逻辑如下，它们存在如下关系：\n\nApp组件是Header、Main、Footer组件的父组件\n\nMain组件是Banner、ProductList组件的父组件\n\n\n在开发过程中，我们会经常遇到需要组件之间相互进行通信：\n\n比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示\n\n又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示\n\n也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件\n\n\n总之，在一个Vue项目中，组件之间的通信是非常重要的环节，所以接下来我们就具体学习一下组件之间是如何相互之间传递数据的\n2. 父子组件的相互通信2.1. 父组件传递给子组件在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：\n\n这个时候我们可以通过props来完成组件之间的通信\n\n什么是Props呢？\n\nProps是你可以在组件上注册一些自定义的attribute\n\n父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值\n\n\nProps有两种常见的用法：\n\n方式一：字符串数组，数组中的字符串就是attribute的名称，可接收任意类型数据\n\n方式二：对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等\n\n\n2.1.1. props的数组用法封装ShowMessage.vue组件：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h2&gt;组件展示的title: &#123;&#123;title&#125;&#125;&lt;/h2&gt;  \n        &lt;p&gt;组件展示的content: &#123;&#123;content&#125;&#125;&lt;/p&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;\n  \n&lt;script&gt;  \nexport default &#123; \n    props: [&quot;title&quot;, &quot;content&quot;]  \n&#125;  \n&lt;/script&gt;通过App.vue传递给组件数据：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;show-message title=&quot;哈哈哈&quot; content=&quot;我是哈哈哈&quot;&gt;&lt;/show-message&gt;  \n        &lt;show-message title=&quot;呵呵呵&quot; content=&quot;我是呵呵呵&quot;&gt;&lt;/show-message&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport ShowMessage from &#39;./ShowMessage.vue&#39;;  \n  \nexport default &#123;  \n    components: &#123;  \n        ShowMessage  \n    &#125;  \n&#125;  \n&lt;/script&gt;当然，我们也可以将data中的数据传递给子组件：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;show-message :title=&quot;title1&quot; :content=&quot;content1&quot;&gt;&lt;/show-message&gt;  \n        &lt;show-message :title=&quot;title2&quot; :content=&quot;content2&quot;&gt;&lt;/show-message&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \n    import ShowMessage from &#39;./ShowMessage.vue&#39;;  \n      \n    export default &#123;  \n        components: &#123;  \n            ShowMessage  \n        &#125;,\n        data() &#123;\n            return &#123;\n                title1: &quot;哈哈哈&quot;,  \n                content1: &quot;我是哈哈哈&quot;,  \n                title2: &quot;呵呵呵&quot;,  \n                content2: &quot;我是呵呵呵&quot;  \n            &#125;  \n        &#125;  \n    &#125;  \n&lt;/script&gt;当然，我们也可以直接传递一个对象：\nhtml&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;show-message :title=&quot;message.title&quot; :content=&quot;message.content&quot;&gt;&lt;/show-message&gt;\n        &lt;show-message v-bind=&quot;message&quot;&gt;&lt;/show-message&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;  \n  \n&lt;script&gt;  \nimport ShowMessage from &#39;./ShowMessage.vue&#39;;  \nexport default &#123;  \n        components: &#123;  \n            ShowMessage  \n        &#125;,  \n        data() &#123;  \n            return &#123;  \n                message: &#123;  \n                title: &quot;嘿嘿嘿&quot;,  \n                content: &quot;我是嘿嘿嘿&quot;  \n            &#125;  \n        &#125;  \n    &#125;  z\n&#125;  \n&lt;/script&gt;2.1.2. props的对象用法数组用法中我们只能说明传入的attribute的名称，并不能对其进行任何形式的限制，接下来我们来看一下对象的写法是如何让我们的props变得更加完善的。\nShowMessage.vue的props对象写法：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;h2&gt;组件展示的title:&#123;&#123;title&#125;&#125;&lt;/h2&gt; \n        &lt;p&gt;组件展示的content: &#123;&#123;content&#125;&#125;&lt;/p&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nexport default &#123; \n        props: &#123; \n        // 指定类型 title: String, \n        // 指定类型，同时指定是否必选、默认值 \n        content: &#123; \n            type: String, \n            require: true, \n            default: &quot;哈哈哈&quot; \n        &#125; \n    &#125; \n&#125;\n&lt;/script&gt;细节一：那么type的类型都可以是哪些呢？\n\nString\n\nNumber\n\nBoolean\n\nArray\n\nObject\n\nDate\n\nFunction\n\nSymbol\n\n\n细节二：对象类型的其他写法\nhtml&lt;script&gt; \nexport default &#123; \n    props: &#123; \n        // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) \n        propA: Number, \n        // 多个可能的类型 \n        propB: [String, Number], \n        // 必填的字符串 \n        propC: &#123; \n            type: String, \n            required: true \n        &#125;, \n        // 带有默认值的数字 \n        propD: &#123; \n            type: Number, \n            default: 100 \n        &#125;, \n        // 带有默认值的对象 \n        propE: &#123;\n            type: Object,\n            // 对象或数组默认值必须从一个工厂函数获取 \n            default() &#123;\n                return &#123;\n                     message: &#39;hello&#39; \n                 &#125;\n             &#125; \n         &#125;, \n        // 自定义验证函数 \n        propF: &#123; \n            validator(value) &#123; \n                // 这个值必须匹配下列字符串中的一个 \n                return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].includes(value) \n            &#125; \n        &#125;, \n        // 具有默认值的函数 \n        propG: &#123; \n            type: Function, \n            // 与对象或数组默认值不同，这不是一个工厂函数 —— 这是一个用作默认值的函数 \n            default() &#123; \n                return &#39;Default function&#39; \n            &#125; \n        &#125; \n    &#125; \n&#125;\n&lt;/script&gt;细节三：Prop 的大小写命名(camelCase vs kebab-case)\n\nHTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符\n\n这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名\n\n\nShowMessage.vue组件：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;p&gt;&#123;&#123;messageInfo&#125;&#125;&lt;/p&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nexport default &#123; \n    props: &#123; \n        messageInfo: String, \n    &#125; \n&#125;\n&lt;/script&gt;App.vue组件中传入：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;show-message messageInfo=&quot;哈哈哈&quot;&gt;&lt;/show-message&gt; \n        &lt;show-message message-info=&quot;哈哈哈&quot;&gt;&lt;/show-message&gt; \n    &lt;/div&gt;\n&lt;/template&gt;重申一次，如果你使用字符串模板，那么这个限制就不存在了。\n2.1.3. 非Prop的Attribute\n什么是非Prop的Attribute呢？\n\n当我们传递给一个组件某个属性，但是该属性并没有定义对应的props或者emits时，就称之为 非Prop的Attribute\n\n常见的包括class、style、id属性等\n\n\n\n\n\nAttribute继承\n当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中：\n\n禁用Attribute继承\n如果我们不希望组件的根元素继承attribute，可以在组件中设置 inheritAttrs: false：\n\n禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素\n\n我们可以通过 $attrs来访问所有的 非props的attribute\n\n\nhtml&lt;template&gt; \n    &lt;div&gt; \n        我是NotPropAttribue组件\n        将attribute应用于 h2 标签\n        &lt;h2 :class=&quot;$attrs.class&quot;&gt;&lt;/h2&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nexport default &#123; \n    inheritAttrs: false \n&#125;\n&lt;/script&gt;多个根节点的attribute\n多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：\nhtml&lt;template&gt; \n    &lt;div :class=&quot;$attrs.class&quot;&gt;我是NotPropAttribue组件1&lt;/div&gt; \n    &lt;div&gt;我是NotPropAttribue组件2&lt;/div&gt; \n    &lt;div&gt;我是NotPropAttribue组件3&lt;/div&gt;\n&lt;/template&gt;2.2. 子组件传递给父组件什么情况下子组件需要传递内容到父组件呢？\n\n当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容\n\n子组件有一些内容想要传递给父组件的时候\n\n\n我们如何完成上面的操作呢？\n\n首先，我们需要在子组件中定义好在某些情况下触发的事件名称\n\n其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中\n\n最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件\n\n\n2.2.1. 自定义事件的流程内部其实是监听两个按钮的点击，点击之后通过 this.$emit的方式发出去事件\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; \n        &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nexport default &#123; \n    emits: [&quot;addOne&quot;, &quot;subOne&quot;], \n    methods: &#123; \n        increment() &#123; \n            this.$emit(&quot;addOne&quot;); \n        &#125;, \n        decrement() &#123; \n            this.$emit(&quot;subOne&quot;); \n        &#125; \n    &#125; \n&#125;\n&lt;/script&gt;我们可以在App.vue中来监听自定义组件发出的事件：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt; \n        &lt;counter-operation @addOne=&quot;add&quot; @subOne=&quot;sub&quot;&gt;&lt;/counter-operation&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nimport CounterOperation from &#39;./CounterOperation.vue&#39;; \nexport default &#123; \n    components: &#123; \n        CounterOperation \n    &#125;, \n    data() &#123; \n        return &#123; counter: 0 \n    &#125; \n    &#125;, \n    methods: &#123; \n        add() &#123; \n            this.counter++ \n        &#125;, \n        sub() &#123; \n            this.counter--; \n        &#125; \n    &#125;\n&#125;\n&lt;/script&gt;2.2.2. 自定义事件的参数自定义事件的时候，我们也可以传递一些参数给父组件：\nhtml&lt;template&gt;\n    &lt;div&gt;\n        &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;\n        &lt;button @click=&quot;incrementTen&quot;&gt;+10&lt;/button&gt;\n        &lt;button @click=&quot;decrement&quot;&gt;-1&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123; \n    methods: &#123; \n        incrementTen() &#123; \n            this.$emit(&quot;addTen&quot;, 10) \n        &#125; \n    &#125; \n&#125;\n&lt;/script&gt;\n&lt;style scoped&gt;&lt;/style&gt;2.2.3. 自定义事件的验证在vue3当中，我们可以对传递的参数进行验证：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;button @click=&quot;incrementTen&quot;&gt;+10&lt;/button&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nexport default &#123; \nemits: &#123; \n    addTen: function(payload) &#123;\n        if (payload === 10) &#123;\n        return true \n    &#125;\n    return false\n    &#125;\n&#125;,\nmethods: &#123; \n    incrementTen() &#123; \n        this.$emit(&quot;addTen&quot;, 10) \n    &#125; \n &#125; \n&#125;\n&lt;/script&gt;2.3. 组件间通信案例练习做一个相对综合的练习：\n\n2.3.1. TabControl实现TabControl.vue的实现代码：\nhtml&lt;template&gt; \n    &lt;div class=&quot;tab-control&quot;&gt; \n        &lt;template v-for=&quot;(item, index) in titles&quot; :key=&quot;item&quot;&gt; \n            &lt;div class=&quot;tab-control-item&quot; @click=&quot;itemClick(index)&quot; :class=&quot;&#123;active: index === currentIndex&#125;&quot;&gt; \n                &lt;span class=&quot;underline&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; \n            &lt;/div&gt; \n        &lt;/template&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123; \n    props: &#123; \n        titles: &#123; \n            type: Array, \n            default() &#123; \n                return []\n            &#125;, \n        &#125;, \n    &#125;,\n    emits: [&quot;titleClick&quot;], \n    data() &#123; \n        return &#123; \n            currentIndex: 0 \n        &#125; \n    &#125;, \n    methods: &#123; \n        itemClick(index) &#123; \n            this.currentIndex = index; \n            this.$emit(&quot;titleClick&quot;, index); \n        &#125;, \n    &#125;,\n&#125;;\n&lt;/script&gt;\n&lt;style scoped&gt; \n.tab-control &#123; \ndisplay: flex; \njustify-content: space-between; \n&#125; \n\n.tab-control-item &#123; \nflex: 1; \ntext-align: center; \nheight: 40px; \nline-height: 40px; \n&#125; \n\n.tab-control-item.active &#123; \ncolor: red; \n&#125; \n\n.tab-control-item.active span &#123; \ndisplay: inline-block; \nborder-bottom: 4px solid red; \npadding: 0 10px; \n&#125;\n&lt;/style&gt;2.3.2. App中的使用我们在App中的使用过程如下：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;tab-control :titles=&quot;titles&quot; @titleClick=&quot;titleClick&quot;&gt;&lt;/tab-control&gt; \n        &lt;h2&gt;&#123;&#123;contents[currentIndex]&#125;&#125;&lt;/h2&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nimport TabControl from &#39;./TabControl.vue&#39;; \nexport default &#123; \n    components: &#123; TabControl &#125;, \n    data() &#123; \n        return &#123; \n            titles: [&quot;衣服&quot;, &quot;鞋子&quot;, &quot;裤子&quot;], \n            contents: [&quot;衣服页面&quot;, &quot;鞋子页面&quot;, &quot;裤子页面&quot;], \n            currentIndex: 0 \n        &#125; \n    &#125;, \n    methods: &#123; \n        titleClick(index) &#123; \n            this.currentIndex = index; \n        &#125; \n    &#125; \n&#125;\n&lt;/script&gt;3. 非父子组件的相互通信在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。\n这里主要讲两种方式：\n\nProvide&#x2F;Inject\n\nMitt全局事件总线\n\n\n3.1. Provide &#x2F; InjectProvide &#x2F; Inject用于非父子组件之间共享数据：\n\n比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容；\n\n在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦；\n\n\n对于这种情况下，我们可以使用 Provide 和 Inject ：\n\n无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；\n\n父组件有一个 provide 选项来提供数据\n\n子组件有一个 inject 选项来开始使用这些数据\n\n\n实际上，你可以将依赖注入看作是“long range props”，除了：\n\n父组件不需要知道哪些子组件使用它 provide 的 property\n\n子组件不需要知道 inject 的 property 来自哪里\n\n\n3.1.1. 基本使用我们开发一个这样的结构：\n\nApp.vue组件提供数据：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;home&gt;&lt;/home&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nimport Home from &#39;./Home.vue&#39;; \nexport default &#123; \n    components: &#123; Home &#125;, \n    provide: &#123;\n        name: &quot;why&quot;, \n        age: 18 \n    &#125; \n&#125;\n&lt;/script&gt;Home.vue是中间的组件：\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;home-content&gt;&lt;/home-content&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nimport HomeContent from &#39;./HomeContent.vue&#39;; \nexport default &#123; \n    components: &#123; HomeContent &#125; \n&#125;\n&lt;/script&gt;HomeContent.vue是获取数据的组件：\nhtml&lt;template&gt; \n    &lt;div&gt;\n        &lt;h2&gt;HomeContent&lt;/h2&gt; \n        &lt;h2&gt;&#123;&#123;name&#125;&#125;-&#123;&#123;age&#125;&#125;&lt;/h2&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nexport default &#123; \n    inject: [&quot;name&quot;, &quot;age&quot;] \n&#125;\n&lt;/script&gt;3.1.2. 函数写法如果Provide中提供的一些数据是来自data，那么我们可能会想要通过this来获取：\nhtml&lt;script&gt;\nimport Home from &#39;./Home.vue&#39;\n\nexport default &#123;\n    components: &#123;\n        Home\n    &#125;,\n    data() &#123;\n        return &#123;\n            names: [&quot;abc&quot;, &quot;cba&quot;]\n        &#125;\n    &#125;,\n    provide: &#123;\n        name: &quot;why&quot;,\n        age: &quot;18&quot;,\n        length: this.names.length\n    &#125;\n&#125;\n&lt;/script&gt;这个时候会报错：\nbashUncaught TypeError: Cannot read property &#39;names&#39; of undefined如何解决这个问题呢？\n我们需要将provide转成为返回对象的函数\njavascriptprovide() &#123;\n    return &#123;\n        name: &quot;why&quot;,\n        age: 18,\n        length: this.names.length\n    &#125;\n&#125;3.1.3. 处理响应式我们先来验证一个结果：如果我们修改了this.names的内容，那么使用length的子组件会不会是响应式的？\nhtml&lt;template&gt; \n    &lt;div&gt; \n        &lt;home&gt;&lt;/home&gt; \n        &lt;button @click=&quot;addName&quot;&gt;添加name&lt;/button&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nimport Home from &#39;./Home.vue&#39;; \nexport default &#123; \n    components: &#123; Home &#125;, \n    data() &#123; \n        return &#123; \n        names: [&quot;abc&quot;, &quot;cba&quot;] &#125; \n    &#125;, \n    provide() &#123; \n        return &#123; \n            name: &quot;why&quot;, \n            age: 18, \n            length: this.names.length \n        &#125; \n    &#125;, \n    methods: &#123; \n        addName() &#123; \n            this.names.push(&quot;why&quot;);\n        &#125; \n    &#125; \n&#125;\n&lt;/script&gt;我们会发现对应的子组件中是没有反应的：\n这是因为当我们修改了names之后，之前在provide中引入的 this.names.length 本身并不是响应式的\n那么怎么样可以让我们的数据变成响应式的呢？\n非常的简单，我们可以使用响应式的一些API来完成这些功能，比如说computed函数\n当然，这个computed是vue3的新特性\n注意：我们在使用length的时候需要获取其中的value，这是因为computed返回的是一个ref对象，需要取出其中的value来使用\n\nProvide和Inject也可以在Composition API中使用\n3.2. 全局事件总线Vue3从实例中移除了 $on、$off 和 $once 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库：\n\nVue3官方有推荐一些库，例如 mitt 或 tiny-emitter；\n\n这里我们主要讲解一下mitt库的使用；\n\n\n首先，我们需要先安装这个库：\nbashnpm install mitt其次，我们可以封装一个工具eventbus.js：\njavascript// 可以创建很多个emitter对象const emitter = mitt();export default emitter;\nimport mitt from &#39;mitt&#39;;在项目中可以使用它们：\n\n我们在Home.vue中监听事件；\n\n我们在App.vue中触发事件；\n\n\nHome.vue组件中监听事件：\nhtml&lt;template&gt; \n    &lt;div&gt; \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt; \nimport emitter from &#39;./eventBus&#39;; \nexport default &#123; \n    created() &#123; \n        emitter.on(&quot;why&quot;, (info) =&gt; &#123; \n            console.log(&quot;why event:&quot;, info); \n        &#125;); \n        emitter.on(&quot;kobe&quot;, (info) =&gt; &#123; \n            console.log(&quot;kobe event:&quot;, info); &#125;); \n        emitter.on(&quot;*&quot;, (type, e) =&gt; &#123; \n            console.log(&quot;* event:&quot;, type, e); \n        &#125;); \n    &#125; \n&#125;\n&lt;/script&gt;其他API的补充，如果在某些情况下我们想要取消事件，可以使用下面的API：\njavascript// 取消emitter中所有的监听emitter.all.clear()\n// 定义一个函数\nfunction onFoo() &#123;&#125;\nemitter.on(&#39;foo&#39;, onFoo)   // 监听\nemitter.off(&#39;foo&#39;, onFoo)  // 取消监听\n结语学如逆水行舟，不进则退\n2023 9 15&#96;\n","slug":"前端框架开发【六】组件之间通信","date":"2023-09-15T02:56:48.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"8861984eced3666bfbbba785cdca3adb","title":"前端框架开发【五】组件化开发基础","content":"\n组件化开发的地位\n现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想。\n所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。\n\n\n\n1. 认识组件化1.1. 什么是组件化？人面对复杂问题的处理方式：\n\n任何一个人处理信息的逻辑能力都是有限的\n\n所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。\n\n但是，我们人有一种天生的能力，就是将问题进行拆解。\n\n如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。\n\n\n\n组件化也是类似的思想：\n\n如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展\n\n但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了\n\n如果我们将一个个功能块拆分后，就可以像搭建积木一下来搭建我们的项目\n\n\n\n我们需要通过组件化的思想来思考整个应用程序：\n\n我们将一个完整的页面分成很多个组件\n\n每个组件都用于实现页面的一个功能块\n\n而每一个组件又可以进行细分\n\n而组件本身又可以在多个地方进行复用\n\n\n1.2. Vue的组件化组件化是Vue、React、Angular的核心思想，也是我们后续课程的重点（包括以后实战项目）：\n\n前面我们的createApp函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的根组件\n\n组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用\n\n任何的应用都会被抽象成一颗组件树\n\n\n\n2. 注册一个组件2.1. 注册全局组件如果我们现在有一部分内容（模板、逻辑等），我们希望将这部分内容抽取到一个独立的组件中去维护，这个时候如何注册一个组件呢？\n我们先从简单的开始谈起，比如下面的模板希望抽离到一个单独的组件：\nhtml&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;  \n&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;注册组件分成两种：\n\n全局组件：在任何其他的组件中都可以使用的组件；\n\n局部组件：只有在注册的组件中才能使用的组件；\n\n\n全局组件的注册：\n\n全局组件需要使用我们全局创建的app来注册组件\n\n通过component方法传入组件名称、组件对象即可注册一个全局组件了\n\n\nhtml  &lt;template id=&quot;my-cpn&quot;&gt;  \n    &lt;h2&gt;我是组件标题&lt;/h2&gt;  \n    &lt;p&gt;我是组件内容，哈哈哈哈&lt;/p&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n  const app = Vue.createApp(App);  \n    // 注册全局组件(使用app)  \n    app.component(&quot;my-cpn&quot;, &#123;  \n      template: &quot;#my-cpn&quot;  \n    &#125;);  \n  \n    app.mount(&#39;#app&#39;);  \n   &lt;/script&gt;之后，我们可以在App组件的template中直接使用这个全局组件：\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;my-cpn&gt;&lt;/my-cpn&gt;  \n    &lt;my-cpn&gt;&lt;/my-cpn&gt;  \n    &lt;my-cpn&gt;&lt;/my-cpn&gt;  \n    &lt;my-cpn&gt;&lt;/my-cpn&gt;  \n  &lt;/template&gt;当然，我们组件本身也可以有自己的代码逻辑：\njavascript// 注册全局组件(使用app)  \napp.component(&quot;my-cpn&quot;, &#123;  \n  template: &quot;#my-cpn&quot;,  \n  data() &#123;  \n    return &#123;  \n      title: &quot;我是标题&quot;,  \n      message: &quot;我是内容, 哈哈哈哈&quot;  \n    &#125;  \n  &#125;,  \n  methods: &#123;  \n    btnClick() &#123;  \n      console.log(&quot;btnClick&quot;);  \n    &#125;  \n  &#125;  \n&#125;);2.2. 组件的名称在通过app.component注册一个组件的时候，第一个参数是组件的名称，定义组件名的方式有两种：\n方式一：使用kebab-case（短横线分割符）\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;\njavascriptapp.component(&#39;my-component-name&#39;, &#123;  \n  /* ... */  \n&#125;)方式二：使用PascalCase（驼峰标识符）\n当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的\njavascriptapp.component(&#39;MyComponentName&#39;, &#123;  \n  /* ... */  \n&#125;)2.3. 注册局部组件全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注册：\n\n比如我们注册了三个全局组件：ComponentA、ComponentB、ComponentC\n\n在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包\n\n这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包的大小\n\n\n所以在开发中我们通常使用组件的时候采用的都是局部注册：\n\n局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册\n\n比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项\n\n该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象\n\n\n接下来，我们看一下局部组件是如何注册的：\nhtml &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;component-a&gt;&lt;/component-a&gt;  \n    &lt;component-b&gt;&lt;/component-b&gt;  \n  &lt;/template&gt;  \n  \n  &lt;template id=&quot;component-a&quot;&gt;  \n    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;  \n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;  \n  &lt;/template&gt;  \n  \n  \n  &lt;template id=&quot;component-b&quot;&gt;  \n    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;  \n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n  const ComponentA = &#123;  \n      template: &quot;#component-a&quot;,  \n      data() &#123;  \n        return &#123;  \n          title: &quot;我是ComponentA标题&quot;,  \n          message: &quot;我是ComponentA内容, 哈哈哈哈&quot;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    const ComponentB = &#123;  \n      template: &quot;#component-b&quot;,  \n      data() &#123;  \n        return &#123;  \n          title: &quot;我是ComponentB标题&quot;,  \n          message: &quot;我是ComponentB内容, 呵呵呵呵&quot;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      components: &#123;  \n        &#39;component-a&#39;: ComponentA,  \n        &#39;component-b&#39;: ComponentB,  \n      &#125;,  \n      data() &#123;  \n        return &#123;  \n          message: &quot;Hello World&quot;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;3. Vue 的开发模式3.1. Vue的开发模式目前我们使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。\n但是随着项目越来越复杂，我们会采用组件化的方式来进行开发：\n\n这就意味着每个组件都会有自己的模板、脚本逻辑、样式等；\n\n当然我们依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来；\n\n也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题；\n\n并且我们的代码为了适配更一些浏览器，必须使用ES5的语法；\n\n在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码；\n\n\n所以在真实开发中，我们可以通过一个后缀名为 .vue 的single-file components (单文件组件) 来解决，并且可以使用webpack或者vite或者rollup等构建工具来对其进行处理。\nhtml&lt;template&gt;\n    &lt;p&gt;&#123;&#123; greeting &#125;&#125; World!&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nmodule.exports = &#123;\n    data: function() &#123;\n        return &#123;\n            greeting: &quot;Hello&quot;\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n\n&lt;style&gt;\np &#123;\n    font-size: 2em;\n    text-align: center;\n&#125;\n&lt;/style&gt;在这个组件中我们可以获得非常多的特性：\n\n代码的高亮；\n\nES6、CommonJS的模块化能力\n\n组件作用域的CSS\n\n可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等\n\n\n3.2. 如何支持SFC如果我们想要使用这一的SFC的.vue文件，比较常见的是两种方式：\n\n方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件；\n\n方式二：自己使用webpack或rollup或vite这类打包工具，对其进行打包处理；\n\n\n我们最终，无论是后期我们做项目，还是在公司进行开发，通常都会采用Vue CLI的方式来完成。\n结语学如逆水行舟，不进则退\n2023 9 14&#96;\n","slug":"前端框架开发【五】组件化开发基础","date":"2023-09-14T02:56:34.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"4951390b4f98c8a91026a3bf12f3018f","title":"前端框架开发【四】VUE开发基础语法（下）","content":"1. Options API1.1 computed1.1.1. 认识计算属性在模板中可以直接通过插值语法显示一些data中的数据。\n但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示。\n比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示；\n在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算；\n在模板中放入太多的逻辑会让模板过重和难以维护；\n并且如果多个地方都使用到，那么会有大量重复的代码；\n我们有没有什么方法可以将逻辑抽离出去呢？\n可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中；\n但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用；\n另外一种方式就是使用计算属性computed；\n\n什么是计算属性 ？\n\n官方并没有给出直接的概念解释\n\n而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性\n\n计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例\n\n\n\n\n\n1.1.2. 计算属性的基本使用计算属性的用法：\n\n选项： computed\n\n类型： &#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;\n\n\n我们来看三个案例：\n\n我们有两个变量：firstName和lastName，希望它们拼接之后在界面上显示\n\n我们有一个分数：score\n\n当score大于60的时候，在界面上显示及格\n\n当score小于60的时候，在界面上显示不及格\n\n\n\n我们有一个变量message，记录一段文字：比如Hello World\n\n某些情况下我们是直接显示这段文字\n\n某些情况下我们需要对这段文字进行反转\n\n\n\n\n我们可以有三种实现思路：\n\n思路一：在模板语法中直接使用表达式\n\n思路二：使用method对逻辑进行抽取\n\n思路三：使用计算属性computed\n\n\n\n思路一的实现：模板语法\n\n缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）\n\n缺点二：当有多次一样的逻辑时，存在重复的代码\n\n缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存\n\n\nhtml&lt;template id=&quot;my-app&quot;&gt;  \n    &lt;!-- 1.实现思路一: --&gt;  \n    &lt;h2&gt;&#123;&#123; firstName + lastName &#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123; score >= 60 ? \"及格\": \"不及格\" &#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123; message.split(\"\").reverse().join(\" \") &#125;&#125;&lt;/h2&gt;  \n&lt;/template&gt;\n\n\n\n思路二的实现：method实现\n\n缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用\n\n缺点二：多次使用方法的时候，没有缓存，也需要多次计算\n\n\njavascript&lt;!-- 2.实现思路二: --&gt;  \n&lt;template id=&quot;my-app&quot;&gt;  \n&lt;h2&gt;&#123;&#123; getFullName()&#125;&#125;&lt;/h2&gt;  \n&lt;h2&gt;&#123;&#123; getResult() &#125;&#125;&lt;/h2&gt;  \n&lt;h2&gt;&#123;&#123; getReverseMessage() &#125;&#125;&lt;/h2&gt;  \n&lt;/template&gt;  \n\n\n&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n&lt;script&gt;    const App = &#123;  \n  template: &#39;#my-app&#39;,  \n  data() &#123;  \n    return &#123;  \n      firstName: &quot;Kobe&quot;,  \n      lastName: &quot;Bryant&quot;,  \n      score: 80,  \n      message: &quot;Hello World&quot;  \n    &#125;  \n  &#125;,  \n  methods: &#123;  \n    getFullName() &#123;  \n      return this.firstName + &quot; &quot; + this.lastName;  \n    &#125;,  \n    getResult() &#123;  \n      return this.score &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;;  \n    &#125;,  \n    getReverseMessage() &#123;  \n      return this.message.split(&quot; &quot;).reverse().join(&quot; &quot;);  \n    &#125;  \n  &#125;  \n&#125;  \n\nVue.createApp(App).mount(&#39;#app&#39;);  &lt;/script&gt;\n\n\n\n思路三的实现：computed实现\n\n注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个与setter和getter时是有关的\n\n我们会发现无论是直观上，还是效果上计算属性都是更好的选择\n\n并且计算属性是有缓存的\n\n\njavascript  &lt;!-- 3.实现思路三: --&gt;  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;h2&gt;&#123;&#123; fullName &#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123; result &#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123; reverseMessage &#125;&#125;&lt;/h2&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          firstName: &quot;Kobe&quot;,  \n          lastName: &quot;Bryant&quot;,  \n          score: 80,  \n          message: &quot;Hello World&quot;  \n        &#125;  \n      &#125;,  \n      computed: &#123;  \n        fullName() &#123;  \n          return this.firstName + this.lastName;  \n        &#125;,  \n        result() &#123;  \n          return this.score &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;;  \n        &#125;,  \n        reverseMessage() &#123;  \n          return this.message.split(&quot; &quot;).reverse().join(&quot; &quot;);  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  &lt;/script&gt;\n\n\n1.1.3. 计算属性 vs methods在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。\n接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;!-- 1.使用methods --&gt;  \n    &lt;h2&gt;&#123;&#123;getResult()&#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123;getResult()&#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123;getResult()&#125;&#125;&lt;/h2&gt;  \n  \n    &lt;!-- 2.使用computed --&gt;  \n    &lt;h2&gt;&#123;&#123;result&#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123;result&#125;&#125;&lt;/h2&gt;  \n    &lt;h2&gt;&#123;&#123;result&#125;&#125;&lt;/h2&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n  const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          score: 90  \n        &#125;  \n      &#125;,  \n      computed: &#123;  \n        result() &#123;  \n          console.log(&quot;调用了计算属性result的getter&quot;);  \n          return this.score &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;;  \n        &#125;  \n      &#125;,  \n      methods: &#123;  \n        getResult() &#123;  \n          console.log(&quot;调用了getResult方法&quot;);  \n          return this.score &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;打印结果如下：\n\n我们会发现methods在多次使用时，会调用多次\n\n而计算属性虽然使用了三次，但是计算的过程只调用了一次\n\n\n\n这是什么原因呢？\n\n这是因为计算属性会基于它们的依赖关系进行缓存\n\n在数据不发生变化时，计算属性是不需要重新计算的\n\n但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算\n\n\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;input type=&quot;text&quot; v-model=&quot;score&quot;&gt;  \n  \n    &lt;!-- 省略代码 --&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          score: 90  \n        &#125;  \n      &#125;,  \n      // 省略代码  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;我们来看一下当分数变化时，方法和计算属性的反应：\n\n1.1.4. 计算属性的 setter 和 getter计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。\n但是，如果我们确实想设置计算属性的值呢？\n这个时候我们也可以给计算属性设置一个setter的方法\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;  \n    &lt;button @click=&quot;setNewName&quot;&gt;设置新名字&lt;/button&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          firstName: &quot;Kobe&quot;,  \n          lastName: &quot;Bryant&quot;  \n        &#125;  \n      &#125;,  \n      computed: &#123;  \n        fullName: &#123;  \n          get() &#123;  \n            return this.firstName + &quot; &quot; + this.lastName;  \n          &#125;,  \n          set(value) &#123;  \n            const names = value.split(&quot; &quot;);  \n            this.firstName = names[0];  \n            this.lastName = names[1];  \n          &#125;  \n        &#125;  \n      &#125;,  \n      methods: &#123;  \n        setNewName() &#123;  \n          this.fullName = &quot;coder why&quot;;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n &lt;/script&gt;你可能觉得很奇怪，Vue内部是如何对我们传入的是一个getter，还是说是一个包含setter和getter的对象进行处理的呢？\n事实上非常的简单，Vue源码内部只是做了一个逻辑判断而已\n\n1.2. 侦听器 watch1.2.1. 侦听器 watch 的基本使用\n什么是侦听器呢 ？\n\n开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中\n\n当数据变化时，template会自动进行更新来显示最新的数据\n\n但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了\n\n\n\n\n\n举个栗子（例子）：\n比如现在我们希望用户在input中输入一个问题\n每当用户输入了最新的内容，我们就获取到最新的内容，并且使用该问题去服务器查询答案\n那么，我们就需要实时的去获取最新的数据变化\nhtml&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\n&lt;template id=&quot;my-app&quot;&gt;\n&lt;label for=&quot;question&quot;&gt;\n  请输入问题:\n  &lt;input type=&quot;text&quot; id=&quot;question&quot; v-model=&quot;question&quot;&gt;\n&lt;/label&gt;\n&lt;/template&gt;\n\n&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;    \nconst App = &#123;\n  template: &#39;#my-app&#39;,\n  data() &#123;\n    return &#123;\n      question: &quot;&quot;,\n      info: &#123;\n        name: &quot;why&quot;\n      &#125;\n    &#125;\n  &#125;,\n  watch: &#123;\n    question(newValue, oldValue) &#123;\n      this.getAnwser(newValue);\n    &#125;\n  &#125;,\n  methods: &#123;\n    // 杀向服务器\n    getAnwser(question) &#123;\n      console.log(`$&#123;question&#125;的问题答案是哈哈哈哈`);\n    &#125;\n  &#125;\n&#125;\n\nVue.createApp(App).mount(&#39;#app&#39;);\n&lt;/script&gt;1.2.2. 侦听器 watch 的配置选项我们先来看一个例子：\n\n当我们点击按钮的时候会修改info.name的值；\n\n这个时候我们使用watch来侦听info，可以侦听到吗？答案是不可以。\n\n\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;button @click=&quot;btnClick&quot;&gt;修改info&lt;/button&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          info: &#123;  \n            name: &quot;why&quot;  \n          &#125;  \n        &#125;  \n      &#125;,  \n      watch: &#123;  \n        info(newValue, oldValue) &#123;  \n          console.log(newValue, oldValue);  \n        &#125;  \n      &#125;,  \n      methods: &#123;  \n        btnClick() &#123;  \n          this.info.name = &quot;kobe&quot;;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;这是因为默认情况下，watch只是在侦听info的引用变化，对于内部属性的变化是不会做出相应的：\n\n这个时候我们可以使用一个选项deep进行更深层的侦听\n\n注意watch里面侦听的属性对应的可以是一个Object\n\n\n还有另外一个属性，是希望一开始的就会立即执行一次：\n这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次\njavascriptwatch: &#123;  \n    info: &#123;    \n        handler(newValue, oldValue) &#123;      \n            console.log(newValue, oldValue);    \n        &#125;,    \n        deep: true,    \n        immediate: true  \n   &#125;\n&#125;1.2.3. 侦听器 watch 的其它方式直接来看官方文档的案例：\njavascriptconst app = Vue.createApp(&#123;  \ndata() &#123;    \n    return &#123;      \n        a: 1,      \n        b: 2,      \n        c: &#123;        \n        d: 4      \n        &#125;,      \n        e: &#39;test&#39;,      \n        f: 5    \n    &#125;  \n&#125;,  \nwatch: &#123;\n    a(val, oldVal) &#123;\n        console.log(`new: $&#123;val&#125;, old: $&#123;oldVal&#125;`)\n    &#125;,\n    // 字符串方法名\n    b: &#39;someMethod&#39;,\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深   \n    c: &#123;\n        handler(val, oldVal) &#123;\n            console.log(&#39;c changed&#39;) \n        &#125;,\n        deep: true\n    &#125;,\n    // 该回调将会在侦听开始之后被立即调用 \n    e: &#123;\n        handler(val, oldVal) &#123;\n            console.log(&#39;e changed&#39;)    \n        &#125;,\n        immediate: true\n    &#125;,\n    // 你可以传入回调数组，它们会被逐一调用    \n    f: [ \n        &#39;handle1&#39;,\n        function handle2(val, oldVal) &#123;      \n            console.log(&#39;handle2 triggered&#39;)   \n        &#125;,\n        &#123;\n            handler: function handle3(val, oldVal) &#123;\n                console.log(&#39;handle3 triggered&#39;)\n            &#125;\n        &#125;\n    ]\n    &#125;,\n    methods: &#123;\n        someMethod() &#123;  \n            console.log(&#39;b changed&#39;)\n        &#125;,\n        handle1() &#123;\n            console.log(&#39;handle 1 triggered&#39;)\n        &#125;\n    &#125;\n&#125;)另外一个是Vue3文档中没有提到的，但是Vue2文档中有提到的是侦听对象的属性：\njavascript&#39;info.name&#39;: function(newValue, oldValue) &#123;  \n    console.log(newValue, oldValue);\n&#125;还有另外一种方式就是使用 $watch 的API：\n\n我们可以在created的生命周期中，使用 this.$watchs 来侦听\n\n第一个参数是要侦听的源\n\n第二个参数是侦听的回调函数callback\n\n第三个参数是额外的其他选项，比如deep、immediate\n\n\njavascriptcreated() &#123;  \n    this.$watch(&#39;message&#39;, (newValue, oldValue) =&gt; &#123;    \n        console.log(newValue, oldValue);  \n    &#125;, \n    &#123;\n        deep: true, \n        immediate: true\n    &#125;\n)&#125;2. 阶段案例\n书籍购物车\n案例效果\n\n案例说明\n\n1.在界面上以表格的形式，显示一些书籍的数据\n\n2.在底部显示书籍的总价格\n\n3.点击+或者-可以增加或减少书籍数量（如果为1，那么不能继续-）\n\n4.点击移除按钮，可以将书籍移除（当所有的书籍移除完毕时，显示：购物车为空~）\n\n\n\n\n\n项目搭建模板引擎的搭建我们先来搭建一下模板引擎：\n\n它需要一个table来包裹需要展示的书籍内容\n\n需要一个h2元素用于计算商品的总价格\n\n\n在这里我们有一些数据和方法需要在组件对象（createApp传入的对象）中定义：\n\n比如book的数据\n\nformatPrice、decrement、increment、handleRemove的方法等\n\n\nhtml  &lt;template id=&quot;myapp&quot;&gt;\n      &lt;table&gt;\n        &lt;thead&gt;\n            &lt;tr&gt;\n              &lt;th&gt;书籍名称&lt;/th&gt;\n              &lt;th&gt;出版日期&lt;/th&gt;\n              &lt;th&gt;价格&lt;/th&gt;\n              &lt;th&gt;购买数量&lt;/th&gt;\n              &lt;th&gt;操作&lt;/th&gt;\n            &lt;/tr&gt;\n         &lt;/thead&gt;\n      &lt;tbody&gt;\n         &lt;tr v-for=&quot;(item, index) in filterBooks&quot; :key=&quot;item.id&quot;&gt;\n            &lt;td&gt;&#123;&#123;index + 1&#125;&#125;&lt;/td&gt;\n            &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;\n            &lt;td&gt;&#123;&#123;item.date&#125;&#125;&lt;/td&gt;\n            &lt;td&gt;&#123;&#123;formatPrice(item.price)&#125;&#125;&lt;/td&gt;\n            &lt;td&gt;\n              &lt;button @click=&quot;decrement(index)&quot; :disabled=&quot;item.count &lt;= 1&quot;&gt;-&lt;/button&gt;\n              &#123;&#123;item.count&#125;&#125;\n              &lt;button @click=&quot;increment(index)&quot;&gt;+&lt;/button&gt;\n            &lt;/td&gt;\n            &lt;td&gt;\n              &lt;button @click=&quot;handleRemove(index)&quot;&gt;移除&lt;/button&gt;\n            &lt;/td&gt;\n         &lt;/tr&gt;\n       &lt;/tbody&gt;\n     &lt;/table&gt;\n     &lt;h2&gt;总价: &#123;&#123;formatPrice(totalPrice)&#125;&#125;&lt;/h2&gt;\n &lt;/template&gt;css样式的实现实现一些css的样式\ncsstable &#123;\n    border: 1px solid #e9e9e9;\n    border-collapse: collapse;\n    border-spacing: 0;\n&#125;\n\nth, td &#123;\n    padding: 8px 16px;\n    border: 1px solid #e9e9e9;\n    text-align: left;\n&#125;\n\nth &#123;\n    background-color: #f7f7f7;\n    color: #5c6b77;\n    font-weight: 600;\n&#125;代码逻辑的实现javascriptconst App = &#123;\n  template: &#39;#my-app&#39;,\n  data() &#123;\n    return &#123;\n      books:  [\n        &#123;id: 1,name: &#39;《算法导论》&#39;, date: &#39;2006-9&#39;, price: 85.00, count: 1 &#125;,\n        &#123;id: 2, name: &#39;《UNIX编程艺术》&#39;, date: &#39;2006-2&#39;,  price: 59.00,count: 1  &#125;,\n        &#123;id: 3, name: &#39;《编程珠玑》&#39;, date: &#39;2008-10&#39;,price: 39.00, count: 1 &#125;,\n        &#123;id: 4, name: &#39;《代码大全》&#39;,  date: &#39;2006-3&#39;, price: 128.00, count: 1 &#125;,\n        ]\n      &#125;\n  &#125;,\n  computed: &#123;\n    filterBooks() &#123;\n      return this.books.map(item =&gt; &#123;\n          item.price = &quot;¥&quot; + item.price;\n          return item;\n      &#125;);\n    &#125;,\n    totalPrice() &#123;\n      return this.books.reduce((preValue, item) =&gt; &#123;\n        return preValue + item.price * item.count;\n      &#125;, 0)\n    &#125;\n  &#125;,\n  methods: &#123;\n    formatPrice(price) &#123;\n      return &quot;¥&quot; + price;\n    &#125;,\n    decrement(index) &#123;\n      this.books[index].count--;\n    &#125;,\n    increment(index) &#123;\n      this.books[index].count++;\n    &#125;,\n    handleRemove(index) &#123;\n        this.books.splice(index, 1);\n    &#125;\n  &#125;\n&#125;\nVue.createApp(App).mount(&#39;#app&#39;);3. 表单输入3.1. v-model基本用法表单提交是开发中非常常见的功能，也是和用户交互的重要手段：\n\n比如用户在登录、注册时需要提交账号密码\n\n比如用户在检索、创建、更新信息时，需要提交一些数据\n\n\n这些都要求我们可以在代码逻辑中获取到用户提交的数据，我们通常会使用v-model指令来完成：\n\nv-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定\n\n它会根据控件类型自动选取正确的方法来更新元素\n\n尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理\n\n\nhtml&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n&lt;template id=&quot;my-app&quot;&gt;\n  &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;\n  &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;\n&lt;/template&gt;\n&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nconst App = &#123;\n  template: &#39;#my-app&#39;,\n  data() &#123;\n    return &#123;\n      message: &quot;Hello World&quot;\n    &#125;\n  &#125;\n&#125;\nVue.createApp(App).mount(&#39;#app&#39;);\n&lt;/script&gt;3.2. v-model的原理官方有说到，v-model的原理其实是背后有两个操作：\n\nv-bind绑定value属性的值\n\nv-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中\n\n\nhtml&lt;input v-model=&quot;searchText&quot; /&gt;等价于\nhtml&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot;&gt;事实上v-model的原理会比上面的等价关系更加复杂：\n\n3.3. v-model绑定其他我们再来绑定一下其他的表单类型：textarea、checkbox、radio、select\nhtml&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n&lt;template id=&quot;my-app&quot;&gt;\n  &lt;!-- 1.绑定textarea --&gt;\n  &lt;div&gt;\n    &lt;textarea v-model=&quot;article&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;\n    &lt;h2&gt;article当前的值是: &#123;&#123;article&#125;&#125;&lt;/h2&gt;\n  &lt;/div&gt;\n  &lt;!-- 2.绑定checkbox --&gt;\n  &lt;!-- 2.1.单选框 --&gt;\n  &lt;div&gt;\n    &lt;label for=&quot;agreement&quot;&gt;\n    &lt;input id=&quot;agreement&quot; type=&quot;checkbox&quot; v-model=&quot;isAgree&quot;&gt;同意协议&lt;/label&gt;\n    &lt;h2&gt;isAgree当前的值是: &#123;&#123;isAgree&#125;&#125;&lt;/h2&gt;\n  &lt;/div&gt;\n  &lt;!-- 2.2.多选框 --&gt;\n  &lt;div&gt;\n    &lt;label for=&quot;basketball&quot;&gt;\n      &lt;input id=&quot;basketball&quot; type=&quot;checkbox&quot; value=&quot;basketball&quot; v-model=&quot;hobbies&quot;&gt;篮球\n    &lt;/label&gt;\n    &lt;label for=&quot;football&quot;&gt;\n      &lt;input id=&quot;football&quot; type=&quot;checkbox&quot; value=&quot;football&quot; v-model=&quot;hobbies&quot;&gt;足球\n      &lt;/label&gt;\n    &lt;label for=&quot;tennis&quot;&gt;\n      &lt;input id=&quot;tennis&quot; type=&quot;checkbox&quot; value=&quot;tennis&quot; v-model=&quot;hobbies&quot;&gt;网球\n    &lt;/label&gt;\n    &lt;h2&gt;hobbies当前的值是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;\n  &lt;/div&gt;\n  &lt;!-- 3.绑定radio --&gt;\n  &lt;div&gt;\n  &lt;label for=&quot;male&quot;&gt;\n    &lt;input type=&quot;radio&quot; id=&quot;male&quot; v-model=&quot;gender&quot; value=&quot;male&quot;&gt;男\n  &lt;/label&gt;\n  &lt;label for=&quot;female&quot;&gt;\n    &lt;input type=&quot;radio&quot; id=&quot;female&quot; v-model=&quot;gender&quot; value=&quot;female&quot;&gt;女\n  &lt;/label&gt;\n  &lt;h2&gt;gender当前的值是: &#123;&#123;gender&#125;&#125;&lt;/h2&gt;\n  &lt;/div&gt;\n  &lt;!-- 4.绑定select --&gt;\n  &lt;div&gt;\n    &lt;select v-model=&quot;fruit&quot;&gt;\n      &lt;option disabled value=&quot;&quot;&gt;请选择喜欢的水果&lt;/option&gt;\n      &lt;option value=&quot;apple&quot;&gt;苹果&lt;/option&gt;\n      &lt;option value=&quot;orange&quot;&gt;橘子&lt;/option&gt;\n      &lt;option value=&quot;banana&quot;&gt;香蕉&lt;/option&gt;\n    &lt;/select&gt;\n    &lt;h2&gt;fruit当前的值是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nconst App = &#123;\n  template: &#39;#my-app&#39;,\n  data() &#123;\n    return &#123;\n      article: &quot;Hello World&quot;,\n      isAgree: false,\n      gender: &quot;male&quot;,\n      fruit: &quot;&quot;\n    &#125;\n  &#125;\n&#125;\nVue.createApp(App).mount(&#39;#app&#39;);\n&lt;/script&gt;3.4. v-model的值绑定目前我们在前面的案例中大部分的值都是在template中固定好的：\n\n比如gender的两个输入框值male、female；\n\n比如hobbies的三个输入框值basketball、football、tennis；\n\n\n在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定。\n3.5. v-model的修饰符v-model在使用的时候可以在后面跟一些修饰符，来完成一些特殊的操作。\n3.5.1. lazy修饰符lazy修饰符是什么作用呢？\n\n默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步；\n\n如果我们在v-model后跟上lazy修饰符，那么会将绑定的事件切换为 change 事件，只有在提交时（比如回车）才会触发；\n\n\nhtml&lt;template id=&quot;my-app&quot;&gt;    \n &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;    \n &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;  \n&lt;/template&gt;3.5.2. number修饰符我们先来看一下v-model绑定后的值是什么类型的：\nmessage总是string类型，即使在我们设置type为number也是string类型；\nhtml&lt;template id=&quot;my-app&quot;&gt;\n    &lt;!-- 类型 --&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;\n    &lt;input type=&quot;number&quot; v-model=&quot;message&quot;&gt;\n    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;\n&lt;/template&gt;\n&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\nconst App = &#123;\n    template: &#39;#my-app&#39;,\n    data() &#123; \n        return &#123;     \n            message: &quot;&quot;\n        &#125;\n    &#125;,\n    watch: &#123;\n        message(newValue) &#123;\n            console.log(newValue, typeof newValue);     \n        &#125;      \n    &#125;    \n    &#125;    \n    Vue.createApp(App).mount(&#39;#app&#39;);\n&lt;/script&gt;如果我们希望转换为数字类型，那么可以使用 .number 修饰符：\nhtml&lt;template id=&quot;my-app&quot;&gt;    \n    &lt;!-- 类型 --&gt;    \n    &lt;input type=&quot;text&quot; v-model.number=&quot;score&quot;&gt;  \n&lt;/template&gt;另外，在我们进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的：\n下面的score在进行判断的过程中会进行隐式转化的；\njavascriptconst score = &quot;100&quot;;\nif (score &gt; 90) &#123;\n    console.log(&quot;优秀&quot;);\n&#125;3.5.3. trim修饰符如果要自动过滤用户输入的首尾空白字符，可以给v-model添加 trim 修饰符：\n  &lt;template id=&quot;my-app&quot;&gt;    &lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt;  &lt;/template&gt;\n3.6. v-model组件使用v-model也可以使用在组件上，Vue2版本和Vue3版本有一些区别\n结语学如逆水行舟，不进则退\n2023 9 13&#96;\n","slug":"前端框架开发【四】VUE开发基础语法（下）","date":"2023-09-13T02:56:20.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"0cc56414654ef1ffb71c6f53c491af99","title":"前端框架开发【三】VUE开发基础语法（上）","content":"\nReact与Vue的开发模式\nReact的开发模式：\n\nReact使用的jsx，所以对应的代码都是编写的类似于js的一种语法。\n\n之后通过Babel将jsx编译成 React.createElement 函数调用。\n\n\nVue也支持jsx的开发模式：\n\n但是大多数情况下，使用基于HTML的模板语法。\n\n在模板中，允许开发者以声明式的方式将DOM绑定到底层组件实例的数据。\n\n在底层的实现中，Vue将模板编译成虚拟DOM渲染函数。\n\n\n所以，对于学习Vue来说，学习模板语法是非常重要的。\n\n\n\n1. 模板语法1.1. 插值语法1.1.1. mustache 语法如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值：\nhtml&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;data返回的对象是有添加到Vue的响应式系统中，当data中的数据发生改变时，对应的内容也会发生更新。\nhtml&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;h2&gt;&#123;&#123; numberObj &#125;&#125;&lt;/h2&gt;\n        &lt;button @click=&quot;change&quot;&gt;BUTTON&lt;/button&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        const app = Vue.createApp(&#123;\n            data() &#123;\n                return &#123;\n                    numberObj: &#123;\n                        a: 1,\n                        b: 2,\n                    &#125;\n                &#125;\n            &#125;,\n            methods: &#123;\n                change() &#123;\n                    this.numberObj.a = 2\n                &#125;\n            &#125;\n        &#125;)\n\n        app.mount(&#39;#app&#39;);\n    &lt;/script&gt;\n&lt;/body&gt;当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式：\nhtml&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\n    &lt;template id=&quot;my-app&quot;&gt;\n      &lt;div&gt;\n        &lt;h2&gt;&#123;&#123; counter * 2&#125;&#125;&lt;/h2&gt;\n        &lt;h2&gt;&#123;&#123; counter + 1 &#125;&#125;&lt;/h2&gt;\n        &lt;h2&gt;&#123;&#123;message.split(\" \").reverse().join(\" \")&#125;&#125;&lt;/h2&gt;\n        &lt;h2&gt;&#123;&#123;reverse(message)&#125;&#125;&lt;/h2&gt;\n        &lt;h2&gt;&#123;&#123; a > b ? '1' : '2'&#125;&#125;&lt;/h2&gt;\n      &lt;/div&gt;\n    &lt;/template&gt;\n\n    &lt;script&gt;\n      const App = &#123;\n        template: &#39;#my-app&#39;,\n        data() &#123;\n          return &#123;\n            message: &quot;Welcome to vue&quot;,\n            counter: 10,\n            a: 1,\n            b: 2\n          &#125;\n        &#125;,\n        methods: &#123;\n          reverse(msg) &#123;\n            return msg.split(&quot; &quot;).reverse().join(&quot; &quot;)\n          &#125;\n        &#125;\n      &#125;\n\n      // 创建应用程序, 并且挂载\n      Vue.createApp(App).mount(&#39;#app&#39;);\n     &lt;/script&gt;\n&lt;/body&gt;但如下是错误的：\nhtml&lt;!-- 这是一个赋值语句, 不是表达式 --&gt;\n&lt;h2&gt;&#123;&#123;var name = \"Hello\"&#125;&#125;&lt;/h2&gt;\n&lt;!-- 控制流的if语句也是不支持的, 可以使用三元运算符 --&gt;\n&lt;h2&gt;&#123;&#123; if (true) &#123; return message &#125; &#125;&#125;&lt;/h2&gt;1.1.2. v-once用于指定元素或者组件只渲染一次：\n当数据发生变化时，元素或者组件以及其所有的自己诶单将视为静态内容并且跳过\n该指令可以用于性能优化\nhtml&lt;h2 v-once&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;  \n&lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;如果是子节点，也是只会渲染一次：\nhtml&lt;div v-once&gt;  \n  &lt;h2&gt;当前计数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;  \n  &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;  \n&lt;/div&gt;1.1.3. v-text用于更新元素的 textContent：\nhtml&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;  \n\n&lt;!-- 等价于 --&gt;  \n\n&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;1.1.4. v-html默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。\n如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示：\nhtml&lt;body&gt;  \n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;div v-html=&#39;info&#39;&gt;&lt;/div&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          info: `&lt;span style=&#39;color: red; font-size: 30px&#39;&gt;哈哈哈&lt;/span&gt;`  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  &lt;/script&gt;  \n&lt;/body&gt;1.1.5. v-prev-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签\n跳过不需要编译的节点，加快编译的速度\nhtml&lt;div v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;1.1.6. v-cloak这个指令保持在元素上直到关联组件实例结束编译。\n和 CSS 规则如 [v-cloak] &#123; display: none &#125; 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕。\ncss[v-cloak] &#123;  \n  display: none;  \n&#125;html&lt;div v-cloak&gt;  \n  &#123;&#123; message &#125;&#125;  \n&lt;/div&gt;&lt;div&gt; 不会显示，直到编译结束。\n1.1.7. v-bind元素除了内容之外还会有各种各样的属性。\n绑定属性我们使用v-bind：\n\n缩写：:\n\n预期：any (with argument) | Object (without argument)\n\n参数：attrOrProp (optional)\n\n修饰符：\n\n.camel - 将 kebab-case attribute 名转换为 camelCase。\n\n用法：动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。\n\n\n绑定基本属性Mustache等语法主要是将内容插入到 innerHTML 中。\n很多时候，元素的属性也是动态的：\n比如a元素的href属性、img元素的src属性\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  \n    &lt;img v-bind:src=&quot;src&quot; alt=&quot;&quot;&gt;  \n    &lt;!-- 语法糖写法 --&gt;  \n    &lt;img :src=&quot;src&quot; alt=&quot;&quot;&gt;  \n    &lt;!-- 注意这两种写法的不同 --&gt;  \n    &lt;img src=&quot;src&quot; alt=&quot;&quot;&gt;  \n  \n    &lt;!-- 绑定a元素 --&gt;  \n    &lt;a :href=&quot;href&quot;&gt;&lt;/a&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          message: &quot;Hello World&quot;,  \n          src: &quot;https://avatars.githubusercontent.com/u/10335230?v=4&quot;,  \n          href: &quot;http://www.baidu.com&quot;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;绑定class属性\n对象语法\n我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;!-- 1.普通的绑定方式 --&gt;  \n    &lt;div :class=&quot;className&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  \n    &lt;!-- 2.对象绑定 --&gt;  \n    &lt;!-- 动态切换class是否加入: &#123;类(变量): boolean(true/false)&#125; --&gt;  \n    &lt;div class=&quot;why&quot; :class=&quot;&#123;nba: true, &#39;james&#39;: true&#125;&quot;&gt;&lt;/div&gt;  \n    &lt;!-- 案例练习 --&gt;  \n    &lt;div :class=&quot;&#123;&#39;active&#39;: isActive&#125;&quot;&gt;哈哈哈&lt;/div&gt;  \n    &lt;button @click=&quot;toggle&quot;&gt;切换&lt;/button&gt;  \n    &lt;!-- 绑定对象 --&gt;  \n    &lt;div :class=&quot;classObj&quot;&gt;哈哈哈&lt;/div&gt;  \n    &lt;!-- 从methods中获取 --&gt;  \n    &lt;div :class=&quot;getClassObj()&quot;&gt;呵呵呵&lt;/div&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n  const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          message: &quot;Hello World&quot;,  \n          className: &quot;why&quot;,  \n          nba: &#39;kobe&#39;,  \n          isActive: false,  \n          classObj: &#123;  \n            why: true,  \n            kobe: true,  \n            james: false  \n          &#125;  \n        &#125;  \n      &#125;,  \n      methods: &#123;  \n        toggle() &#123;  \n          this.isActive = !this.isActive;  \n        &#125;,  \n        getClassObj() &#123;  \n          return &#123;  \n            why: true,  \n            kobe: true,  \n            james: false  \n          &#125;  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;\n\n\n\n数组语法\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;div :class=&quot;[&#39;why&#39;, nba]&quot;&gt;哈哈哈&lt;/div&gt;  \n    &lt;div :class=&quot;[&#39;why&#39;, nba, isActive? &#39;active&#39;: &#39;&#39;]&quot;&gt;呵呵呵&lt;/div&gt;  \n    &lt;div :class=&quot;[&#39;why&#39;, nba, &#123;&#39;actvie&#39;: isActive&#125;]&quot;&gt;嘻嘻嘻&lt;/div&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n  const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          message: &quot;Hello World&quot;,  \n          nba: &#39;kobe&#39;,  \n          isActive: true  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n   &lt;/script&gt;\n\n\n绑定style属性\n对象语法\n:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。\nCSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\n\n\n\n\n数组语法\n:style 的数组语法可以将多个样式对象应用到同一个元素上。\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;div :style=&quot;[styleObj1, styleObj2]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n  const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          message: &quot;Hello World&quot;,  \n          size: 50,  \n          styleObj1: &#123;  \n            color: &#39;red&#39;,   \n            fontSize: &#39;50px&#39;,   \n            &#39;background-color&#39;: &#39;blue&#39;  \n          &#125;,  \n          styleObj2: &#123;  \n            textDecoration: &#39;underline&#39;,  \n            fontWeight: 700  \n          &#125;   \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n   &lt;/script&gt;\n\n\n动态绑定属性\n属性的名称和值都是动态的\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;!-- 属性的名称是动态的 --&gt;  \n    &lt;div :[name]=&quot;value&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  \n  &lt;/template&gt;\n\n\n绑定一个对象\n对象会被拆解成各个小属性\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;div v-bind=&quot;info&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  \n  &lt;/template&gt;\n\n\n1.1.8. v-on前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。\n在前端开发中，我们需要经常和用户进行各种各样的交互：\n这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等\n在Vue中如何监听事件呢？\n使用v-on指令\n\nv-on 的使用\n\n缩写：@\n\n预期：Function | Inline Statement | Object\n\n参数：event\n\n修饰符：\n\n.stop - 调用 event.stopPropagation()。\n\n.prevent - 调用 event.preventDefault()。\n\n.capture - 添加事件侦听器时使用 capture 模式。\n\n.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n\n.&#123;keyAlias&#125; - 仅当事件是从特定键触发时才触发回调。\n\n.once - 只触发一次回调。\n\n.left - 只当点击鼠标左键时触发。\n\n.right - 只当点击鼠标右键时触发。\n\n.middle - 只当点击鼠标中键时触发。\n\n.passive - &#123; passive: true &#125; 模式添加侦听器\n\n\n\n用法：绑定事件监听\n\n\n\n\n\n案例演练\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;  \n    &lt;!-- 基本使用 --&gt;  \n    &lt;!-- 1.绑定函数 --&gt;  \n    &lt;button v-on:click=&quot;btnClick&quot;&gt;按钮1&lt;/button&gt;  \n    &lt;button @click=&quot;btnClick&quot;&gt;按钮2&lt;/button&gt;  \n    &lt;div v-on:mousemove=&quot;mouseMove&quot;&gt;div的区域&lt;/div&gt;  \n  \n    &lt;!-- 2.绑定对象 --&gt;  \n    &lt;button v-on=&quot;&#123;click: btnClick, mousemove: mouseMove&#125;&quot;&gt;特殊按钮3&lt;/button&gt;  \n  \n    &lt;!-- 3.内联语句 --&gt;  \n    &lt;!-- 默认会把event对象传入 --&gt;  \n    &lt;button @click=&quot;btn4Click&quot;&gt;按钮4&lt;/button&gt;  \n    &lt;!-- 内联语句传入其他属性 --&gt;  \n    &lt;button @click=&quot;btn4Click($event, &#39;why&#39;)&quot;&gt;按钮5&lt;/button&gt;  \n  \n    &lt;!-- 4.修饰符 --&gt;  \n    &lt;div @click=&quot;divClick&quot;&gt;  \n      &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮6&lt;/button&gt;  \n    &lt;/div&gt;  \n    &lt;input type=&quot;text&quot; @keyup.enter=&quot;onEnter&quot;&gt;  \n  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          message: &quot;Hello World&quot;  \n        &#125;  \n      &#125;,  \n      methods: &#123;  \n        btnClick() &#123;  \n          console.log(&quot;按钮被点击了&quot;);  \n        &#125;,  \n        btn4Click(event) &#123;  \n          console.log(event);  \n        &#125;,  \n        btn4Click(event, message) &#123;  \n          console.log(event, message);  \n        &#125;,  \n        mouseMove() &#123;  \n          console.log(&quot;鼠标移动&quot;);  \n        &#125;,  \n        divClick() &#123;  \n          console.log(&quot;divClick&quot;);  \n        &#125;,  \n        onEnter(event) &#123;  \n          console.log(event.target.value);  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;1.1.9. 条件渲染在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。\nVue提供了下面的指令来进行条件判断：\n\nv-if\n\nv-else\n\nv-else-if\n\nv-show\n\n\nv-if、v-else、v-else-ifv-if、v-else、v-else-if用于根据条件来渲染某一块的内容：\n\n这些内容只有在条件为true时，才会被渲染出来。\n\n这三个指令与JavaScript的条件语句if、else、else if类似。\n\n\nhtml&lt;!-- vue3中, template不再要求必须只有一个根元素 --&gt;  \n&lt;template id=&quot;my-app&quot;&gt;  \n  &lt;input type=&quot;text&quot; v-model.number=&quot;score&quot;&gt;  \n  &lt;h2 v-if=&quot;score &gt; 90&quot;&gt;优秀&lt;/h2&gt;  \n  &lt;h2 v-else-if=&quot;score &gt; 80&quot;&gt;良好&lt;/h2&gt;  \n  &lt;h2 v-else-if=&quot;score &gt; 60&quot;&gt;普通&lt;/h2&gt;  \n  &lt;h2 v-else&gt;不及格&lt;/h2&gt;  \n&lt;/template&gt;v-if的渲染原理：\n\nv-if是惰性的。\n\n当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉。\n\n当条件为true时，才会真正渲染条件块中的内容。\n\n\ntemplate 元素因为v-if是一个指令，所以必须将其添加到一个元素上：\n\n但是如果我们希望切换的是多个元素呢？\n\n此时我们渲染div，但是我们并不希望div这种元素被渲染；\n\n这个时候，我们可以选择使用template；\n\n\ntemplate元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来：\n有些类似于小程序中的 block\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;template v-if=&quot;showHa&quot;&gt;  \n      &lt;h2&gt;哈哈哈哈&lt;/h2&gt;  \n      &lt;h2&gt;哈哈哈哈&lt;/h2&gt;  \n      &lt;h2&gt;哈哈哈哈&lt;/h2&gt;  \n    &lt;/template&gt;  \n    &lt;template v-else&gt;  \n      &lt;h2&gt;呵呵呵呵&lt;/h2&gt;  \n      &lt;h2&gt;呵呵呵呵&lt;/h2&gt;  \n      &lt;h2&gt;呵呵呵呵&lt;/h2&gt;  \n    &lt;/template&gt;  \n    &lt;button @click=&quot;toggle&quot;&gt;切换&lt;/button&gt;  \n  &lt;/template&gt;v-showv-show和v-if的用法看起来是一致的：\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;h2 v-show=&quot;isShow&quot;&gt;哈哈哈哈&lt;/h2&gt;  \n  &lt;/template&gt;v-show 和 v-if 区别首先，在用法上的区别：\n\nv-show 是不支持 template。\n\nv-show 不可以和 v-else 一起使用。\n\n\n其次，本质的区别：\n\nv-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行切换。\n\nv-if当条件为false时，其对应的原生压根不会被渲染到DOM中。\n\n\n开发中如何进行选择呢？\n\n如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用v-show。\n\n如果不会频繁的发生切换，那么使用v-if。\n\n\n1.1.10. 列表渲染在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。\n\n这个时候我们可以使用v-for来完成。\n\nv-for类似于JavaScript的for循环，可以用于遍历一组数据。\n\n\nv-for 基本使用v-for 的基本格式是 &quot;item in 数组&quot;：\n\n数组通常是来自data或者prop，也可以是其他方式。\n\nitem是我们给每项元素起的一个别名，这个别名可以自定来定义。\n\n\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;h2&gt;电影列表&lt;/h2&gt;  \n    &lt;ul&gt;  \n      &lt;li v-for=&quot;item in movies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;  \n    &lt;/ul&gt;  \n  &lt;/template&gt;我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：\n\n如果我们需要索引，可以使用格式：&quot;(item, index) in 数组&quot;。\n\n注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的。\n\n\nv-for支持类型v-for也支持遍历对象，并且支持有一二三个参数：\n\n一个参数：&quot;value in object&quot;\n\n二个参数：&quot;(value, key) in object&quot;\n\n三个参数：&quot;(value, key, index) in object&quot;\n\n\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;h2&gt;遍历对象&lt;/h2&gt;  \n    &lt;ul&gt;  \n      &lt;li v-for=&quot;(value, key, index) in info&quot;&gt;  \n        &#123;&#123;index&#125;&#125; - &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125;  \n      &lt;/li&gt;  \n    &lt;/ul&gt;  \n  &lt;/template&gt;v-for同时也支持数字的遍历：\nhtml  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;h2&gt;遍历数字&lt;/h2&gt;  \n    &lt;ul&gt;  \n        &lt;li v-for=&quot;num in 5&quot; :key=&quot;num&quot;&gt;\n          &#123;&#123; num &#125;&#125;\n        &lt;/li&gt;\n    &lt;/ul&gt;  \n  &lt;/template&gt;template元素类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容：\n我们使用template来对多个元素进行包裹，而不是使用div来完成\nhtml  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n  \n  &lt;template id=&quot;my-app&quot;&gt;  \n    &lt;ul&gt;  \n      &lt;template v-for=&quot;(value, key) in info&quot;&gt;  \n        &lt;li&gt;&#123;&#123;key&#125;&#125;&lt;/li&gt;  \n        &lt;li&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt;  \n        &lt;hr&gt;  \n      &lt;/template&gt;  \n    &lt;/ul&gt;  \n  &lt;/template&gt;  \n  \n  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  \n  &lt;script&gt;    \n      const App = &#123;  \n          template: &#39;#my-app&#39;,  \n          data() &#123;  \n            return &#123;  \n              info: &#123;  \n                name: &#39;why&#39;,  \n                age: 18,  \n                height: 1.88  \n              &#125;  \n            &#125;  \n          &#125;  \n        &#125;  \n        Vue.createApp(App).mount(&#39;#app&#39;);  \n  &lt;/script&gt;数组更新检测Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\n\npush()\n\npop()\n\nshift()\n\nunshift()\n\nsplice()\n\nsort()\n\nreverse()\n\n\n上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、concat() 和 slice()。\njsconst nums = [10, 21, 34, 6];  \nconst newNums = nums.filter(num =&gt; num % 2 === 0);  \nconsole.log(newNums);1.1.11. key和diff算法认识 VNode 和 VDOM在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。\n这个key属性有什么作用呢？\n\n官方的解释\n\nkey属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。\n\n如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法。\n\n而使用key时，它会基于key的变化重新排列元素顺序，并且会移除&#x2F;销毁key不存在的元素。\n\n\n\n\n\n官方的解释对于初学者来说并不好理解，比如下面的问题：\n\n什么是新旧nodes，什么是VNode？\n\n没有key的时候，如何尝试修改和复用的？\n\n有key的时候，如何基于key重新排列的？\n\n\n我们先来解释一下VNode的概念：\n\n因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode。\n\nVNode的全称是Virtual Node，也就是虚拟节点。\n\n事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode。\n\nVNode的本质是一个JavaScript的对象。\n\n\n举个例子\nhtml&lt;div class=&quot;title&quot; style=&quot;font-size: 30px; color: red;&quot;&gt;哈哈哈&lt;/div&gt;这在Vue中会被转化创建出一个VNode对象：\njavascriptconst vnode = &#123;  \n  type: &#39;div&#39;,  \n  props: &#123;   \n    &#39;class&#39;: &#39;title&#39;,  \n    style: &#123;  \n      &#39;font-size&#39;: &#39;30px&#39;,  \n      color: &#39;red&#39;  \n    &#125;  \n  &#125;,  \n  children: &#39;哈哈哈&#39;  \n&#125;Vue内部在拿到VNode对象后，会对VNode进行处理，渲染成真实的DOM。\n\n如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个VNode Tree：\nhtml&lt;div&gt;  \n  &lt;p&gt;  \n    &lt;i&gt;哈哈哈哈&lt;/i&gt;  \n    &lt;i&gt;哈哈哈哈&lt;/i&gt;  \n  &lt;/p&gt;  \n  &lt;span&gt;嘻嘻嘻嘻&lt;/span&gt;  \n  &lt;strong&gt;呵呵呵呵&lt;/strong&gt;  \n&lt;/div&gt;\n这个和我们的key有什么关系呢？\nkey 作用和 diff 算法我们先来看一个例子：\n这个例子是当我点击按钮时会在中间插入一个 f\nhtml&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;  \n\n&lt;template id=&quot;my-app&quot;&gt;  \n&lt;ul&gt;  \n  &lt;li v-for=&quot;item in letters&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;  \n&lt;/ul&gt;  \n&lt;button @click=&quot;insertF&quot;&gt;insert f&lt;/button&gt;  \n&lt;/template&gt;  \n\n&lt;script&gt;    \n  const App = &#123;  \n      template: &#39;#my-app&#39;,  \n      data() &#123;  \n        return &#123;  \n          letters: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]  \n        &#125;  \n      &#125;,  \n      methods: &#123;  \n        insertF() &#123;  \n          this.letters.splice(2, 0, &#39;f&#39;);  \n        &#125;  \n      &#125;  \n    &#125;  \n  \n    Vue.createApp(App).mount(&#39;#app&#39;);  \n&lt;/script&gt;我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们li的列表：\n\n在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列表。\n\n因为对于列表中 a、b、c、d它们都是没有变化的。\n\n在操作真实DOM的时候，我们只需要在中间插入一个f的li即可。\n\n\n那么Vue中对于列表的更新究竟是如何操作的呢？\n\nVue事实上会对于有key和没有key会调用两个不同的方法。\n\n有key，那么就使用 patchKeyedChildren方法。\n\n没有key，那么就使用 patchUnkeyedChildren方法。\n\n\n\n没有 key 执行操作没有key对应的源代码如下：\n\n它的过程画图就是如下的操作：\n\n我们会发现上面的diff算法效率并不高：\n\nc和d来说它们事实上并不需要有任何的改动。\n\n但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增。\n\n\n有 key 执行操作如果有key，那么会执行什么样的操作呢？\n\n第一步的操作是从头开始进行遍历、比较：\n\na和b是一致的会继续进行比较\n\nc和f因为key不一致，所以就会break跳出循环\n\n\n\n第二步的操作是从尾部开始进行遍历、比较：\n\n第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：\n\n第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：\n\n第五步是最特色的情况，中间还有很多未知的或者乱序的节点：\n\n所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作：\n\n在没有key的时候我们的效率是非常低效的。\n\n在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效。\n\n\n2. methods中的this不能使用箭头函数我们在methods中要使用data返回对象中的数据，那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。\n那么我们这个this能不能是window呢？\n\n不可以是window，因为window中我们无法获取到data返回对象中的数据；\n\n但是如果我们使用箭头函数，那么这个this就会是window了；\n\n\n我们来看下面的代码：\n\n我将increment换成了箭头函数，那么它其中的this进行打印时就是window；\n\njsconst App = &#123;  \n  template: &quot;#my-app&quot;,  \n  data() &#123;  \n    return &#123;  \n      counter: 0  \n    &#125;  \n  &#125;,  \n  methods: &#123;  \n    increment: () =&gt; &#123;  \n      // this.counter++;  \n      console.log(this);  \n    &#125;,  \n    decrement() &#123;  \n      this.counter--;  \n    &#125;  \n  &#125;  \n&#125;为什么是window呢？\n\n这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用域中来查找this；\n\n最终刚好找到的是script作用域中的this，所以就是window；\n\n\nthis到底是如何查找和绑定的呢？\n\nhttps://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA；\n\n认真学习之后你绝对对this的绑定一清二楚；\n\n\nthis到底指向什么事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过bind绑定了this：\n\n\n结语学如逆水行舟，不进则退\n2023 9 12&#96;\n","slug":"前端框架开发【三】VUE开发基础语法（上）","date":"2023-09-12T02:56:04.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"3518b8ecf99ea2129ef5e3325fd10d77","title":"前端框架开发【二】邂逅Vue3开发","content":"1. 认识Vue.js1.1. 认识VueVue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。\n什么是渐进式框架呢？\n表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个项目### 1.2. Vue的安装\nVue是一个JavaScript的库，刚开始我们不需要把它想象的非常复杂，我们就把它理解成一个已经帮助我们封装好的库，在项目中可以引入并且使用它即可。\n那么安装和使用Vue这个JavaScript库有哪些方式呢？\n\n方式一：在页面中通过CDN的方式来引入；\n\n方式二：下载Vue的JavaScript文件，并且自己手动引入；\n\n方式三：通过npm包管理工具安装使用它（webpack再讲）；\n\n方式四：直接通过Vue CLI创建项目，并且使用它；\n\n\n1.2. Vue的安装Vue是一个JavaScript的库，刚开始我们不需要把它想象的非常复杂，我们就把它理解成一个已经帮助我们封装好的库，在项目中可以引入并且使用它即可。\n那么安装和使用Vue这个JavaScript库有哪些方式呢？\n\n方式一：在页面中通过CDN的方式来引入；\n\n方式二：下载Vue的JavaScript文件，并且自己手动引入；\n\n方式三：通过npm包管理工具安装使用它（结合webpack）；\n\n方式四：直接通过Vue CLI创建项目，并且使用它；\n\n\n1.2.1. CDN方式引入什么是CDN呢？\nCDN称之为内容分发网络（Content Delivery Network或Content Distribution Network，缩写：CDN）\n\n它是指通过相互连接的网络系统，利用最靠近每个用户的服务器；\n\n更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户；\n\n来提供高性能、可扩展性及低成本的网络内容传递给用户；\n\n\n\n常用的CDN服务器可以大致分为两种：\n\n自己的CDN服务器：需要购买自己的CDN服务器，目前阿里、腾讯、亚马逊、Google等都可以购买CDN服务器；\n\n开源的CDN服务器：国际上使用比较多的是unpkg、JSDelivr、cdnjs；\n\n\nVue 的 CDN 引入\n注意：后期咱们所有的代码的 CDN 引入的都是 Vue 3，Vue 3 是支持 Vue 2 的 ，有一点不同就是 Vue 3 中不再支持 Vue 2 的挂载方式了。在 Vue 3 中，需要使用 createApp 方法来创建 Vue 实例，并使用 mount 方法将其挂载到指定的元素上\n\nVue 2\njs&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;Vue 3\nbash&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;1.2.2. 两种不同的挂载方式\nVue 2 的挂载方式\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Vue 2 挂载方式示例&lt;/title&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                message: &#39;Hello, Vue 2!&#39;\n            &#125;\n        &#125;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nVue 3 的挂载方式\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Vue 3 挂载方式示例&lt;/title&gt;\n    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        const app = Vue.createApp(&#123;\n            data() &#123;\n                return &#123;\n                    message: &#39;Hello, Vue 3!&#39;\n                &#125;\n            &#125;\n        &#125;);\n\n        app.mount(&#39;#app&#39;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;2. 声明式和命令式的区分2.1 命令式每完成一个操作，都需要通过JavaScript编写一条代码，来给浏览器一个指令，这样的编写代码的过程，我们称之为命令式编程：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;计数器&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;h2 id=&quot;counter&quot;&gt;&lt;/h2&gt;\n        &lt;button id=&quot;addBtn&quot;&gt;+1&lt;/button&gt;\n        &lt;button id=&quot;decBtn&quot;&gt;-1&lt;/button&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        const counterElement = document.getElementById(&#39;counter&#39;)\n        const addBtn = document.getElementById(&#39;addBtn&#39;)\n        const decBtn = document.getElementById(&#39;decBtn&#39;)\n\n        let counter = 0\n\n        const updateCounter = () =&gt; &#123;\n            counterElement.textContent = counter\n        &#125;\n\n        const add = () =&gt; &#123;\n            counter++\n            updateCounter()\n        &#125;\n\n        const dec = () =&gt; &#123;\n            counter--\n            updateCounter()\n        &#125;\n\n        addBtn.addEventListener(&#39;click&#39;, add)\n        decBtn.addEventListener(&#39;click&#39;, dec)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;2.2 声明式在createApp传入的对象中声明需要的内容，模板template、数据data、方法methods，这样的编写代码的过程，我们称之为是声明式编程。\n声明式之 Options API\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;计数器&lt;/title&gt;\n    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n      const App = &#123;\n        template: `\n          &lt;div&gt;\n            &lt;h2&gt;&#123;&#123;counter&#125;&#125;&lt;/h2&gt;\n            &lt;button @click=&#39;add&#39;&gt;+1&lt;/button&gt;\n            &lt;button @click=&#39;dec&#39;&gt;-1&lt;/button&gt;\n          &lt;/div&gt;\n        `,\n        data() &#123;\n          return &#123;\n            counter: 0\n          &#125;\n        &#125;,\n        methods: &#123;\n          add() &#123;\n            this.counter++\n          &#125;,\n          dec() &#123;\n            this.counter--\n          &#125;\n        &#125;\n      &#125;\n\n      Vue.createApp(App).mount(&#39;#app&#39;)\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;声明式之 Composable API\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;计数器&lt;/title&gt;\n    &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n      const App = &#123;\n        template: `\n          &lt;div&gt;\n            &lt;h2&gt;&#123;&#123; counter &#125;&#125;&lt;/h2&gt;\n            &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt;\n            &lt;button @click=&quot;dec&quot;&gt;-1&lt;/button&gt;\n          &lt;/div&gt;\n        `,\n        setup() &#123;\n          const counter = Vue.ref(0);\n\n          const add = () =&gt; &#123;\n            counter.value++;\n          &#125;\n\n          const dec = () =&gt; &#123;\n            counter.value--;\n          &#125;\n\n          return &#123;\n            counter,\n            add,\n            dec\n          &#125;\n        &#125;\n      &#125;\n\n      Vue.createApp(App).mount(&#39;#app&#39;)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;3. MVVM 开发模式通常情况下，我们也经常称Vue是一个MVVM的框架。\n什么是MVVM吗？\nMVVM是一种软件的体系结构，是Model-View-ViewModel的简称；\n\nVue官方其实有说明，Vue虽然并没有完全遵守MVVM的模型，但是整个设计是受到它的启发的。\n\n4. createApp 对象参数在使用createApp的时候，我们传入了一个对象，接下来我们详细解析一其中的一部分传入的属性。\n4.1 template属性template表示的是Vue需要帮助我们渲染的模板信息：\n目前我们看到它里面有很多的HTML标签，这些标签会替换掉我们挂载到的元素（比如id为app的div）的innerHTML。\n但是这个模板的写法有点过于 别扭 了，并且IDE很有可能没有任何提示，阻碍我们开发的效率。\n\n因此，Vue提供了两种方式\n方式一：\n使用script标签，并且标记它的类型为 x-template。\nhtml &lt;body&gt;\n     &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n     &lt;script type=&quot;x-template&quot; id=&quot;my-app&quot;&gt;    \n        &lt;div&gt;  \n          &lt;h2&gt;&#123;&#123;counter&#125;&#125;&lt;/h2&gt;  \n          &lt;button @click=&#39;increment&#39;&gt;+1&lt;/button&gt;  \n          &lt;button @click=&#39;decrement&#39;&gt;-1&lt;/button&gt;  \n        &lt;/div&gt;\n     &lt;/script&gt;\n     &lt;script&gt;\n         const APP = &#123;\n             data() &#123;\n                 return &#123;\n                     counter: 10\n                 &#125;\n             &#125;,\n             methods: &#123;\n                 increment() &#123;\n                     this.counter++\n                 &#125;,\n                 decrement() &#123;\n                     this.counter--\n                 &#125;\n             &#125;\n         &#125;\n        Vue.createApp(APP).mount(&#39;#app&#39;)\n     &lt;/script&gt;\n &lt;/body&gt;方式二：使用任意标签\n通常使用template标签，因为不会被浏览器渲染，并为其设置id。\n\ntemplate元素是一种用于保存客户端内容的机制，该内容在加载页面时不会被呈现，但随后可以在运行时使用JavaScript实例化。\n\nhtml&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;template id=&quot;my-app&quot;&gt;\n      &lt;div&gt;\n        &lt;h2&gt;&#123;&#123; counter&#125;&#125;&lt;/h2&gt;\n      &lt;/div&gt;\n    &lt;/template&gt;\n\n    &lt;script&gt;\n      const App = &#123;\n        template: &#39;#my-app&#39;,\n        data() &#123;\n          return &#123;\n            counter: 10,\n          &#125;\n        &#125;\n      &#125;\n      // 创建应用程序, 并且挂载\n      Vue.createApp(App).mount(&#39;#app&#39;);\n    &lt;/script&gt;\n&lt;/body&gt;在createApp的对象中\n\n我们需要传入的template属性值要以 # 开头\n如果tempalte属性的值是以 # 开始，那么它将被用作 querySelector，并且使用匹配元素的 innerHTML 作为模板字符串。\n\n\n\n4.2 data 属性data 属性是传入一个函数，并且该函数需要返回一个对象：\n\n在Vue2.x的时候，也可以传入一个对象（虽然官方推荐是一个函数）\n\n在Vue3.x的时候，比如传入一个函数，否则就会直接在浏览器中报错\n\n\ndata 中返回的对象会被 Vue 的响应式系统劫持，之后对该对象的修改或者访问都会在劫持中被处理：\n\n所以我们在 template 中通过 &#123;&#123;counter&#125;&#125; 访问 counter，可以从对象中获取到数据\n\n所以我们修改 counter 的值时，template 中的  &#123;&#123;counter&#125;&#125; 也会发生改变\n\n\n4.3 methods 属性methods属性是一个对象，通常我们会在这个对象中定义很多的方法：\n\n这些方法可以被绑定到 template 模板中。\n\n在该方法中，我们可以使用this关键字来直接访问到data中返回的对象的属性。\n\n\n\n4.4 其它属性\n这里还可以定义很多其他的属性\nVue2\n\nel: 指定 Vue 实例挂载的元素，可以是 CSS 选择器字符串或 DOM 元素。\ndata: Vue 实例的初始数据对象。\nprops: 组件的属性列表，用于接收父组件传递的数据。\ncomputed: 计算属性对象，用于定义基于响应式数据计算的属性。\nmethods: 方法对象，用于定义 Vue 实例的方法。\nwatch: 监听属性对象，用于监听数据的变化。\ntemplate: Vue 实例的模板字符串。\nrender: 渲染函数，用于生成 Vue 实例的虚拟 DOM。\ncomponents: 组件对象，用于注册局部组件。\ndirectives: 指令对象，用于注册局部指令。\nfilters: 过滤器对象，用于注册局部过滤器。\nbeforeCreate: Vue 实例创建之前调用的钩子函数。\ncreated: Vue 实例创建完成后调用的钩子函数。\nbeforeMount: Vue 实例挂载到 DOM 之前调用的钩子函数。\nmounted: Vue 实例挂载到 DOM 后调用的钩子函数。\nbeforeUpdate: Vue 实例更新之前调用的钩子函数。\nupdated: Vue 实例更新完成后调用的钩子函数。\nbeforeDestroy: Vue 实例销毁之前调用的钩子函数。\ndestroyed: Vue 实例销毁完成后调用的钩子函数。\n\nVue3\n\ndata: Vue 实例的初始数据对象。\nprops: 组件的属性列表，用于接收父组件传递的数据。\ncomputed: 计算属性对象，用于定义基于响应式数据计算的属性。\nmethods: 方法对象，用于定义 Vue 实例的方法。\nwatch: 监听属性对象，用于监听数据的变化。\ntemplate: Vue 实例的模板字符串。\nrender: 渲染函数，用于生成 Vue 实例的虚拟 DOM。\ncomponents: 组件对象，用于注册局部组件。\ndirectives: 指令对象，用于注册局部指令。\nbeforeCreate: Vue 实例创建之前调用的钩子函数。\ncreated: Vue 实例创建完成后调用的钩子函数。\nbeforeMount: Vue 实例挂载到 DOM 之前调用的钩子函数。\nmounted: Vue 实例挂载到 DOM 后调用的钩子函数。\nbeforeUpdate: Vue 实例更新之前调用的钩子函数。\nupdated: Vue 实例更新完成后调用的钩子函数。\nbeforeUnmount: Vue 实例卸载之前调用的钩子函数。\nunmounted: Vue 实例卸载完成后调用的钩子函数。\n\n\n\n\n\n结语学如逆水行舟，不进则退\n2023 09 11\n","slug":"前端框架开发【二】邂逅Vue3开发","date":"2023-09-11T02:55:49.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"855e657882f14bd8507dfda3eeaac0bb","title":"前端框架开发【一】邂逅Vue3和TypeScript","content":"1. 为什么要学习 Vue？1.1. 三个框架的对比当你学习到这里的，我就默认你已经知道了前端现在流行的三大框架：Vue、React、Angular\n\nAngular：入门门槛相对会比较高，所以在国内无论是开发者还是使用的公司都是较少的，当然它本身是一个非常优秀的框架。\n\nReact：在国内外市场占有率都非常高（尤其在国外，待会儿我们会看到数据对比），也是前端开发者必须要掌握的一个框架。\n\nVue：在国内的市场占有率是最高的，是国内前端开发者必须要学习的一个框架，几乎所有的前端岗位都对Vue有要求。\n\n\n\n1.2. 框架的数据对比Google指数\n我们通过Google指数（中国）可以看出：使用Vue的人数依然是最高的，其次是React，Angular人数是最少的。\n当然国内的程序员使用的Google是较少数的，更多使用的是百度，所以我们再来看一下百度指数。\n\n百度指数\n从百度指数我们可以看出：Vue是遥遥领先的，其次是React，再次是Angular。\n当然这些指数只能反映开发者搜索这些关键字的频率，从侧面反映对应框架的热门程度。\n\nnpm下载量\n如果我们从npm下载量来观察，会发现React是遥遥领先的：\n\n这是因为npm下载量反映的是全球框架的使用频率。\n\n我们刚才有提到，React事实上在国外是更加的流行，所以React从世界的角度来看，下载量也是最高的。\n\n\n\nGitHub Star\n如果我们来看GitHub上的Star：Vue的star是排第一的，当然这也是和国内使用Vue的人数非常多有关系，React排在第二，Angular排在第三。\n1.3. 谁是最好的前端框架？那么在对比完之后，三个框架中到底谁才是最好的框架呢？\n\n当然，这个问题很难有一个结论，我也不会给出结论；\n\n因为这是一个仁者见仁智者见智的问题，也在很多地方会被争论不休；\n\n就像很多人喜欢争论谁才是世界上最好的语言一样；\n\n另外，争论这个话题是没有意义的，争论不休的话题；\n\n\n但是，我们可以从现实的角度分析一下一些问题，比如：学习哪一门语言更容易找到工作？\n\n找后端的工作：优先推荐Java、其次推荐Go、再次推荐Node（JavaScript），可能不推荐PHP、C#；\n\n目前在国内后端开发必然是首推Java的，所以也有很多的大公司慢慢将技术栈转向了Go；\n\n而类似于PHP、C#已经在慢慢的退出历史舞台；\n\n找前端的工作：优先推荐JavaScript（TypeScript）、其次Flutter、再次Android（Java、Kotlin）、iOS（OC、Swift）；\n\n如果找前端工作，必须要学好JavaScript，其次是一些矿平台的方案；\n\n而原生的Android和iOS开发的市场确确实实在慢慢的变小；\n\n也有很多的其他方向：游戏开发、人工智能、算法工程师等等；\n\n\n那么，就前端来说，学习了HTML、CSS、JavaScript，哪一个框架更容易找到工作？\n\n如果去国外找工作，优先推荐React、其次是Vue和Angular，不推荐jQuery了；\n\n如果在国内找工作，优先推荐、必须学习Vue，其次是React，其次是Angular，不推荐jQuery了；\n\n\n2. 是时候学习 Vue3 了吗？在2020年的9月19日，万众期待的Vue3终于发布了正式版，命名为One Piece。\n\n它也带来了很多新的特性：更好的性能、更小的包体积、更好的TypeScript集成、更优秀的API设计。\n\n2.1. Vue3的新变化更现代化的源码管理方式\nVue3对项目管理的管理进行了重大的重构，采用了monorepo的方式来进行管理：\n\nmono是单个的意思，repo是repository仓库的简写。\n\n主要的含义是将许多项目的代码存储在同一个repository中。\n\n\n我们来看下面的图片，对比vue2和vue3源码的不同管理方式：\n\nVue2.x是将所有的源代码编写到了src的目录下，并且依照不同的功能划分成了多个文件夹，比如compiler是和模板编译相关的，core是通用的核心运行时代码等。\n\nVue3.x是将不同的模块拆分到不同packages下的子目录中，并且每一个模块都可以看成是一个独立的项目。\n\n这个独立的项目可以有自己的类型定义、自己的API、自己的测试用例。\n\n这样每一个模块的划分更加清晰，开发者更容易阅读、理解、修改模块的代码，也提供了代码的可维护性、可扩展性。\n\n并且每一个模块可以单独的进行编译，而无需从大量的src代码中抽离出一部分代码。\n\n\n\n目前很多的开源项目都是采用monorepo的方式来开发的：\n\n比如Vue3、React、Babel、Element-Plus等等。\n\n当然也有很多的框架并不是，比如webpack。\n\n\n代码使用TypeScript进行了重构\n待会儿我们也会讲到为什么需要使用TypeScript，但是我先知道一下Vue3已经全部使用TypeScript对源代码进行重写。\n\n在Vue2.x的时候，它是使用Flow来进行类型的检测，但是Flow有很多的复杂场景是类型的支持并不是非常友好。\n\n所以在Vue3.x开始，整个项目全部使用了TypeScript进行重构，并且Vue3.x本身对TypeScript的支持也变得更加友好了。\n\n\n使用Proxy进行数据劫持\n在Vue2.x的时候，Vue是使用Object.defineProperty来劫持数据的getter和setter方法的。\n\n这种方式一直存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的。\n\n所以在Vue2.x的时候，不得不提供一些特殊的API，比如set或delete，事实上都是一些hack方法，也增加了开发者学习新的API的成本。\n\n\n而在Vue3.x开始，Vue使用Proxy来实现数据的劫持。\n编译阶段的优化\nVue3在编译阶段进行了很多的优化：\n\n生成Block Tree：在编译阶段对静态模板进行分析，生成Block Tree（具体是干嘛的，后面讲原理再讲）。\n\nslot编译优化：Vue3优化了slot的生成，对于非动态slot中属性的更新只会触发子组件的更新。\n\ndiff算法优化：Vue3相对于vue2在diff算法上也进行了优化（后续会讲解）。\n\n\ncomposition api\n由Options API 到 Composition API（了解，后续课程会讲解）：\n在Vue2.x的时候，我们会通过Options API来描述组件对象。\nOptions API包括data、props、methods、computed、生命周期等等这些选项。\n存在比较大的问题是多个逻辑可能是在不同的地方：\n\n比如created中会使用某一个method来修改data的数据，代码的内聚性非常差。\n\nComposition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找。\n\n\nHooks函数增加代码的复用性：\n在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑。\n但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题。\n在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的。\n移除一些非必要的api\nVue3移除了实例上的 off 和 $once。\nVue3移除了一些特性：如filter、内联模板等。\n\n当然有对应的替代的方案。\n\n2.2. 现在开始学习Vue3吗？是时候学习Vue3了吗？\n在vue3刚刚发布时，很多人也是跃跃欲试，想要尝试vue3的各种新特性。\n但是事实上在刚刚发布的时候我们使用vue3来写demo练习是没有问题的，真正在实际业务项目中使用vue3还需要一个相对的过程；\n包括vue3的进一步稳定、包括社区更多vue3相关的插件、组件库的支持和完善；\n那么现在是否是学习vue3的时间呢？\n答案是肯定的\n首先vue3在经过一系列的更新和维护后，已经是趋于稳定，并且在之前尤雨溪也宣布在今年（2021年）第二季度会将vue3作为Vue CLI的默认版本了。\n目前社区也经过一定时间的沉淀，更加的完善了，包括AntDesignVue、Element-Plus都提供了对Vue3的支持，所以很多公司目前新的项目都已经在使用Vue3来进行开发了。\n并且在面试的时候，几乎都会问到各种各样Vue3、Vite工具相关的问题。\n3. 为什么学习 TypeScript？TypeScript类型检测\n我们已经简单体会到没有类型检查带来的一些问题，JavaScript因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失：\n\n前端开发人员通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证；\n\n从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮；\n\n\n所以我们经常会说JavaScript不适合开发大型项目，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患，多人员开发往往也增加很大的沟通成本。\n\n比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性；\n\n比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型。\n\n\n为了弥补JavaScript类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：\n\n2014年，Facebook推出了flow来对JavaScript进行类型检查；\n\n同年，Microsoft微软也推出了TypeScript1.0版本；\n\n他们都致力于为JavaScript提供类型检查；\n\n\n而在所有的方案中，无疑TypeScript是最优秀的，也是目前使用最广泛的：\n\nVue3.x已经全线转向TypeScript，几乎所有的代码都使用TypeScript进行了重构；\n\n而Angular在很早期就使用TypeScript进行了项目重构，并且项目也需要使用TypeScript来进行开发；\n\n包括React使用最多的组件库Ant Design也是全面使用的TypeScript；\n\n目前很多的公司项目都是使用Vue+TypeScript、React+TypeScript、Angular+TypeScript；\n\n包括最新的Vue3中也提供了更好的对TypeScript的支持；\n\n\n所以对于前端工程师来说，TypeScript也是必须要掌握的技能。\n\n结语学如逆水行舟，不进则退\n2023 09 10\n","slug":"前端框架开发【一】邂逅Vue3和TypeScript","date":"2023-09-10T02:55:21.000Z","categories_index":"VUE","tags_index":"VUE 入门","author_index":"一小池勺"},{"id":"efa903f91a28565d8dca46166c5eaa96","title":"TypeScript【四】接口interface使用详解","content":"前言接口是TypeScript中一个非常重要的概念，在其他很多语言中已经有了并且被大量使用。\n1. 为什么要使用接口1.1. JavaScript存在的问题我们在JavaScript中定义一个函数，用于获取一个用户的姓名和年龄的字符串：\njavascriptconst getUserInfo = function(user) &#123;\n    return `name: $&#123;user.name&#125;`, aage: $&#123;user.age&#125;`\n&#125;正确的调用方法应该是下面的方式：\njavascriptgetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;)但是当项目比较大，或者多人开发时，会出现错误的调用方法：\njavascript// 错误的调用  \ngetUserInfo() // Uncaught TypeError: Cannot read property &#39;name&#39; of undefined  \nconsole.log(getUserInfo(&#123;name: &quot;coderwhy&quot;&#125;)) // name: coderwhy, age: undefined  \ngetUserInfo(&#123;name: &quot;codewhy&quot;, height: 1.88&#125;) // name: coderwhy, age: undefined因为 JavaScript 是弱类型的语言，所以并不会对我们传入的代码进行任何的检测，但是在之前的 JavaScript 中确确实实会存在很多类似的安全隐患。\n如何避免这样的问题呢？\n当然是使用 TypeScript 来对代码进行重构\n1.2. TypeScript代码重构（一）我们可以使用TypeScript来对上面的代码进行改进：\ntypescriptconst getUserInfo = (user: &#123;name: string, age: number&#125;): string =&gt; &#123;\n    return `name: $&#123;user.name&#125; age: $&#123;user.age&#125;`;\n&#125;;正确的调用是如下的方式：\ntypescriptgetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;);如果调用者出现了错误的调用，那么TypeScript 会直接给出错误的提示信息：\ntypescript// 错误的调用  \ngetUserInfo(); // 错误信息：An argument for &#39;user&#39; was not provided.  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;&#125;); // 错误信息：Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;, height: 1.88&#125;); // 错误信息：类型不匹配这样确实可以防止出现错误的调用，但是我们在定义函数的时候，参数的类型和函数的类型都是非常长的，代码非常不便于阅读。\n所以，我们可以使用接口来对代码再次进行重构。\n1.3. TypeScript 代码重构（二）接口重构一：参数类型使用接口定义\n我们先定义一个IUser接口：\ntypescript// 先定义一个接口  \ninterface IUser &#123;  \n    name: string;  \n    age: number;  \n&#125;接下来我们看一下函数如何来写：\ntypescriptconst getUserInfo = (user: IUser): string =&gt; &#123;  \n    return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;  \n&#125;;  \n  \n// 正确的调用  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;);  \n  \n// 错误的调用，其他也是一样  \ngetUserInfo();接口重构二：函数的类型使用接口定义（后面会详细讲解接口函数的定义）\n我们先定义两个接口：\n\n第二个接口定义有一个警告，我们暂时忽略它，它的目的是如果一个函数接口只有一个方法，那么可以使用type来定义  type IUserInfoFunc &#x3D; (user: IUser) &#x3D;&gt; string;\n\ntypescriptinterface IUser &#123;\n    name: string;\n    age: number;\n&#125;\n\ninterface IUserInfoFunc &#123;\n    (user: IUser): string;\n&#125;接着我们去定义函数和调用函数即可：\ntypescriptconst getUserInfo: IUserInfoFunc = (user) =&gt; &#123;  \n    return`name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;  \n&#125;;  \n  \n// 正确的调用  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;);  \n  \n// 错误的调用  \ngetUserInfo();2. 接口的基本使用2.1. 接口的定义方式和其他很多的语言类似，TypeScript 中定义接口也是使用 interface 关键字来定义：\ntypescriptinterface IPerson &#123;  \n    name: string;  \n&#125;你会发现我都在接口的前面加了一个 I，这是 tslint 要求的，否则会报一个警告\n\n要不要加前缀是根据公司规范和个人习惯\n\nbashinterface name must start with a capitalized I当然我们可以在 tslint 中关闭掉它：在 rules 中添加如下规则\njavascript&quot;interface-name&quot; : [true, &quot;never-prefix&quot;]2.2. 接口中定义方法定义接口中不仅仅可以有属性，也可以有方法：\ntypescriptinterface Person &#123;  \n    name: string;  \n    run(): void;  \n    eat(): void;\n&#125;如果我们有一个对象是该接口类型，那么必须包含对应的属性和方法：\ntypescriptconst p: Person = &#123;  \n    name: &quot;why&quot;,  \n    run() &#123;    \n    console.log(&quot;running&quot;);  \n    &#125;,  \n    eat() &#123;    \n    console.log(&quot;eating&quot;);  \n    &#125;\n&#125;;2.3. 可选属性的定义默认情况下一个变量（对象）是对应的接口类型，那么这个变量（对象）必须实现接口中所有的属性和方法。\n但是，开发中为了让接口更加的灵活，某些属性我们可能希望设计成可选的（想实现可以实现，不想实现也没有关系），这个时候就可以使用可选属性。\ntypescriptinterface Person &#123;  \n    name: string;  \n    age?: number;  \n    run(): void;  \n    eat(): void;  \n    study?(): void;\n&#125;上面的代码中，我们增加了 age 属性和 study 方法，这两个都是可选的：\n\n可选属性如果没有赋值，那么获取到的值是undefined；\n\n对于可选方法，必须先进行判断，再调用，否则会报错；\n\n\ntypescriptconst p: Person = &#123;  \n    name: &quot;why&quot;,  \n    run() &#123;  \n    console.log(&quot;running&quot;);  \n    &#125;,  \n    eat() &#123;  \n    console.log(&quot;eating&quot;);  \n    &#125;\n&#125;;  \n  \nconsole.log(p.age); // undefined  \np.study(); // 不能调用可能是“未定义”的对象。正确的调用方式如下：\ntypescriptif (p.study) &#123;  \n    p.study();\n&#125;2.4. 只读属性的定义默认情况下，接口中定义的属性可读可写：\ntypescriptconsole.log(p.name);  \np.name = &quot;流川枫&quot;;如果一个属性，我们只是希望在定义的时候就定义值，之后不可以修改，那么可以在属性的前面加上一个关键字：readonly\ntypescriptinterface Person &#123;  \n    readonly name: string;  \n    age?: number;  \n    run(): void;  \n    eat(): void;  \n    study?(): void;  \n&#125;当我在name前面加上readonly时，赋值语句就会报错：\ntypescriptconsole.log(p.name);p.name = &quot;流川枫&quot;; // Cannot assign to &#39;name&#39; because it is a read-only property.3. 接口的高级使用3.1. 函数类型的定义接口不仅仅可以定义普通的对象类型，也可以定义函数的类型\ntypescript// 函数类型的定义\ninterface SumFunc &#123;  \n    (num1: number, num2: number): number;  \n&#125;  \n  \n// 定义具体的函数  \nconst sum: SumFunc = (num1, num2) =&gt; &#123;  \n    return num1 + num2;  \n&#125;;  \n  \n// 调用函数  \nconsole.log(sum(20, 30));不过上面的接口中只有一个函数，TypeScript 会给我们一个建议，可以使用type来定义一个函数的类型：\ntypescripttype SumFunc = (num1: number, num2: number) =&gt; number;3.2. 可索引类型的定义和使用接口描述函数的类型差不多，我们也可以使用接口来描述 可索引类型\n\n比如一个变量可以这样访问：a[3]，a[&quot;name&quot;]\n\n可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。\ntypescript// 定义可索引类型的接口  \ninterface RoleMap &#123;  \n    [index: number]: string;  \n&#125;  \n  \n// 赋值具体的值  \n// 赋值方式一：  \nconst roleMap1: RoleMap = &#123;  \n    0: &quot;学生&quot;,  \n    1: &quot;讲师&quot;,  \n    2: &quot;班主任&quot;,  \n&#125;;  \n  \n// 赋值方式二：因为数组本身是可索引的值  \nconst roleMap2 = [&quot;鲁班七号&quot;, &quot;露娜&quot;, &quot;李白&quot;];  \n  \n// 取出对应的值  \nconsole.log(roleMap1[0]); // 学生  \nconsole.log(roleMap2[1]); // 露娜上面的案例中，我们的索引签名是数字类型， TypeScript支持两种索引签名：字符串和数字。\n我们来定义一个字符串的索引类型：\ntypescriptinterface RoleMap &#123;  \n    [name: string]: string;  \n&#125;  \n  \nconst roleMap: RoleMap = &#123;  \n    aaa: &quot;鲁班七号&quot;,  \n    bbb: &quot;露娜&quot;,  \n    ccc: &quot;李白&quot;,  \n&#125;;  \n  \nconsole.log(roleMap.aaa);  \nconsole.log(roleMap[&quot;aaa&quot;]); // 警告：不推荐这样来取可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型：\n这是因为当使用 number来索引时，JavaScript 会将它转换成 string 然后再去索引对象。\ntypescriptclass Person &#123;  \n    private name: string = &quot;&quot;;  \n&#125;  \n  \nclass Student extends Person &#123;  \n    private sno: number = 0;  \n&#125;  \n  \n// 下面的代码会报错  \ninterface IndexSubject &#123;  \n    [index: number]: Person;  \n    [name: string]: Student;  \n&#125;代码会报如下错误：\nbash数字索引类型“Person”不能赋给字符串索引类型“Student”。修改为如下代码就可以了：\ntypescriptinterface IndexSubject &#123;  \n    [index: number]: Student;  \n    [name: string]: Person;\n&#125;下面的代码也会报错：\n\nletter 索引得到结果的类型，必须是 Person 类型或者它的子类型\n\ntypescriptinterface IndexSubject &#123;  \n    [index: number]: Student;  \n    [name: string]: Person;  \n    letter: string;\n&#125;3.3. 接口的实现接口除了定义某种类型规范之后，也可以和其他编程语言一样，让一个类去实现某个接口，那么这个类就必须明确去拥有这个接口中的属性和实现其方法：\ntypescript// 定义一个实体接口  \ninterface Entity &#123;  \n    title: string;  \n    log(): void;  \n&#125;  \n  \n// 实现这样一个接口  \nclass Post implements Entity &#123;\n    title: string;  \n      \n    constructor(title: string) &#123;  \n        this.title = title;  \n    &#125;  \n    \n    log(): void &#123;\n        console.log(this.title);  \n    &#125;  \n&#125;思考：我定义了一个接口，但是我在继承这个接口的类中还要写接口的实现方法，那我不如直接就在这个类中写实现方法岂不是更便捷，还省去了定义接口？这是一个初学者经常会有疑惑的地方。\n从思考方式上，为什么需要接口?\n\n我们从生活出发理解接口\n\n比如你去三亚&#x2F;杭州旅游, 玩了一上午后饥饿难耐, 你放眼望去, 会注意什么? 饭店!!\n\n你可能并不会太在意这家饭店叫什么名字, 但是你知道只要后面有饭店两个字, 就意味着这个地方必然有饭店的实现 – 做各种菜给你吃；\n\n接口就好比饭店&#x2F;酒店&#x2F;棋牌室这些名词后面添加的附属词, 当我们看到这些附属词后就知道它们具备的功能\n\n\n从代码设计上，为什么需要接口?\n\n在代码设计中，接口是一种规范；\n\n接口通常用于来定义某种规范, 类似于你必须遵守的协议, 有些语言直接就叫protocol；\n\n站在程序角度上说接口只规定了类里必须提供的属性和方法，从而分离了规范和实现，增强了系统的可拓展性和可维护性；\n\n\n当然，对于初次接触接口的人，还是很难理解它在实际的代码设计中的好处，这点慢慢体会，不用心急。\n3.3. 接口的继承和类相似，接口也是可以继承接口来提供复用性：\n\n注意：继承使用extends关键字\n\ntypescriptinterface Barkable &#123;  \n    barking(): void;\n&#125;\ninterface Shakable &#123;  \n    shaking(): void;\n&#125;\ninterface Petable extends Barkable, Shakable &#123;  \n    eating(): void;\n&#125;接口Petable继承自Barkable和Shakable，另外我们发现一个接口可以同时继承自多个接口\n如果现在有一个类实现了Petable接口，那么不仅仅需要实现Petable的方法，也需要实现Petable继承自的接口中的方法：\n\n注意：实现接口使用implements关键字\n\ntypescriptclass Dog implements Petable &#123;  \n    barking(): void &#123;  \n    console.log(&quot;汪汪叫&quot;);  \n    &#125;  \n  \nshaking(): void &#123;  \n    console.log(&quot;摇尾巴&quot;);  \n    &#125;  \n  \neating(): void &#123;  \n    console.log(&quot;吃骨头&quot;);  \n    &#125;  \n&#125;结语学如逆水行舟，不进则退\n\n谢谢款待\n2023 09 09\n","slug":"TypeScript【四】接口interface使用详解","date":"2023-09-09T04:30:47.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"},{"id":"3a056f889a88e7c415c2526b3ac8783b","title":"TypeScript【三】定义变量和数据类型","content":"前言学习如何在 TypeScript 中定义变量，以及 JavaScript 类型在 TypeScript 中的变化以及 TypeScript 中新增的类型。\n1. 声明变量方式1.1.  声明变量的格式在 TypeScript 中定义变量需要指定 标识符 的类型。\n所以完整的声明格式如下：\ntypescriptvar/let/const 标识符: 数据类型 = 赋值;比如我们声明一个message，完整的写法如下：\ntypescriptlet message: string = &quot;Hello World&quot;;\nmessage = &quot;Hello TypeScript&quot;; // 正确的做法\nmessage = 20; // 错误的做法，因为message是一个string类型\n注意：这里的string是小写的，和String是有区别的\n\nstring是 TypeScript 中定义的字符串类型，String 是 ECMAScript 中定义的一个类。\n\n\n1.2. 声明变量的关键字在TypeScript定义变量（标识符）和ES6之后一致，可以使用var、let、const来定义：\ntypescriptvar myname: string = &quot;abc&quot;;\nlet myage: number = 20;\nconst myheight: number = 1.88;但是，我们会发现使用var关键字会有一个警告：\n\n\n\n\n\n\n\nWARNING\nForbidden ‘var’keyword,use ‘let’or ‘const’instead\n\n可见，在 TypeScript 中并不建议再使用 var 关键字了，主要原因和 ES6 升级后 let 和 var 的区别是一样的，var是没有块级作用域的，会引起很多的问题。\n所以，在之后的开发中，我们定义变量主要使用 let 和 const。\n1.3. 变量的类型推断在开发中，有时候为了方便起见我们并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过TypeScript本身的特性帮助我们推断出对应的变量类型：\ntypescriptlet message = &quot;Hello World&quot;;上面的代码我们并没有指定类型，但是message实际上依然是一个字符串类型。\n这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型：\n上面的message就是因为后面赋值的是一个string类型，所以message虽然没有明确的说明，但是依然是一个string类型。\n1.4. 声明 name 报错我们在TypeScript的文件中声明一个name（很多其他的名字也会）时，会报错：\n\n主要错误信息：\n无法重新声明块范围变量 name\n我们前面明明（明明说管我什么事）没有声明 name，但是却说我们重复声明了\n\n这次是因为我们的typescript 将 DOM typings 作为全局的运行环境。\n\n所以当我们声明 name时， 与 DOM 中的全局  name 属性出现了重名。\n\n\n\n如何解决这个问题呢？\n\n有两种方案：去掉 DOM typings 的环境和声明模块\n\n方式一：删除DOM typings的环境\n但是这种办法对于我们来说并不合适，因为我们依然希望在DOM下编译我们的TypeScript代码。\n方式二：声明我们的ts文件为一个模块\n既然与全局的变量出现重名，那我们将脚本封装到模块（module）中，因为模块有属于自己的作用域，就不会和全局的产生冲突：\n\n在 Typescript 中，我们可以使用ES6的export来导出一个对象，并且该文件被视为 module\n\ntypescriptlet name = &quot;coderwhy&quot;;export &#123;&#125;;1.5. console.log报错另外为了测试方便我们经常使用console.log来进行测试，但是使用时会报一个警告。\n这个时候，我们可以配置：\ntslint.json\njson&#123;\n    &quot;defaultSeverity&quot;: &quot;error&quot;,\n    &quot;extends&quot;: [\n        &quot;tslint:recommended&quot;\n    ],\n    &quot;jsRules&quot;: &#123;&#125;,\n    &quot;rules&quot;: &#123;\n        &quot;no-console&quot;: false\n    &#125;,\n    &quot;rulesDirectory&quot;: []\n&#125;添加了：\njson&quot;rules&quot;: &#123;\n    &quot;no-console&quot;: false\n&#125;2. JavaScript 数据类型2.1. number类型数字类型是我们开发中经常使用的类型，TypeScript和JavaScript一样，不区分整数类型（int）和浮点型（double），统一为number类型。\ntypescript// 1.数字类型基本定义\nlet num = 100;\nnum = 20;\nnum = 6.66;ES6新增了二进制和八进制的表示方法，而TypeScript也是支持二进制、八进制、十六进制的表示：\ntypescript// 2.其他进制表示  \nnum = 100; // 十进制  \nnum = 0b110; // 二进制  \nnum = 0o555; // 八进制  \nnum = 0xf23; // 十六进制2.2. boolean类型boolean类型只有两个取值：true和false，非常简单\ntypescript// boolean类型的表示\nlet flag: boolean = true;\nflag = false;flag = 20 &gt; 30;2.3. string类型string 类型是字符串类型，可以使用单引号或者双引号表示：\n\n注意：如果打开了 TSLint，默认情况下推荐使用使用双引号\n\ntypescript// string类型表示\nlet message: string = &quot;Hello World&quot;;\nmessage = &#39;Hello TypeScript&#39;;同时也支持ES6的模板字符串来拼接变量和字符串：\ntypescriptconst name = &quot;why&quot;;\nconst age = 18;\nconst height = 1.88;\nconst info = `my name is $&#123;name&#125;, age is $&#123;age&#125;, height is $&#123;height&#125;`;\nconsole.log(info);2.4. array类型数组类型的定义也非常简单，有两种方式：\n\n但是TSLint会推荐我们使用上面这种方式\n\ntypescriptconst names1: string[] = [&quot;why&quot;, &quot;abc&quot;, &quot;cba&quot;];  \nconst names2: Array&lt;string&gt; = [&quot;why&quot;, &quot;abc&quot;, &quot;cba&quot;];2.5. object类型object对象类型可以用于描述一个对象：\ntypescript// object类型表示\nconst myinfo: object = &#123;  \n    name: &quot;why&quot;,  \n    age: 20,  \n    height: 1.88\n&#125;;属性是不可以访问的\n如果我们访问myinfo中的属性，会发现报错：\n\n这是因为TypeScript并不知道某一个object类型上面就有一个name的属性。\n但是如果我们让它是类型推断的写法，就可以正常的访问：\n\n还有一种方法是定义接口，TypeScript一个非常好用的特性就是接口interface。\n2.6. symbol类型在ES5中，如果我们是不可以在对象中添加相同的属性名称的，比如下面的做法：\ntypescriptconst person = &#123;  \n    identity: &quot;程序员&quot;,  \n    identity: &quot;老师&quot;\n&#125;通常我们的做法是定义两个不同的属性名字：比如identity1和identity2。\n但是我们也可以通过symbol来定义相同的名称，因为Symbol函数返回的是不同的值：\ntypescriptconst s1 = Symbol(&quot;identity&quot;);\nconst s2 = Symbol(&quot;identity&quot;);\nconst person = &#123;  \n    [s1]: &quot;程序员&quot;,  \n    [s2]: &quot;老师&quot;\n&#125;;2.7. null和undefined在 JavaScript 中，undefined 和 null 是两个基本数据类型。\n在TypeScript中，它们各自的类型也是undefined和null，也就意味着它们既是实际的值，也是自己的类型：\ntypescriptconst n: null = null;\nconst u: undefined = undefined;3. TypeScript 引入的数据类型TypeScript 在原有的 JavaScript 基础上引入了很多好用的类型：enum 枚举类型、tuple 元组类型、any 类型、void 类型、never 类型等。\n3.1. enum 类型3.1.1. 枚举的基本定义枚举类型在很多语言都有的类型，比如C++、Java等等，并且也非常好用，所以TypeScript引入了enum类型，让我们开发更好的方便和安全。\n枚举类型通常是定义一组数据：\ntypescriptenum Direction &#123;\n    EAST,\n    WEST,\n    NORTH,\n    SOUTH\n&#125;\n\nconst d1 = Direction.EAST\nconst d2 = Direction.NORTH3.1.2. 枚举类型的值枚举类型有自己的值，比如打印上面的d1和d2\ntypescriptconsole.log(d1)\nconsole.log(d2)bash------ 控制台 ------\n0\n2默认情况下，枚举中的数据是从0开始的，我们可以改变它的初始化值，比如下面的代码：\ntypescriptenum Direction &#123;  \n    EAST = 10,  \n    WEST,  \n    NORTH,  \n    SOUTH\n&#125;  \n  \nconst d1 = Direction.EAST;  \nconst d2 = Direction.NORTH;  \n  \nconsole.log(d1); // 10  \nconsole.log(d2); // 12也可以全部自己来指定：\ntypescriptenum Direction &#123;  \n    EAST = 10,  \n    WEST = 20,  \n    NORTH = 30,  \n    SOUTH = 40\n&#125;  \n  \nconst d1 = Direction.EAST;  \nconst d2 = Direction.NORTH;  \n  \nconsole.log(d1); // 10  \nconsole.log(d2); // 30我们也可以通过对应的值去获取对应的数据名称：\ntypescriptconsole.log(Direction[10]); // EAST  \nconsole.log(Direction[30]); // NORTH3.2. tuple 类型3.2.1. tuple的基本使用tuple是元组类型，很多语言中也有这种数据类型，比如Python、Swift等。\ntypescriptconst tInfo: [string, number, number] = [&quot;why&quot;, 18, 1.88];  \nconst item1 = tInfo[0]; // why, 并且知道类型是string类型  \nconst item2 = tInfo[1]; // 18, 并且知道类型是number类型3.2.1. tuple 和数组类比初学 tuple 会觉得它和数组非常相似\n但是数组中通常会定义一组相同的数据，如果数据不同会造成类型的丢失：\ntypescriptconst aInfo: Array&lt;string|number&gt; = [&quot;why&quot;, 18, 1.88];  \nconst itema = aInfo[0]; // why，但是并不知道itema是string类型还是number类型3.3. any类型在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用any类型（类似于Dart语言中的dynamic类型）\ntypescriptlet a: any = &quot;why&quot;;a = 123;a = true;const aArray: any[] = [&quot;why&quot;, 18, 1.88];3.4. void类型void 类型通常用于函数没有返回值时来使用：\n在 TypeScript 中函数也是有类型的\n下面的函数，虽然我们没有指定它的类型，但是它会通过类型推导出来：\ntypescriptconst sum = (num1: number, num2: number) =&gt; &#123;  \nreturn num1 + num2;  \n&#125;;  \n  \n// 相当于下面的写法  \nconst sum: (num1: number, num2: number) =&gt;number = (num1: number, num2: number) =&gt; &#123;  \nreturn num1 + num2;  \n&#125;;\n3.5. never类型never类型表示一种从来不会存在的值的类型，有点绕，我们来这样理解：\n如果一个函数中是一个死循环，那么这个函数会返回东西吗？不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型。\n\n如果一个函数是抛出一个异常，那么这个函数是不是也没有返回值呢？这个时候我们也可以使用never类型。\n\n结语学如逆水行舟，不进则退\n\n谢谢款待\n2023 09 08\n","slug":"TypeScript【三】定义变量和数据类型","date":"2023-09-08T02:34:03.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"},{"id":"8341e59134e12dac24934a69216cde75","title":"TypeScript【二】使用Webpack搭建环境","content":"前言学习任何的开发，我们都需要对应的环境：包括TypeScript的编译环境和开发工具。\n我们就来完成它们的搭建，后续就可以愉快的来写TypeScript代码了。\n1. 环境搭建1.1. TypeScript环境安装TypeScript最终会被编译成JavaScript代码：\n\n那么我们必然需要对应的编译环境：\n安装命令\nbashnpm install typescript -g查看版本\nbashtsc --version1.2. tsc简单代码测试打开VSCode，并且新建一个个文件：index.ts\nindex.ts 代码如下：\ntypescript// 定义一个变量\nlet message: string = &quot;abc&quot;\nmessage = 123\n\n// 定义一个函数\nfunction sum(num1: number, num2: number): number &#123;\n    return num1 + num2\n&#125;\n\nsum(&quot;abc&quot;, &quot;cba&quot;)我们会发现有两个地方都会报错：\n错误一：不能将类型 “123” 分配给类型 “string”\n\n错误二：类型 “abc” 的参数不能赋给类型 “number” 的参数\n\n上面两个错误都是因为我们的代码已经增加了类型约束，不能随便赋值其他类型给我们的变量。\n将代码修改正确如下：\ntypescript// 定义一个变量  \nlet message: string = &quot;abc&quot;;  \nmessage = &quot;Hello World&quot;;  \n  \n// 定义一个函数  \nfunction sum(num1: number, num2: number): number &#123;  \n    return num1 + num2;  \n&#125;  \n  \nsum(20, 30);将代码编译为JavaScript的代码\nbashtsc index.ts\n我们会发现，生成了一个index.js文件，并且其中的代码就是普通的JavaScript代码。\n问题：每次都这样测试会不会太麻烦了呢？\n如果每次我们写完一个TypeScript代码都需要像上面的步骤一样，一点点去完成测试就会过于麻烦，我们可以怎么做呢？\n\n直接配置webpack，让webpack对我们编写的代码进行一个编译，并且自动引入编译后的js文件。\n\n而且webpack可以在代码修改后重新帮助我们进行编译，并且自动刷新浏览器，不需要手动操作。\n\n\n2. 项目环境2.1. 项目环境的基础配置为了之后的学习和使用方便，可以配置一个webpack的环境。\n配置目的：\n在环境中我们编写对应的TypeScript代码，让webpack自动帮助我们编译，并且在浏览器中查看结果。\n注意：\n这里需要对npm和webpack有一些简单的了解，不会非常复杂。\n2.1.1. 创建一个简单的项目目录结构新建一个新的目录：LearnTypeScript，并且创建如下的目录结构\nbash|- index.html\n|- build\n|  - webpack.config.js\n|- src\n|  - main.ts目录和文件夹结构分析:\n\nindex.html 是跑在浏览器上的模块文件\n\nbuild 文件夹中用于存放webpack的配置信息\n\nsrc 用于存放我们之后编写的所有TypeScript代码\n\n\n2.1.2. 使用npm管理项目的依赖webpack 本身需要有很多的依赖，并且之后我们也需要启动 node 服务来快速浏览 index.html 模板以及编译后的 JavaScript 代码。\n我们要使用 npm 来初始化 package.json 文件：\nbashnpm init -y2.1.3. 本地依赖 TypeScript为什么需要本地依赖 TypeScript ?\n\n因为我们之后是通过webpack进行编译我们的TypeScript代码的，并不是通过tsc来完成的。（tsc使用的是全局安装的TypeScript依赖）\n那么webpack会在本地去查找TypeScript的依赖，所以我们是需要本地依赖TypeScript的；\n\n安装本地TypeScript依赖\nbashnpm install typescript2.1.4. 初始化 tsconfig.json 文件在进行 TypeScript 开发时，我们会针对 TypeScript 进行相关的配置，而这些配置信息是存放在一个 tsconfig.json 文件中的。\n我们并不需要手动去创建它，可以通过命令行直接来生成这样的一个文件：\nbashtsc --init2.1.5. 配置 tslint 来约束代码为了按照严格的 TypeScript 风格学习代码，这里可以加入 tslint\n全局安装tslint：\nbashnpm install tslint -g在项目中初始化tslint的配置文件：tslint.json\nbashtslint -i2.2. 项目环境的Webpack下面我们开始配置webpack相关的内容\n2.2.1. 安装 webpack 相关的依赖使用 webpack 开发和打开：\n需要依赖 webpack、webpack-cli、webpack-dev-server\nbashnpm install webpack webpack-cli webpack-dev-server -D2.2.2. 在 package.json 中添加启动命令为了方便启动 webpack，我们在 package.json 中添加如下启动命令\nbash&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;serve&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --mode=development --config build/webpack.config.js&quot;\n&#125;2.2.3. 添加 webpack 的其他相关依赖依赖一 ：cross-env\n这里我们用到一个插件 cross-env ，这个插件的作用是可以在 webpack.config.js 中通过 process.env.NODE_ENV 来获取当前是开发还是生产环境，我们需要这个插件：cross-env\nbashnpm install cross-env -D依赖二 ：ts-loader\n因为我们需要解析.ts文件，所以需要依赖对应的loader：ts-loader\nbashnpm install ts-loader -D依赖三 ：html-webpack-plugin\n编译后的代码需要对应的 html 模块作为它的运行环境，所以我们需要使用 html-webpack-plugin 来将它插入到对应的模板中：\nbashnpm install html-webpack-plugin -D2.2.4. 配置 webpack.config.js 文件将如下配置到webpack.config.js文件中：\njavascriptconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\n\nconst path = require(&quot;path&quot;);\n\nmodule.exports = &#123;\n  entry: &quot;./src/main.ts&quot;,\n  output: &#123;\n    filename: &quot;build.js&quot;\n  &#125;,\n  resolve: &#123;\n    extensions: [&quot;.tsx&quot;, &quot;.ts&quot;, &quot;.js&quot;]\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.tsx?$/,\n        use: &quot;ts-loader&quot;,\n        exclude: /node_modules/\n      &#125;\n    ]\n  &#125;,\n  devtool: process.env.NODE_ENV === &quot;production&quot; ? false : &quot;inline-source-map&quot;,\n  devServer: &#123;\n    static: &#123;\n      directory: path.resolve(__dirname, &#39;dist&#39;)\n    &#125;,\n    client: &#123;\n      logging: &#39;error&#39;\n    &#125;,\n    compress: false,\n    host: &quot;localhost&quot;,\n    port: 8080\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: &quot;./index.html&quot;\n    &#125;)\n  ]\n&#125;;2.3. 项目环境下代码测试下面我们就可以愉快的在main.ts中编写代码，之后只需要启动服务即可：\ntypescriptlet message: string = &quot;Hello World&quot;\nconsole.log(message)在终端中启动服务：\nbashnpm run serve之后修改代码，直接可以看到修改后的效果，不需要手动进行任何刷新。\n结语学如逆水行舟，不进则退\n\n谢谢款待\n2023 09 07\n","slug":"TypeScript【二】使用Webpack搭建环境","date":"2023-09-07T03:12:26.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"},{"id":"fe45d9911f5fa4623963bc931676390e","title":"TypeScript【一】TypeScript培养类型思维","content":"前言 当你点开这篇文章时，我相信你已经在很多地方都已经听说过或者见过 TypeScript 了。\n 但是可能对 TypeScript 依然有很多问号：TypeScript 到底是什么？\n 为什么每个人都在说 TypeScript 怎么怎么好，到底好在哪里？\n Angular、Vue3 接连使用 TypeScript 进行了重构是否意味着我们必须掌握 TypeScript，它们又为什么要选择TypeScript ？\n 我需要什么样的基础才能学会或者说学好TypeScript呢？没有关系，在这个章节中我们就来解答上面的疑惑，并且我希望大家学完这个章节可以对一个概念有深入的理解，就是 类型思维。\n 不着急，下面就让我们和TypeScript有一场美丽的邂逅。\n1. JavaScript 的痛点\n\n\n\n\n\n\n\n\n我始终坚信：任何新技术的出现都是为了解决之前某个技术的痛点。\n1.1. 优秀的JavaScriptJavaScript是一门优秀的编程语言吗？\n每个人可能观点并不完全一致，但是从很多角度来看，JavaScript是一门非常优秀的编程语言。\n而且，可以说在很长一段时间内这个语言不会被代替，并且会在更多的领域被大家广泛使用。\n著名的Atwood定律是什么？\n\n\n\n\n\n\n\n\n\nany application that can be written in JavaScript, will eventually be written in JavaScript.\n“任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现。”\nStack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律。\n其实我们已经看到了，至少目前JavaScript在浏览器端依然无可替代，并且在服务端（Nodejs）也在被广泛的应用。\n优秀的JavaScript没有缺点吗？\n\n其实上由于各种历史因素，JavaScript语言本身存在很多的缺点；\n\n比如ES5以及之前的使用的var关键字关于作用域的问题；\n\n比如最初JavaScript设计的数组类型并不是连续的内存空间；\n\n比如直到今天JavaScript也没有加入类型检测这一机制；\n\n\nJavaScript正在慢慢变好吗？\n\n不可否认的是，JavaScript正在慢慢变得越来越好，无论是从底层设计还是应用层面。\n\nES6、7、8等的推出，每次都会让这门语言更加现代、更加安全、更加方便。\n\n但是知道今天，JavaScript在类型检测上依然是毫无进展。\n\n\n1.2. 类型引发的问题首先你需要知道，编程开发中我们有一个共识：错误出现的越早越好\n\n能在写代码的时候发现错误，就不要在代码编译时再发现（IDE的优势就是在代码编写过程中帮助我们发现错误）。\n\n能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测就可以很好的帮助我们做到这一点）。\n\n能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。\n\n\n现在我们想探究的就是如何在 代码编译期间 发现代码的错误\nJavaScript可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题。\njavascriptfunction getLength(str) &#123;\n    return str.length\n&#125;\n\nconsole.log(&quot;1.正在代码执行&quot;)\nconsole.log(&quot;2.开始函数&quot;)\ngetLength(&quot;abc&quot;)\ngetLength()\nconsole.log(&quot;3.调用结束&quot;)bash----- 控制台 -----\n1.正在代码执行\n2.开始函数\nTypeError: Cannot read properties of undefined (reading &#39;length&#39;)如上是我们一个非常常见的错误：\n\n这个错误很大的原因就是因为JavaScript没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个错误。\n\n并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而陷入崩溃。\n\n\n当然，你可能会想：我怎么可能犯这样低级的错误呢？\n\n当我们写像我们上面这样的简单的demo时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来。\n\n但是当我们开发一个大型项目时呢？你能保证自己一定不会出现这样的问题吗？而且如果我们是调用别人的类库，又如何知道让我们传入的到底是什么样的参数呢？\n\n\n但是，如果我们可以给JavaScript加上很多限制，在开发中就可以很好的避免这样的问题了：\n\n比如我们的getLength函数中str是一个必传的类型，没有调用者没有传编译期间就会报错。\n\n比如我们要求它的必须是一个String类型，传入其他类型就直接报错。\n\n那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改。\n\n\n1.3. 类型思维的缺失我们已经简单体会到没有类型检查带来的一些问题，JavaScript因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失：\n\n前端开发人员通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证。\n\n从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮。\n\n\n所以我们经常会说JavaScript不适合开发大型项目，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患，多人员开发它们之间也没有良好的类型契约：\n\n比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性。\n\n比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型。\n\n\n为了弥补JavaScript类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：\n\n2014年，Facebook推出了flow来对JavaScript进行类型检查\n\n同年，Microsoft微软也推出了TypeScript1.0版本\n\n他们都致力于为JavaScript提供类型检查\n\n\n而现在，无疑TypeScript已经完全胜出：\n\nVue2.x的时候采用的就是flow来做类型检查。\n\nVue3.x已经全线转向TypeScript，98.3%使用TypeScript进行了重构。\n\n而Angular在很早期就使用TypeScript进行了项目重构并且需要使用TypeScript来进行开发。\n\n而甚至Facebook公司一些自己的产品也在使用TypeScript。\n\n\n学习TypeScript不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。\n2. 邂逅 TypeScript2.1. 什么是 TypeScript ?虽然我们已经知道TypeScript是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下TypeScript到底是什么？\n\nTypeScript 在 GitHub 和官方上对自己的定义\n\nGitHub说法：\n\nTypeScript is a superset of JavaScript that compiles to clean JavaScript output.  \n\nTypeScript官网：\n\nTypeScript is a typed superset of JavaScript that compiles to plain JavaScript.  \n翻译一下：TypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码。\n\n\n\n怎么理解上面的话呢？\n我们可以将TypeScript理解成加强版的JavaScript。\ntxtJavaScript所拥有的特性，TypeScript全部都是支持的，并且它紧随ECMAScript的标准，所以ES6、ES7、ES8等新语法标准，它都是支持的。\n\n并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等。\n\nTypeScript在实现新特性的同时，总是保持和ES标准的同步甚至是领先。\n\n并且TypeScript最终会被编译成JavaScript代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于Babel这样的工具。所以，我们可以把TypeScript理解成一身神装的JavaScript，不仅让JavaScript更加安全，而且给它带来了诸多好用的装备特效。\n官方对TypeScript有几段特点的描述，我觉得非常到位（虽然有些官方，了解一下），我们一起来分享一下：\n始于JavaScript，归于JavaScript\n\nTypeScript从今天数以百万计的JavaScript开发者所熟悉的语法和语义开始。使用现有的JavaScript代码，包括流行的JavaScript库，并从JavaScript代码中调用TypeScript代码。\n\nTypeScript可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持ECMAScript 3（或更高版本）的JavaScript引擎中。\n\n\nTypeScript是一个强大的工具，用于构建大型项目\n\n类型允许JavaScript开发者在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有JavaScript库的行为。\n\n\n拥有先进的 JavaScript\n\nTypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的ECMAScript3（或更新版本）的JavaScript。\n\n\n正是因为有这些特性，TypeScript目前已经在很多地方被应用：\n\n包括我们前面提到的Vue3和Angular已经使用TypeScript进行重构\n包括Vue3以后的开发模式必然会和TypeScript更加切合，大家也更多的需要使用TypeScript来编写代码\n包括目前已经变成最流行的编辑器VSCode也是使用TypeScript来完成的\n包括在React中已经使用的ant-design的UI库，也大量使用TypeScript来编写\n包括小程序开发，也是支持TypeScript的\n\n3. 前端学不动系列3.1. 前端开发者的难大前端是一群最能或者说最需要折腾的开发者：\n\n客户端开发者：从Android到iOS，或者从iOS到Android，到RN，甚至现在越来越多的客户端开发者接触前端相关知识（Vue、React、Angular、小程序）\n\n前端开发者：从jQuery到AngularJS，到三大框架并行：Vue、React、Angular，还有小程序，甚至现在也要接触客户端开发（比如RN、Flutter）\n\n目前又面临着不仅仅学习ES的特性，还要学习TypeScript\n\nVue3马上也会到来，又必须学习Vue3新特性\n\n\n大前端开发就是，不像服务器一样可能几年甚至几十年还是那一套的东西。前端新技术会层出不穷。\n但是每一样技术的出现都会让惊喜，因为他必然是解决了之前技术的某一个痛点的，而TypeScript真是解决了JavaScript存在的很多设计缺陷，尤其是关于类型检测的。\n并且从开发者长远的角度来看，学习TypeScript有助于我们前端程序员培养 类型思维，这种思维方式对于完成大型项目尤为重要。\n结语学如逆水行舟，不进则退。\n\n谢谢款待\n2023 09 06\n","slug":"TypeScript【一】TypeScript培养类型思维","date":"2023-09-06T04:00:00.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"}]