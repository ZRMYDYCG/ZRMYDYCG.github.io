[{"id":"a20f42ee8373946d2898ea566c51817c","title":"821.字符串的最短距离-力扣（LeetCode）","content":"题目详情简单\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。返回一个整数数组 answer ，其中 answer.length &#x3D;&#x3D; s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n示例\n示例 1：\n\n输入：\nbashs = &quot;loveleetcode&quot;, c = &quot;e&quot;输出：\nbash[3,2,1,0,1,0,0,1,2,2,1,0]解释：\n字符 ‘e’ 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(0 - 3) &#x3D; 3 。\n距下标 1 最近的 ‘e’ 出现在下标 3 ，所以距离为 abs(1 - 3) &#x3D; 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 ‘e’ 都离它最近，但距离是一样的 abs(4 - 3) &#x3D;&#x3D; abs(4 - 5) &#x3D; 1 。\n距下标 8 最近的 ‘e’ 出现在下标 6 ，所以距离为 abs(8 - 6) &#x3D; 2 。\n\n示例 2：\n\n输入：\nbashs = &quot;aaab&quot;, c = &quot;b&quot;输出：\nbash[3,2,1,0]提示\n1 &lt;&#x3D; s.length &lt;&#x3D; 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n题解javascript/**\n  @ 一小池勺 \n * @param &#123;string&#125; s\n * @param &#123;character&#125; c\n * @return &#123;number[]&#125;\n  @ 2024 1 30\n */\nvar shortestToChar = function(S, C) &#123;\n  const resultArray = new Array(S.length).fill(0)\n  let NowTargetCharC_Index = 0\n\n  // 一次遍历\n  const charArray = Array.from(S) // 将字符串转换为数组\n  charArray.forEach((item, index) =&gt; &#123;\n    if(item === C) &#123;\n      resultArray[index] = 0\n      NowTargetCharC_Index = index\n    &#125; else &#123;\n      // 针对当前的 i 元素 =&gt; 进行前后距离比较\n      resultArray[index] = Math.min(Math.abs(S.indexOf(C, index) - index), Math.abs(S.indexOf(C, NowTargetCharC_Index) - index))\n    &#125;\n  &#125;)\n\n  return resultArray\n&#125;代码思路\n创建一个与字符串长度相同的数组resultArray，并将其填充为0。\n\n初始化变量NowTargetCharC_Index为0，用于记录当前目标字符C的索引位置。\n\n将字符串转换为字符数组charArray。\n\n使用forEach方法遍历charArray中的每个字符。\n\n如果当前字符等于目标字符C，将resultArray相应索引位置的值设置为0，并更新NowTargetCharC_Index为当前索引。\n\n如果当前字符不等于目标字符C，通过indexOf方法分别计算当前索引位置到目标字符C的前一个索引位置和后一个索引位置的距离，并将较小的距离赋值给resultArray相应索引位置。\n\n返回resultArray作为结果。\n\n\n","slug":"821-字符串的最短距离-力扣（LeetCode）","date":"2024-02-07T09:59:44.000Z","categories_index":"LeetCode","tags_index":"LeetCode 解题报告","author_index":"一小池勺"},{"id":"efa903f91a28565d8dca46166c5eaa96","title":"TypeScript【四】接口interface使用详解","content":"前言接口是TypeScript中一个非常重要的概念，在其他很多语言中已经有了并且被大量使用。\n1. 为什么要使用接口1.1. JavaScript存在的问题我们在JavaScript中定义一个函数，用于获取一个用户的姓名和年龄的字符串：\njavascriptconst getUserInfo = function(user) &#123;\n    return `name: $&#123;user.name&#125;`, aage: $&#123;user.age&#125;`\n&#125;正确的调用方法应该是下面的方式：\njavascriptgetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;)但是当项目比较大，或者多人开发时，会出现错误的调用方法：\njavascript// 错误的调用  \ngetUserInfo() // Uncaught TypeError: Cannot read property &#39;name&#39; of undefined  \nconsole.log(getUserInfo(&#123;name: &quot;coderwhy&quot;&#125;)) // name: coderwhy, age: undefined  \ngetUserInfo(&#123;name: &quot;codewhy&quot;, height: 1.88&#125;) // name: coderwhy, age: undefined因为 JavaScript 是弱类型的语言，所以并不会对我们传入的代码进行任何的检测，但是在之前的 JavaScript 中确确实实会存在很多类似的安全隐患。\n如何避免这样的问题呢？\n当然是使用 TypeScript 来对代码进行重构\n1.2. TypeScript代码重构（一）我们可以使用TypeScript来对上面的代码进行改进：\ntypescriptconst getUserInfo = (user: &#123;name: string, age: number&#125;): string =&gt; &#123;\n    return `name: $&#123;user.name&#125; age: $&#123;user.age&#125;`;\n&#125;;正确的调用是如下的方式：\ntypescriptgetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;);如果调用者出现了错误的调用，那么TypeScript 会直接给出错误的提示信息：\ntypescript// 错误的调用  \ngetUserInfo(); // 错误信息：An argument for &#39;user&#39; was not provided.  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;&#125;); // 错误信息：Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;, height: 1.88&#125;); // 错误信息：类型不匹配这样确实可以防止出现错误的调用，但是我们在定义函数的时候，参数的类型和函数的类型都是非常长的，代码非常不便于阅读。\n所以，我们可以使用接口来对代码再次进行重构。\n1.3. TypeScript 代码重构（二）接口重构一：参数类型使用接口定义\n我们先定义一个IUser接口：\ntypescript// 先定义一个接口  \ninterface IUser &#123;  \n    name: string;  \n    age: number;  \n&#125;接下来我们看一下函数如何来写：\ntypescriptconst getUserInfo = (user: IUser): string =&gt; &#123;  \n    return `name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;  \n&#125;;  \n  \n// 正确的调用  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;);  \n  \n// 错误的调用，其他也是一样  \ngetUserInfo();接口重构二：函数的类型使用接口定义（后面会详细讲解接口函数的定义）\n我们先定义两个接口：\n\n第二个接口定义有一个警告，我们暂时忽略它，它的目的是如果一个函数接口只有一个方法，那么可以使用type来定义  type IUserInfoFunc &#x3D; (user: IUser) &#x3D;&gt; string;\n\ntypescriptinterface IUser &#123;\n    name: string;\n    age: number;\n&#125;\n\ninterface IUserInfoFunc &#123;\n    (user: IUser): string;\n&#125;接着我们去定义函数和调用函数即可：\ntypescriptconst getUserInfo: IUserInfoFunc = (user) =&gt; &#123;  \n    return`name: $&#123;user.name&#125;, age: $&#123;user.age&#125;`;  \n&#125;;  \n  \n// 正确的调用  \ngetUserInfo(&#123;name: &quot;coderwhy&quot;, age: 18&#125;);  \n  \n// 错误的调用  \ngetUserInfo();2. 接口的基本使用2.1. 接口的定义方式和其他很多的语言类似，TypeScript 中定义接口也是使用 interface 关键字来定义：\ntypescriptinterface IPerson &#123;  \n    name: string;  \n&#125;你会发现我都在接口的前面加了一个 I，这是 tslint 要求的，否则会报一个警告\n\n要不要加前缀是根据公司规范和个人习惯\n\nbashinterface name must start with a capitalized I当然我们可以在 tslint 中关闭掉它：在 rules 中添加如下规则\njavascript&quot;interface-name&quot; : [true, &quot;never-prefix&quot;]2.2. 接口中定义方法定义接口中不仅仅可以有属性，也可以有方法：\ntypescriptinterface Person &#123;  \n    name: string;  \n    run(): void;  \n    eat(): void;\n&#125;如果我们有一个对象是该接口类型，那么必须包含对应的属性和方法：\ntypescriptconst p: Person = &#123;  \n    name: &quot;why&quot;,  \n    run() &#123;    \n    console.log(&quot;running&quot;);  \n    &#125;,  \n    eat() &#123;    \n    console.log(&quot;eating&quot;);  \n    &#125;\n&#125;;2.3. 可选属性的定义默认情况下一个变量（对象）是对应的接口类型，那么这个变量（对象）必须实现接口中所有的属性和方法。\n但是，开发中为了让接口更加的灵活，某些属性我们可能希望设计成可选的（想实现可以实现，不想实现也没有关系），这个时候就可以使用可选属性。\ntypescriptinterface Person &#123;  \n    name: string;  \n    age?: number;  \n    run(): void;  \n    eat(): void;  \n    study?(): void;\n&#125;上面的代码中，我们增加了 age 属性和 study 方法，这两个都是可选的：\n\n可选属性如果没有赋值，那么获取到的值是undefined；\n\n对于可选方法，必须先进行判断，再调用，否则会报错；\n\n\ntypescriptconst p: Person = &#123;  \n    name: &quot;why&quot;,  \n    run() &#123;  \n    console.log(&quot;running&quot;);  \n    &#125;,  \n    eat() &#123;  \n    console.log(&quot;eating&quot;);  \n    &#125;\n&#125;;  \n  \nconsole.log(p.age); // undefined  \np.study(); // 不能调用可能是“未定义”的对象。正确的调用方式如下：\ntypescriptif (p.study) &#123;  \n    p.study();\n&#125;2.4. 只读属性的定义默认情况下，接口中定义的属性可读可写：\ntypescriptconsole.log(p.name);  \np.name = &quot;流川枫&quot;;如果一个属性，我们只是希望在定义的时候就定义值，之后不可以修改，那么可以在属性的前面加上一个关键字：readonly\ntypescriptinterface Person &#123;  \n    readonly name: string;  \n    age?: number;  \n    run(): void;  \n    eat(): void;  \n    study?(): void;  \n&#125;当我在name前面加上readonly时，赋值语句就会报错：\ntypescriptconsole.log(p.name);p.name = &quot;流川枫&quot;; // Cannot assign to &#39;name&#39; because it is a read-only property.3. 接口的高级使用3.1. 函数类型的定义接口不仅仅可以定义普通的对象类型，也可以定义函数的类型\ntypescript// 函数类型的定义\ninterface SumFunc &#123;  \n    (num1: number, num2: number): number;  \n&#125;  \n  \n// 定义具体的函数  \nconst sum: SumFunc = (num1, num2) =&gt; &#123;  \n    return num1 + num2;  \n&#125;;  \n  \n// 调用函数  \nconsole.log(sum(20, 30));不过上面的接口中只有一个函数，TypeScript 会给我们一个建议，可以使用type来定义一个函数的类型：\ntypescripttype SumFunc = (num1: number, num2: number) =&gt; number;3.2. 可索引类型的定义和使用接口描述函数的类型差不多，我们也可以使用接口来描述 可索引类型\n\n比如一个变量可以这样访问：a[3]，a[&quot;name&quot;]\n\n可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。\ntypescript// 定义可索引类型的接口  \ninterface RoleMap &#123;  \n    [index: number]: string;  \n&#125;  \n  \n// 赋值具体的值  \n// 赋值方式一：  \nconst roleMap1: RoleMap = &#123;  \n    0: &quot;学生&quot;,  \n    1: &quot;讲师&quot;,  \n    2: &quot;班主任&quot;,  \n&#125;;  \n  \n// 赋值方式二：因为数组本身是可索引的值  \nconst roleMap2 = [&quot;鲁班七号&quot;, &quot;露娜&quot;, &quot;李白&quot;];  \n  \n// 取出对应的值  \nconsole.log(roleMap1[0]); // 学生  \nconsole.log(roleMap2[1]); // 露娜上面的案例中，我们的索引签名是数字类型， TypeScript支持两种索引签名：字符串和数字。\n我们来定义一个字符串的索引类型：\ntypescriptinterface RoleMap &#123;  \n    [name: string]: string;  \n&#125;  \n  \nconst roleMap: RoleMap = &#123;  \n    aaa: &quot;鲁班七号&quot;,  \n    bbb: &quot;露娜&quot;,  \n    ccc: &quot;李白&quot;,  \n&#125;;  \n  \nconsole.log(roleMap.aaa);  \nconsole.log(roleMap[&quot;aaa&quot;]); // 警告：不推荐这样来取可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型：\n这是因为当使用 number来索引时，JavaScript 会将它转换成 string 然后再去索引对象。\ntypescriptclass Person &#123;  \n    private name: string = &quot;&quot;;  \n&#125;  \n  \nclass Student extends Person &#123;  \n    private sno: number = 0;  \n&#125;  \n  \n// 下面的代码会报错  \ninterface IndexSubject &#123;  \n    [index: number]: Person;  \n    [name: string]: Student;  \n&#125;代码会报如下错误：\nbash数字索引类型“Person”不能赋给字符串索引类型“Student”。修改为如下代码就可以了：\ntypescriptinterface IndexSubject &#123;  \n    [index: number]: Student;  \n    [name: string]: Person;\n&#125;下面的代码也会报错：\n\nletter 索引得到结果的类型，必须是 Person 类型或者它的子类型\n\ntypescriptinterface IndexSubject &#123;  \n    [index: number]: Student;  \n    [name: string]: Person;  \n    letter: string;\n&#125;3.3. 接口的实现接口除了定义某种类型规范之后，也可以和其他编程语言一样，让一个类去实现某个接口，那么这个类就必须明确去拥有这个接口中的属性和实现其方法：\ntypescript// 定义一个实体接口  \ninterface Entity &#123;  \n    title: string;  \n    log(): void;  \n&#125;  \n  \n// 实现这样一个接口  \nclass Post implements Entity &#123;\n    title: string;  \n      \n    constructor(title: string) &#123;  \n        this.title = title;  \n    &#125;  \n    \n    log(): void &#123;\n        console.log(this.title);  \n    &#125;  \n&#125;思考：我定义了一个接口，但是我在继承这个接口的类中还要写接口的实现方法，那我不如直接就在这个类中写实现方法岂不是更便捷，还省去了定义接口？这是一个初学者经常会有疑惑的地方。\n从思考方式上，为什么需要接口?\n\n我们从生活出发理解接口\n\n比如你去三亚&#x2F;杭州旅游, 玩了一上午后饥饿难耐, 你放眼望去, 会注意什么? 饭店!!\n\n你可能并不会太在意这家饭店叫什么名字, 但是你知道只要后面有饭店两个字, 就意味着这个地方必然有饭店的实现 – 做各种菜给你吃；\n\n接口就好比饭店&#x2F;酒店&#x2F;棋牌室这些名词后面添加的附属词, 当我们看到这些附属词后就知道它们具备的功能\n\n\n从代码设计上，为什么需要接口?\n\n在代码设计中，接口是一种规范；\n\n接口通常用于来定义某种规范, 类似于你必须遵守的协议, 有些语言直接就叫protocol；\n\n站在程序角度上说接口只规定了类里必须提供的属性和方法，从而分离了规范和实现，增强了系统的可拓展性和可维护性；\n\n\n当然，对于初次接触接口的人，还是很难理解它在实际的代码设计中的好处，这点慢慢体会，不用心急。\n3.3. 接口的继承和类相似，接口也是可以继承接口来提供复用性：\n\n注意：继承使用extends关键字\n\ntypescriptinterface Barkable &#123;  \n    barking(): void;\n&#125;\ninterface Shakable &#123;  \n    shaking(): void;\n&#125;\ninterface Petable extends Barkable, Shakable &#123;  \n    eating(): void;\n&#125;接口Petable继承自Barkable和Shakable，另外我们发现一个接口可以同时继承自多个接口\n如果现在有一个类实现了Petable接口，那么不仅仅需要实现Petable的方法，也需要实现Petable继承自的接口中的方法：\n\n注意：实现接口使用implements关键字\n\ntypescriptclass Dog implements Petable &#123;  \n    barking(): void &#123;  \n    console.log(&quot;汪汪叫&quot;);  \n    &#125;  \n  \nshaking(): void &#123;  \n    console.log(&quot;摇尾巴&quot;);  \n    &#125;  \n  \neating(): void &#123;  \n    console.log(&quot;吃骨头&quot;);  \n    &#125;  \n&#125;结语学如逆水行舟，不进则退\n\n谢谢款待\n2023 09 09\n","slug":"TypeScript【四】接口interface使用详解","date":"2023-09-09T04:30:47.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"},{"id":"3a056f889a88e7c415c2526b3ac8783b","title":"TypeScript【三】定义变量和数据类型","content":"前言学习如何在 TypeScript 中定义变量，以及 JavaScript 类型在 TypeScript 中的变化以及 TypeScript 中新增的类型。\n1. 声明变量方式1.1.  声明变量的格式在 TypeScript 中定义变量需要指定 标识符 的类型。\n所以完整的声明格式如下：\ntypescriptvar/let/const 标识符: 数据类型 = 赋值;比如我们声明一个message，完整的写法如下：\ntypescriptlet message: string = &quot;Hello World&quot;;\nmessage = &quot;Hello TypeScript&quot;; // 正确的做法\nmessage = 20; // 错误的做法，因为message是一个string类型\n注意：这里的string是小写的，和String是有区别的\n\nstring是 TypeScript 中定义的字符串类型，String 是 ECMAScript 中定义的一个类。\n\n\n1.2. 声明变量的关键字在TypeScript定义变量（标识符）和ES6之后一致，可以使用var、let、const来定义：\ntypescriptvar myname: string = &quot;abc&quot;;\nlet myage: number = 20;\nconst myheight: number = 1.88;但是，我们会发现使用var关键字会有一个警告：\n\n\n\n\n\n\n\nWARNING\nForbidden ‘var’keyword,use ‘let’or ‘const’instead\n\n可见，在 TypeScript 中并不建议再使用 var 关键字了，主要原因和 ES6 升级后 let 和 var 的区别是一样的，var是没有块级作用域的，会引起很多的问题。\n所以，在之后的开发中，我们定义变量主要使用 let 和 const。\n1.3. 变量的类型推断在开发中，有时候为了方便起见我们并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过TypeScript本身的特性帮助我们推断出对应的变量类型：\ntypescriptlet message = &quot;Hello World&quot;;上面的代码我们并没有指定类型，但是message实际上依然是一个字符串类型。\n这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型：\n上面的message就是因为后面赋值的是一个string类型，所以message虽然没有明确的说明，但是依然是一个string类型。\n1.4. 声明 name 报错我们在TypeScript的文件中声明一个name（很多其他的名字也会）时，会报错：\n\n主要错误信息：\n无法重新声明块范围变量 name\n我们前面明明（明明说管我什么事）没有声明 name，但是却说我们重复声明了\n\n这次是因为我们的typescript 将 DOM typings 作为全局的运行环境。\n\n所以当我们声明 name时， 与 DOM 中的全局  name 属性出现了重名。\n\n\n\n如何解决这个问题呢？\n\n有两种方案：去掉 DOM typings 的环境和声明模块\n\n方式一：删除DOM typings的环境\n但是这种办法对于我们来说并不合适，因为我们依然希望在DOM下编译我们的TypeScript代码。\n方式二：声明我们的ts文件为一个模块\n既然与全局的变量出现重名，那我们将脚本封装到模块（module）中，因为模块有属于自己的作用域，就不会和全局的产生冲突：\n\n在 Typescript 中，我们可以使用ES6的export来导出一个对象，并且该文件被视为 module\n\ntypescriptlet name = &quot;coderwhy&quot;;export &#123;&#125;;1.5. console.log报错另外为了测试方便我们经常使用console.log来进行测试，但是使用时会报一个警告。\n这个时候，我们可以配置：\ntslint.json\njson&#123;\n    &quot;defaultSeverity&quot;: &quot;error&quot;,\n    &quot;extends&quot;: [\n        &quot;tslint:recommended&quot;\n    ],\n    &quot;jsRules&quot;: &#123;&#125;,\n    &quot;rules&quot;: &#123;\n        &quot;no-console&quot;: false\n    &#125;,\n    &quot;rulesDirectory&quot;: []\n&#125;添加了：\njson&quot;rules&quot;: &#123;\n    &quot;no-console&quot;: false\n&#125;2. JavaScript 数据类型2.1. number类型数字类型是我们开发中经常使用的类型，TypeScript和JavaScript一样，不区分整数类型（int）和浮点型（double），统一为number类型。\ntypescript// 1.数字类型基本定义\nlet num = 100;\nnum = 20;\nnum = 6.66;ES6新增了二进制和八进制的表示方法，而TypeScript也是支持二进制、八进制、十六进制的表示：\ntypescript// 2.其他进制表示  \nnum = 100; // 十进制  \nnum = 0b110; // 二进制  \nnum = 0o555; // 八进制  \nnum = 0xf23; // 十六进制2.2. boolean类型boolean类型只有两个取值：true和false，非常简单\ntypescript// boolean类型的表示\nlet flag: boolean = true;\nflag = false;flag = 20 &gt; 30;2.3. string类型string 类型是字符串类型，可以使用单引号或者双引号表示：\n\n注意：如果打开了 TSLint，默认情况下推荐使用使用双引号\n\ntypescript// string类型表示\nlet message: string = &quot;Hello World&quot;;\nmessage = &#39;Hello TypeScript&#39;;同时也支持ES6的模板字符串来拼接变量和字符串：\ntypescriptconst name = &quot;why&quot;;\nconst age = 18;\nconst height = 1.88;\nconst info = `my name is $&#123;name&#125;, age is $&#123;age&#125;, height is $&#123;height&#125;`;\nconsole.log(info);2.4. array类型数组类型的定义也非常简单，有两种方式：\n\n但是TSLint会推荐我们使用上面这种方式\n\ntypescriptconst names1: string[] = [&quot;why&quot;, &quot;abc&quot;, &quot;cba&quot;];  \nconst names2: Array&lt;string&gt; = [&quot;why&quot;, &quot;abc&quot;, &quot;cba&quot;];2.5. object类型object对象类型可以用于描述一个对象：\ntypescript// object类型表示\nconst myinfo: object = &#123;  \n    name: &quot;why&quot;,  \n    age: 20,  \n    height: 1.88\n&#125;;属性是不可以访问的\n如果我们访问myinfo中的属性，会发现报错：\n\n这是因为TypeScript并不知道某一个object类型上面就有一个name的属性。\n但是如果我们让它是类型推断的写法，就可以正常的访问：\n\n还有一种方法是定义接口，TypeScript一个非常好用的特性就是接口interface。\n2.6. symbol类型在ES5中，如果我们是不可以在对象中添加相同的属性名称的，比如下面的做法：\ntypescriptconst person = &#123;  \n    identity: &quot;程序员&quot;,  \n    identity: &quot;老师&quot;\n&#125;通常我们的做法是定义两个不同的属性名字：比如identity1和identity2。\n但是我们也可以通过symbol来定义相同的名称，因为Symbol函数返回的是不同的值：\ntypescriptconst s1 = Symbol(&quot;identity&quot;);\nconst s2 = Symbol(&quot;identity&quot;);\nconst person = &#123;  \n    [s1]: &quot;程序员&quot;,  \n    [s2]: &quot;老师&quot;\n&#125;;2.7. null和undefined在 JavaScript 中，undefined 和 null 是两个基本数据类型。\n在TypeScript中，它们各自的类型也是undefined和null，也就意味着它们既是实际的值，也是自己的类型：\ntypescriptconst n: null = null;\nconst u: undefined = undefined;3. TypeScript 引入的数据类型TypeScript 在原有的 JavaScript 基础上引入了很多好用的类型：enum 枚举类型、tuple 元组类型、any 类型、void 类型、never 类型等。\n3.1. enum 类型3.1.1. 枚举的基本定义枚举类型在很多语言都有的类型，比如C++、Java等等，并且也非常好用，所以TypeScript引入了enum类型，让我们开发更好的方便和安全。\n枚举类型通常是定义一组数据：\ntypescriptenum Direction &#123;\n    EAST,\n    WEST,\n    NORTH,\n    SOUTH\n&#125;\n\nconst d1 = Direction.EAST\nconst d2 = Direction.NORTH3.1.2. 枚举类型的值枚举类型有自己的值，比如打印上面的d1和d2\ntypescriptconsole.log(d1)\nconsole.log(d2)bash------ 控制台 ------\n0\n2默认情况下，枚举中的数据是从0开始的，我们可以改变它的初始化值，比如下面的代码：\ntypescriptenum Direction &#123;  \n    EAST = 10,  \n    WEST,  \n    NORTH,  \n    SOUTH\n&#125;  \n  \nconst d1 = Direction.EAST;  \nconst d2 = Direction.NORTH;  \n  \nconsole.log(d1); // 10  \nconsole.log(d2); // 12也可以全部自己来指定：\ntypescriptenum Direction &#123;  \n    EAST = 10,  \n    WEST = 20,  \n    NORTH = 30,  \n    SOUTH = 40\n&#125;  \n  \nconst d1 = Direction.EAST;  \nconst d2 = Direction.NORTH;  \n  \nconsole.log(d1); // 10  \nconsole.log(d2); // 30我们也可以通过对应的值去获取对应的数据名称：\ntypescriptconsole.log(Direction[10]); // EAST  \nconsole.log(Direction[30]); // NORTH3.2. tuple 类型3.2.1. tuple的基本使用tuple是元组类型，很多语言中也有这种数据类型，比如Python、Swift等。\ntypescriptconst tInfo: [string, number, number] = [&quot;why&quot;, 18, 1.88];  \nconst item1 = tInfo[0]; // why, 并且知道类型是string类型  \nconst item2 = tInfo[1]; // 18, 并且知道类型是number类型3.2.1. tuple 和数组类比初学 tuple 会觉得它和数组非常相似\n但是数组中通常会定义一组相同的数据，如果数据不同会造成类型的丢失：\ntypescriptconst aInfo: Array&lt;string|number&gt; = [&quot;why&quot;, 18, 1.88];  \nconst itema = aInfo[0]; // why，但是并不知道itema是string类型还是number类型3.3. any类型在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用any类型（类似于Dart语言中的dynamic类型）\ntypescriptlet a: any = &quot;why&quot;;a = 123;a = true;const aArray: any[] = [&quot;why&quot;, 18, 1.88];3.4. void类型void 类型通常用于函数没有返回值时来使用：\n在 TypeScript 中函数也是有类型的\n下面的函数，虽然我们没有指定它的类型，但是它会通过类型推导出来：\ntypescriptconst sum = (num1: number, num2: number) =&gt; &#123;  \nreturn num1 + num2;  \n&#125;;  \n  \n// 相当于下面的写法  \nconst sum: (num1: number, num2: number) =&gt;number = (num1: number, num2: number) =&gt; &#123;  \nreturn num1 + num2;  \n&#125;;\n3.5. never类型never类型表示一种从来不会存在的值的类型，有点绕，我们来这样理解：\n如果一个函数中是一个死循环，那么这个函数会返回东西吗？不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型。\n\n如果一个函数是抛出一个异常，那么这个函数是不是也没有返回值呢？这个时候我们也可以使用never类型。\n\n结语学如逆水行舟，不进则退\n\n谢谢款待\n2023 09 08\n","slug":"TypeScript【三】定义变量和数据类型","date":"2023-09-08T02:34:03.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"},{"id":"8341e59134e12dac24934a69216cde75","title":"TypeScript【二】使用Webpack搭建环境","content":"前言学习任何的开发，我们都需要对应的环境：包括TypeScript的编译环境和开发工具。\n我们就来完成它们的搭建，后续就可以愉快的来写TypeScript代码了。\n1. 环境搭建1.1. TypeScript环境安装TypeScript最终会被编译成JavaScript代码：\n\n那么我们必然需要对应的编译环境：\n安装命令\nbashnpm install typescript -g查看版本\nbashtsc --version1.2. tsc简单代码测试打开VSCode，并且新建一个个文件：index.ts\nindex.ts 代码如下：\ntypescript// 定义一个变量\nlet message: string = &quot;abc&quot;\nmessage = 123\n\n// 定义一个函数\nfunction sum(num1: number, num2: number): number &#123;\n    return num1 + num2\n&#125;\n\nsum(&quot;abc&quot;, &quot;cba&quot;)我们会发现有两个地方都会报错：\n错误一：不能将类型 “123” 分配给类型 “string”\n\n错误二：类型 “abc” 的参数不能赋给类型 “number” 的参数\n\n上面两个错误都是因为我们的代码已经增加了类型约束，不能随便赋值其他类型给我们的变量。\n将代码修改正确如下：\ntypescript// 定义一个变量  \nlet message: string = &quot;abc&quot;;  \nmessage = &quot;Hello World&quot;;  \n  \n// 定义一个函数  \nfunction sum(num1: number, num2: number): number &#123;  \n    return num1 + num2;  \n&#125;  \n  \nsum(20, 30);将代码编译为JavaScript的代码\nbashtsc index.ts\n我们会发现，生成了一个index.js文件，并且其中的代码就是普通的JavaScript代码。\n问题：每次都这样测试会不会太麻烦了呢？\n如果每次我们写完一个TypeScript代码都需要像上面的步骤一样，一点点去完成测试就会过于麻烦，我们可以怎么做呢？\n\n直接配置webpack，让webpack对我们编写的代码进行一个编译，并且自动引入编译后的js文件。\n\n而且webpack可以在代码修改后重新帮助我们进行编译，并且自动刷新浏览器，不需要手动操作。\n\n\n2. 项目环境2.1. 项目环境的基础配置为了之后的学习和使用方便，可以配置一个webpack的环境。\n配置目的：\n在环境中我们编写对应的TypeScript代码，让webpack自动帮助我们编译，并且在浏览器中查看结果。\n注意：\n这里需要对npm和webpack有一些简单的了解，不会非常复杂。\n2.1.1. 创建一个简单的项目目录结构新建一个新的目录：LearnTypeScript，并且创建如下的目录结构\nbash|- index.html\n|- build\n|  - webpack.config.js\n|- src\n|  - main.ts目录和文件夹结构分析:\n\nindex.html 是跑在浏览器上的模块文件\n\nbuild 文件夹中用于存放webpack的配置信息\n\nsrc 用于存放我们之后编写的所有TypeScript代码\n\n\n2.1.2. 使用npm管理项目的依赖webpack 本身需要有很多的依赖，并且之后我们也需要启动 node 服务来快速浏览 index.html 模板以及编译后的 JavaScript 代码。\n我们要使用 npm 来初始化 package.json 文件：\nbashnpm init -y2.1.3. 本地依赖 TypeScript为什么需要本地依赖 TypeScript ?\n\n因为我们之后是通过webpack进行编译我们的TypeScript代码的，并不是通过tsc来完成的。（tsc使用的是全局安装的TypeScript依赖）\n那么webpack会在本地去查找TypeScript的依赖，所以我们是需要本地依赖TypeScript的；\n\n安装本地TypeScript依赖\nbashnpm install typescript2.1.4. 初始化 tsconfig.json 文件在进行 TypeScript 开发时，我们会针对 TypeScript 进行相关的配置，而这些配置信息是存放在一个 tsconfig.json 文件中的。\n我们并不需要手动去创建它，可以通过命令行直接来生成这样的一个文件：\nbashtsc --init2.1.5. 配置 tslint 来约束代码为了按照严格的 TypeScript 风格学习代码，这里可以加入 tslint\n全局安装tslint：\nbashnpm install tslint -g在项目中初始化tslint的配置文件：tslint.json\nbashtslint -i2.2. 项目环境的Webpack下面我们开始配置webpack相关的内容\n2.2.1. 安装 webpack 相关的依赖使用 webpack 开发和打开：\n需要依赖 webpack、webpack-cli、webpack-dev-server\nbashnpm install webpack webpack-cli webpack-dev-server -D2.2.2. 在 package.json 中添加启动命令为了方便启动 webpack，我们在 package.json 中添加如下启动命令\nbash&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;serve&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --mode=development --config build/webpack.config.js&quot;\n&#125;2.2.3. 添加 webpack 的其他相关依赖依赖一 ：cross-env\n这里我们用到一个插件 cross-env ，这个插件的作用是可以在 webpack.config.js 中通过 process.env.NODE_ENV 来获取当前是开发还是生产环境，我们需要这个插件：cross-env\nbashnpm install cross-env -D依赖二 ：ts-loader\n因为我们需要解析.ts文件，所以需要依赖对应的loader：ts-loader\nbashnpm install ts-loader -D依赖三 ：html-webpack-plugin\n编译后的代码需要对应的 html 模块作为它的运行环境，所以我们需要使用 html-webpack-plugin 来将它插入到对应的模板中：\nbashnpm install html-webpack-plugin -D2.2.4. 配置 webpack.config.js 文件将如下配置到webpack.config.js文件中：\njavascriptconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);\n\nconst path = require(&quot;path&quot;);\n\nmodule.exports = &#123;\n  entry: &quot;./src/main.ts&quot;,\n  output: &#123;\n    filename: &quot;build.js&quot;\n  &#125;,\n  resolve: &#123;\n    extensions: [&quot;.tsx&quot;, &quot;.ts&quot;, &quot;.js&quot;]\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.tsx?$/,\n        use: &quot;ts-loader&quot;,\n        exclude: /node_modules/\n      &#125;\n    ]\n  &#125;,\n  devtool: process.env.NODE_ENV === &quot;production&quot; ? false : &quot;inline-source-map&quot;,\n  devServer: &#123;\n    static: &#123;\n      directory: path.resolve(__dirname, &#39;dist&#39;)\n    &#125;,\n    client: &#123;\n      logging: &#39;error&#39;\n    &#125;,\n    compress: false,\n    host: &quot;localhost&quot;,\n    port: 8080\n  &#125;,\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      template: &quot;./index.html&quot;\n    &#125;)\n  ]\n&#125;;2.3. 项目环境下代码测试下面我们就可以愉快的在main.ts中编写代码，之后只需要启动服务即可：\ntypescriptlet message: string = &quot;Hello World&quot;\nconsole.log(message)在终端中启动服务：\nbashnpm run serve之后修改代码，直接可以看到修改后的效果，不需要手动进行任何刷新。\n结语学如逆水行舟，不进则退\n\n谢谢款待\n2023 09 07\n","slug":"TypeScript【二】使用Webpack搭建环境","date":"2023-09-07T03:12:26.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"},{"id":"fe45d9911f5fa4623963bc931676390e","title":"TypeScript【一】TypeScript培养类型思维","content":"前言 当你点开这篇文章时，我相信你已经在很多地方都已经听说过或者见过 TypeScript 了。\n 但是可能对 TypeScript 依然有很多问号：TypeScript 到底是什么？\n 为什么每个人都在说 TypeScript 怎么怎么好，到底好在哪里？\n Angular、Vue3 接连使用 TypeScript 进行了重构是否意味着我们必须掌握 TypeScript，它们又为什么要选择TypeScript ？\n 我需要什么样的基础才能学会或者说学好TypeScript呢？没有关系，在这个章节中我们就来解答上面的疑惑，并且我希望大家学完这个章节可以对一个概念有深入的理解，就是 类型思维。\n 不着急，下面就让我们和TypeScript有一场美丽的邂逅。\n1. JavaScript 的痛点\n\n\n\n\n\n\n\n\n我始终坚信：任何新技术的出现都是为了解决之前某个技术的痛点。\n1.1. 优秀的JavaScriptJavaScript是一门优秀的编程语言吗？\n每个人可能观点并不完全一致，但是从很多角度来看，JavaScript是一门非常优秀的编程语言。\n而且，可以说在很长一段时间内这个语言不会被代替，并且会在更多的领域被大家广泛使用。\n著名的Atwood定律是什么？\n\n\n\n\n\n\n\n\n\nany application that can be written in JavaScript, will eventually be written in JavaScript.\n“任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现。”\nStack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 Atwood定律。\n其实我们已经看到了，至少目前JavaScript在浏览器端依然无可替代，并且在服务端（Nodejs）也在被广泛的应用。\n优秀的JavaScript没有缺点吗？\n\n其实上由于各种历史因素，JavaScript语言本身存在很多的缺点；\n\n比如ES5以及之前的使用的var关键字关于作用域的问题；\n\n比如最初JavaScript设计的数组类型并不是连续的内存空间；\n\n比如直到今天JavaScript也没有加入类型检测这一机制；\n\n\nJavaScript正在慢慢变好吗？\n\n不可否认的是，JavaScript正在慢慢变得越来越好，无论是从底层设计还是应用层面。\n\nES6、7、8等的推出，每次都会让这门语言更加现代、更加安全、更加方便。\n\n但是知道今天，JavaScript在类型检测上依然是毫无进展。\n\n\n1.2. 类型引发的问题首先你需要知道，编程开发中我们有一个共识：错误出现的越早越好\n\n能在写代码的时候发现错误，就不要在代码编译时再发现（IDE的优势就是在代码编写过程中帮助我们发现错误）。\n\n能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测就可以很好的帮助我们做到这一点）。\n\n能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。\n\n\n现在我们想探究的就是如何在 代码编译期间 发现代码的错误\nJavaScript可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题。\njavascriptfunction getLength(str) &#123;\n    return str.length\n&#125;\n\nconsole.log(&quot;1.正在代码执行&quot;)\nconsole.log(&quot;2.开始函数&quot;)\ngetLength(&quot;abc&quot;)\ngetLength()\nconsole.log(&quot;3.调用结束&quot;)bash----- 控制台 -----\n1.正在代码执行\n2.开始函数\nTypeError: Cannot read properties of undefined (reading &#39;length&#39;)如上是我们一个非常常见的错误：\n\n这个错误很大的原因就是因为JavaScript没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个错误。\n\n并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而陷入崩溃。\n\n\n当然，你可能会想：我怎么可能犯这样低级的错误呢？\n\n当我们写像我们上面这样的简单的demo时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来。\n\n但是当我们开发一个大型项目时呢？你能保证自己一定不会出现这样的问题吗？而且如果我们是调用别人的类库，又如何知道让我们传入的到底是什么样的参数呢？\n\n\n但是，如果我们可以给JavaScript加上很多限制，在开发中就可以很好的避免这样的问题了：\n\n比如我们的getLength函数中str是一个必传的类型，没有调用者没有传编译期间就会报错。\n\n比如我们要求它的必须是一个String类型，传入其他类型就直接报错。\n\n那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改。\n\n\n1.3. 类型思维的缺失我们已经简单体会到没有类型检查带来的一些问题，JavaScript因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于类型思维的缺失：\n\n前端开发人员通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证。\n\n从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮。\n\n\n所以我们经常会说JavaScript不适合开发大型项目，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患，多人员开发它们之间也没有良好的类型契约：\n\n比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性。\n\n比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型。\n\n\n为了弥补JavaScript类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：\n\n2014年，Facebook推出了flow来对JavaScript进行类型检查\n\n同年，Microsoft微软也推出了TypeScript1.0版本\n\n他们都致力于为JavaScript提供类型检查\n\n\n而现在，无疑TypeScript已经完全胜出：\n\nVue2.x的时候采用的就是flow来做类型检查。\n\nVue3.x已经全线转向TypeScript，98.3%使用TypeScript进行了重构。\n\n而Angular在很早期就使用TypeScript进行了项目重构并且需要使用TypeScript来进行开发。\n\n而甚至Facebook公司一些自己的产品也在使用TypeScript。\n\n\n学习TypeScript不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。\n2. 邂逅 TypeScript2.1. 什么是 TypeScript ?虽然我们已经知道TypeScript是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下TypeScript到底是什么？\n\nTypeScript 在 GitHub 和官方上对自己的定义\n\nGitHub说法：\n\nTypeScript is a superset of JavaScript that compiles to clean JavaScript output.  \n\nTypeScript官网：\n\nTypeScript is a typed superset of JavaScript that compiles to plain JavaScript.  \n翻译一下：TypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码。\n\n\n\n怎么理解上面的话呢？\n我们可以将TypeScript理解成加强版的JavaScript。\ntxtJavaScript所拥有的特性，TypeScript全部都是支持的，并且它紧随ECMAScript的标准，所以ES6、ES7、ES8等新语法标准，它都是支持的。\n\n并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等。\n\nTypeScript在实现新特性的同时，总是保持和ES标准的同步甚至是领先。\n\n并且TypeScript最终会被编译成JavaScript代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于Babel这样的工具。所以，我们可以把TypeScript理解成一身神装的JavaScript，不仅让JavaScript更加安全，而且给它带来了诸多好用的装备特效。\n官方对TypeScript有几段特点的描述，我觉得非常到位（虽然有些官方，了解一下），我们一起来分享一下：\n始于JavaScript，归于JavaScript\n\nTypeScript从今天数以百万计的JavaScript开发者所熟悉的语法和语义开始。使用现有的JavaScript代码，包括流行的JavaScript库，并从JavaScript代码中调用TypeScript代码。\n\nTypeScript可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持ECMAScript 3（或更高版本）的JavaScript引擎中。\n\n\nTypeScript是一个强大的工具，用于构建大型项目\n\n类型允许JavaScript开发者在开发JavaScript应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有JavaScript库的行为。\n\n\n拥有先进的 JavaScript\n\nTypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的ECMAScript3（或更新版本）的JavaScript。\n\n\n正是因为有这些特性，TypeScript目前已经在很多地方被应用：\n\n包括我们前面提到的Vue3和Angular已经使用TypeScript进行重构\n包括Vue3以后的开发模式必然会和TypeScript更加切合，大家也更多的需要使用TypeScript来编写代码\n包括目前已经变成最流行的编辑器VSCode也是使用TypeScript来完成的\n包括在React中已经使用的ant-design的UI库，也大量使用TypeScript来编写\n包括小程序开发，也是支持TypeScript的\n\n3. 前端学不动系列3.1. 前端开发者的难大前端是一群最能或者说最需要折腾的开发者：\n\n客户端开发者：从Android到iOS，或者从iOS到Android，到RN，甚至现在越来越多的客户端开发者接触前端相关知识（Vue、React、Angular、小程序）\n\n前端开发者：从jQuery到AngularJS，到三大框架并行：Vue、React、Angular，还有小程序，甚至现在也要接触客户端开发（比如RN、Flutter）\n\n目前又面临着不仅仅学习ES的特性，还要学习TypeScript\n\nVue3马上也会到来，又必须学习Vue3新特性\n\n\n大前端开发就是，不像服务器一样可能几年甚至几十年还是那一套的东西。前端新技术会层出不穷。\n但是每一样技术的出现都会让惊喜，因为他必然是解决了之前技术的某一个痛点的，而TypeScript真是解决了JavaScript存在的很多设计缺陷，尤其是关于类型检测的。\n并且从开发者长远的角度来看，学习TypeScript有助于我们前端程序员培养 类型思维，这种思维方式对于完成大型项目尤为重要。\n结语学如逆水行舟，不进则退。\n\n谢谢款待\n2023 09 06\n","slug":"TypeScript【一】TypeScript培养类型思维","date":"2023-09-06T04:00:00.000Z","categories_index":"TypeScript","tags_index":"TypeScript 入门","author_index":"一小池勺"}]