---
title: 尚品汇项目复盘
date: 2024-02-14 23:16:21
tags:
  - 项目
categories:
  - 尚品汇项目
cover: https://pic.imgdb.cn/item/65cb36a29f345e8d03b81368.jpg
---
# Home 模块开发 1 — 33

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/002d7619e991404585369072ef9e61e2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c96f2f471b3a46d596e59ff2878d0bb4.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/80eac14753f7408ea3a61e8ff64e9f23.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b11f2e91b1dd4ba1a3445ffbc8facc2b.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9ba11da6959c495394814193c6930cde.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9dfcb28710d0443f86837f59def2dece.png)

# 项目收获
## 1. 读懂项目文件

尚品汇是一个基于 vue-cli 脚手架搭建的项目，项目文件目录如下：

```bash
- node_modules文件夹：项目依赖文件夹
- public文件夹：一般是用于放置一些静态资源（图片），需要注意的是，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动打包到dist文件夹中
- scr文件夹：源代码文件夹
	- assets文件夹：一般也是放置静态资源（一般用于放置多个组件共用的静态资源），需要注意的是，放置在 assets 文件夹里面的静态资源，在 webpack 打包的时候， webpack 会把静态资源当作一个模块，打包在JS文件里面
	- components文件夹：放置非路由组件
	- views文件夹：放置路由组件
	- App.vue：唯一的根组件
	- main.js：程序的入口文件，也是整个程序中最先执行的文件
- babel.config.js：配置文件（babel 相关）
- package.json：可以认为是项目的 “身份证”，记录项目叫做什么、项目中有哪些依赖、项目怎么运行。
- package-lock.js：缓存性文件
- vue.config.js：常见的的项目配置代码都是写在这里面，在这里面会对外暴露一个对象【module.exports = {}】
- README.md：项目说明性文件
```

## 2. 如何添加项目的其它配置

### 2.1 配置 1 ：如何使得项目一运行起来，浏览器就自动打开项目

找到 package.json 文件，修改启动命令的代码即可 `"serve": "vue-cli-service serve --open"`

```json
  "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  }
```

### 2.2 配置 2 ：如何关闭 eslint 校验功能

首先，在根目录下，创建一个 vue.config.js 文件

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0f5e010576954622bd7e20f0feb5210d.png)

之后在暴露对象中新定义一个字段就可以了

```js
module.exports = {
   // 关闭 eslint
   lintOnSave: false
}
```

### 2.3 配置 3 ：如何为 src 文件夹配置别名


为什么要为 src 配置别名呢？

如果项目一旦复杂起来，【 `../ ` 】【 `./` 】【 `../../ ` 】 的访问方式写起来一点都不方便，此时我们规定 src 的别名就为 @ ，配置别名 @ 就可以让项目中的文件互相依赖时导入更加方便了，这样意思就是 “直接在 @ 文件下去寻找依赖文件了”。

在项目根目录下找到 jsconfig.js 文件，编写如下代码

```js
{
    "compilerOptions": {
        "baseUrl": "./",
        "paths": {
            "@/*": [
                "src/*"
            ]
        }
    }
}
```

## 3. 如何做大体路由分析

路由好比就是 key 与 value 的匹配，key 也即是浏览器窗口的那个地址，value 其实就是页面所呈现出来的效果。那么我们该如何去基于需求做一个大体的路由拆分呢？

咱们看看项目预览【本地跑，咱们就把它当作以后工作后的一个原型就可以了】：


[video(video-awNXCI7x-1705210190295)(type-csdn)(url-https://live.csdn.net/v/embed/359580)(image-https://live-file.csdnimg.cn/release/live/file/1705208853362.png?x-oss-process=image/resize,l_300)(title-)]


在大体上，我们可以做如下拆分：

路由组件：

+ Home 首页路由组件
+ Search 搜索页路由组件
+ login 登录页路由组件
+ Refister 注册页路由组件

非路由组件：

+ Header 头部组件【出现的位置：首页、搜索页】
+ Footer 底部组件【出现的位置：首页、搜索页 未出现：在登录 | 注册页面没有出现】

## 4. 清除css全局默认样式

### 4.1 安装插件

```bash
yarn add reset-css
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/19d52d3597cc4bbabfa0ed210a0cda9e.png)

### 4.2 然后于程序入口文件 main.js 中引入

```bash
import 'reset-css' // 清除全局默认样式
```

### 4.3 或者使用如下的样式重置文件

```css
@import "./iconfont.css";

/* 清除内外边距 */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote,
dl, dt, dd, ul, ol, li,
pre,
fieldset, lengend, button, input, textarea,
th, td {
    margin: 0;
    padding: 0;
}

/* 设置默认字体 */
body,
button, input, select, textarea { /* for ie */
    /*font: 12px/1 Tahoma, Helvetica, Arial, "宋体", sans-serif;*/
    font: 12px/1.3 "Microsoft YaHei",Tahoma, Helvetica, Arial, "\5b8b\4f53", sans-serif; /* 用 ascii 字符表示，使得在任何编码下都无问题 */
    color: #333;
}


h1 { font-size: 18px; /* 18px / 12px = 1.5 */ }
h2 { font-size: 16px; }
h3 { font-size: 14px; }
h4, h5, h6 { font-size: 100%; }

address, cite, dfn, em, var, i{ font-style: normal; } /* 将斜体扶正 */
b, strong{ font-weight: normal; } /* 将粗体扶细 */
code, kbd, pre, samp, tt { font-family: "Courier New", Courier, monospace; } /* 统一等宽字体 */
small { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */

/* 重置列表元素 */
ul, ol { list-style: none; }

/* 重置文本格式元素 */
a { text-decoration: none; color: #666;}


/* 重置表单元素 */
legend { color: #000; } /* for ie6 */
fieldset, img { border: none; }
button, input, select, textarea {
    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */
}

/* 重置表格元素 */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

/* 重置 hr */
hr {
    border: none;
    height: 1px;
}
.clearFix::after{
	content:"";
	display: block;
	clear:both;
}
/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */
html { overflow-y: scroll; }

a:link:hover{
    color : rgb(79, 76, 212) !important;
    text-decoration: underline;
}

/* 清除浮动 */
.clearfix::after {
    display: block;
    height: 0;
    content: "";
    clear: both;
    visibility: hidden;
}
```

## 5. 完成非路由组件 Header 、Footer

### 5.1 新建组件

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cd3d1b6703a64e3190a7684dc663ae5f.png)

Footer.vue

```bash
<template>
  <div class="footer">
    <div class="footer-container">
        <div class="footerList">
            <div class="footerItem">
                <h4>购物指南</h4>
                <ul class="footerItemCon">
                    <li>购物流程</li>
                    <li>会员介绍</li>
                    <li>生活旅行/团购</li>
                    <li>常见问题</li>
                    <li>购物指南</li>
                </ul>
            </div>
            <div class="footerItem">
                <h4>配送方式</h4>
                <ul class="footerItemCon">
                    <li>上门自提</li>
                    <li>211限时达</li>
                    <li>配送服务查询</li>
                    <li>配送费收取标准</li>
                    <li>海外配送</li>
                </ul>
            </div>
            <div class="footerItem">
                <h4>支付方式</h4>
                <ul class="footerItemCon">
                    <li>货到付款</li>
                    <li>在线支付</li>
                    <li>分期付款</li>
                    <li>邮局汇款</li>
                    <li>公司转账</li>
                </ul>
            </div>
            <div class="footerItem">
                <h4>售后服务</h4>
                <ul class="footerItemCon">
                    <li>售后政策</li>
                    <li>价格保护</li>
                    <li>退款说明</li>
                    <li>返修/退换货</li>
                    <li>取消订单</li>
                </ul>
            </div>
            <div class="footerItem">
                <h4>特色服务</h4>
                <ul class="footerItemCon">
                    <li>夺宝岛</li>
                    <li>DIY装机</li>
                    <li>延保服务</li>
                    <li>尚品汇E卡</li>
                    <li>尚品汇通信</li>
                </ul>
            </div>
            <div class="footerItem">
                <h4>帮助中心</h4>
                <img src="./images/wx_cz.jpg">
            </div>
        </div>
        <div class="copyright">
            <ul class="helpLink">
                <li>关于我们
                    <span class="space"></span>
                </li>
                <li>联系我们
                    <span class="space"></span>
                </li>
                <li>关于我们
                    <span class="space"></span>
                </li>
                <li>商家入驻
                    <span class="space"></span>
                </li>
                <li>营销中心
                    <span class="space"></span>
                </li>
                <li>友情链接
                    <span class="space"></span>
                </li>
                <li>关于我们
                    <span class="space"></span>
                </li>
                <li>营销中心
                    <span class="space"></span>
                </li>
                <li>友情链接
                    <span class="space"></span>
                </li>
                <li>关于我们</li>
            </ul>
            <p>地址：北京市昌平区宏福科技园综合楼6层</p>
            <p>京ICP备19006430号</p>
        </div>
    </div>
</div>
</template>

<script>
export default {
  name: 'ShangFooter'
}
</script>

<style scoped lang="less">
@import url('./Footer.less');
</style>
```

Header.vue

```bash
<template>
  <header class="header">
      <!-- 头部的第一行 -->
      <div class="top">
          <div class="container">
              <div class="loginList">
                  <p>尚品汇欢迎您！</p>
                  <p>
                      <span>请</span>
                      <a href="###">登录</a>
                      <a href="###" class="register">免费注册</a>
                  </p>
              </div>
              <div class="typeList">
                  <a href="###">我的订单</a>
                  <a href="###">我的购物车</a>
                  <a href="###">我的尚品汇</a>
                  <a href="###">尚品汇会员</a>
                  <a href="###">企业采购</a>
                  <a href="###">关注尚品汇</a>
                  <a href="###">合作招商</a>
                  <a href="###">商家后台</a>
              </div>
          </div>
      </div>
      <!--头部第二行 搜索区域-->
      <div class="bottom">
          <h1 class="logoArea">
              <a class="logo" title="尚品汇" href="###" target="_blank">
                  <img src="./images/logo.png" alt="">
              </a>
          </h1>
          <div class="searchArea">
              <form action="###" class="searchForm">
                  <input type="text" id="autocomplete" class="input-error input-xxlarge" />
                  <button class="sui-btn btn-xlarge btn-danger" type="button">搜索</button>
              </form>
          </div>
      </div>
  </header>
</template>

<script>
export default {
  name: 'ShangHeader'
}
</script>

<style scoped lang="less">
@import url('./Header.less');
</style>

```

### 5.2 于 App.vue 注册使用

```bash
<template>
  <div id="app">
    <!-- 头部 -->
    <ShangHeader></ShangHeader>
    <!-- 底部 -->
    <ShangFooter></ShangFooter>
  </div>
</template>

<script>
import ShangHeader from '@/components/Header'
import ShangFooter from '@/components/Footer'
export default {
  data () {
    return {}
  },
  components: {
    ShangHeader,
    ShangFooter
  }
}
</script>

<style>

</style>
```

## 6. 路由组件的搭建

### 6.1 新建 views 文件夹，初步建立路由组件

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e1d4bbc55ccd4084bed3147fe1a6f041.png)

### 6.2 新建 router 文件夹，初步配置路由规则

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cd48f6b67ac34852ae619927d7e95a27.png)
index.js

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import routes from './routes' // 导入路由规则

Vue.use(VueRouter) // 使用路由插件

const router = new VueRouter({
  routes
})

export default router
```

routes.js

```js
export default [
  // 一级路由重定向
  {
    path: '/',
    redirect: '/home'
  },
  {
    path: '/home',
    component: () => import('@/views/Home')
  },
  {
    path: '/search',
    component: () => import('@/views/Search')
  },
  {
    path: '/login',
    component: () => import('@/views/Login')
  },
  {
    path: '/register',
    component: () => import('@/views/Register')
  }
]
```

### 6.3 于 main.js 中挂载路由

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'

new Vue({
  router,
  render: h => h(App)
}).$mount('#app')
```

注册完路由，不管是路由组件还是非路由组件，组件身上都有 `$route`、`$router` 属性，尤其是 `$route` 属性，可以使得我们的开发更加灵活。

#### 6.3.1 $route

一般获取路由信息

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/38e0079c2c274e628465019cea2e8ba3.png)


#### 6.3.2 $router

一般进行编程式导航进行路由跳转 【push | replace | go】，当然这只是路由跳转的一种方式，路由跳转还有一种形式是声明式导航 `<router-link />` ，声明式导航能做的，编程式导航都能做，但是编程式导航除了可以进行路由的跳转，其还能够完成一些其它的**业务逻辑**。如果只是简单的跳转，而没有什么业务逻辑，声明式导航足矣。

举一个例子：

当前的这个登录页面，用户点击登录，我们要做这样的一个业务逻辑，就是我们要从后台确定用户账号密码是否正确后完成登录跳转，进入携程首页，这里就可以用到编程式导航。

还是当前这个页面，用户点击免费注册，就跳转到用户注册页面，这里就没有处理逻辑，用 router-link 声明式导航即可。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f6a173cffa4c40708852776caa0b6a2c.png)
在该项目中的非路由组件 Header 中就体现了这一点

+ 点击 Logo 跳转首页
+ 点击登录 跳转登录页
+ 点击注册 跳转注册页
+ 点击搜索按钮，我们需要携带用户的搜索信息进行跳转

```bash
<template>
  <header class="header">
      <!-- 头部的第一行 -->
      <div class="top">
          <div class="container">
              <div class="loginList">
                  <p>尚品汇欢迎您！</p>
                  <p>
                      <span>请</span>
                      <router-link to="/login" href="###">登录</router-link>
                      <router-link to="/register" class="register">免费注册</router-link>
                  </p>
              </div>
              <div class="typeList">
                  <a href="###">我的订单</a>
                  <a href="###">我的购物车</a>
                  <a href="###">我的尚品汇</a>
                  <a href="###">尚品汇会员</a>
                  <a href="###">企业采购</a>
                  <a href="###">关注尚品汇</a>
                  <a href="###">合作招商</a>
                  <a href="###">商家后台</a>
              </div>
          </div>
      </div>
      <!--头部第二行 搜索区域-->
      <div class="bottom">
          <h1 class="logoArea">
              <router-link class="logo" to="home">
                  <img src="./images/logo.png" alt="">
              </router-link>
          </h1>
          <div class="searchArea">
              <form action="###" class="searchForm">
                  <input type="text" id="autocomplete" class="input-error input-xxlarge" />
                  <button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">搜索</button>
              </form>
          </div>
      </div>
  </header>
</template>

<script>
export default {
  name: 'ShangHeader',
  methods: {
  	// 得到用户搜索的内容进行跳转
    goSearch () {
      this.$router.push('/search')
    }
  }
}
</script>
```

### 6.4 确定路由出口

根组件 App.vue

```html
<template>
  <div id="app">
    <!-- 头部 -->
    <ShangHeader></ShangHeader>
    <!-- 一级路由出口 -->
    <router-view></router-view>
    <!-- 底部 -->
    <ShangFooter></ShangFooter>
  </div>
</template>

<script>
import ShangHeader from '@/components/Header'
import ShangFooter from '@/components/Footer'
export default {
  data () {
    return {}
  },
  components: {
    ShangHeader,
    ShangFooter
  }
}
</script>

<style>

</style>
```

## 7. 路由元信息之底部公用组件 Footer 的显示与隐藏

我们在配置路由规则时，可以为其添加 meta 配置项，如下就是通过 meta 配置项中添加变量来控制 Footer 组件是否显示

router.js

```js
export default [
  // 一级路由重定向
  {
    path: '/',
    redirect: '/home'
  },
  {
    path: '/home',
    component: () => import('@/views/Home'),
    meta: { show: true }
  },
  {
    path: '/search',
    component: () => import('@/views/Search'),
    meta: { show: true }
  },
  {
    path: '/login',
    component: () => import('@/views/Login'),
    meta: { show: false }
  },
  {
    path: '/register',
    component: () => import('@/views/Register'),
    meta: { show: false }
  }
]
```

App.vue

```html
<template>
  <div id="app">
    <!-- 头部 -->
    <ShangHeader></ShangHeader>
    <!-- 一级路由出口 -->
    <router-view></router-view>
    <!-- 底部 -->
    <ShangFooter v-if="$route.meta.show"></ShangFooter>
  </div>
</template>
```

## 8. 路由传参小结

首先，路由跳转有两种方式，比如由 A 跳转至 B，可以通过声明式导航来实现，也可以通过编程式导航来实现，其中声明式导航使用 router-link 【务必要有 to 属性】，编程式导航利用的式组件实例的 $router.push | replace 方法【可以有业务逻辑】


接着，路由传参，其参数有两种类型

+ params参数：属于路径当中的一部分  【 https://editor.csdn.net/`id` 】，但是要注意的是，在配置路由的时候，是需要占位的。
+  query参数：不属于路径当中的一部分【https://editor.csdn.net/md/`?articleId=135579592&spm=1001.2014.3001.9457` 】

最后，路由传递参数的时候，可以有如下的一些方式

+ 字符串形式

```bash
<div> params 参数 {{ $route.params.keyword }} </div> 
<div> query 参数 {{ $route.query.k }} </div>
export default {
   name: "ShangHome",
   data() {
      return {
      	keyword: "abc"
      }
   },
   methods: {
   	  go() {
   	  	this.$router.push("/search" + this.keyword + "?k=" + this.keyword.toUpperCase() // 同时传递 params 参数 、 query 参数
   	  }
   }
}
```

注意，存在 params 参数，配置路由的时候需要进行占位

```js
  {
    path: '/search',
    component: () => import('@/views/Search/:keywords'),
    meta: { show: true }
  }
```

+ 模板字符串形式

```js
this.$router.push(`/search/${this.keyword}?k={this.keyword.toUpperCase()}`)
```

+ 对象形式【⭐⭐⭐⭐⭐】

如果是使用了对象形式来进行路由的跳转传参，且携带了 params 参数，不可以使用 path（路径） 的形式跳转，得用如下的 name 的形式，这是就需要在配置项中给该路由命名。

```js
 {
   path: '/search',
   component: () => import('@/views/Search'),
   meta: { show: true },
   name: 'search'
 }
```

```js
this.$router.push({ name: "search", params: {keyword: this.keyword}, query: {k: this.keyword.roUpperCase()} })
```

## 9. 路由传参相关面试题

### 9.1 路由传递参数（对象写法）path 是否可以结合 params 参数一起使用?

路由跳转传参的时候，对象的写法可以是 name、path 形式，但是需要注意，path 这种写法不能与 params 参数一起使用。

```js
this.$router.push({ path:'/search' }, params: { keyword: this.keyword }, query: { k:this.keyword.toUpperCase() })
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/81ceb78f7d3e4f1b804cf0f2d68c6974.png)

### 9.2 如何指定 params 参数可传可不传？

```js
{
  path: '/search/:keyword',
  component: () => import('@/views/Search'),
  meta: { show: true },
  name: 'search'
}
```

```js
goSearch () {
  this.$router.push({ name: 'search', query: { k: this.keyword.toUpperCase() } })
}
```
我们在配置路由的时候，已经占位了（params参数），但是在路由跳转时不传递，此时路径就会出现如下的问题：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cfb0a73c8fc2437d8b5844def0aa9db8.png)

http://localhost:8080/#/?k=ABC

我们预期的效果是，即使用户不传递 params 参数，路径效果也是如下：

http://localhost:8080/#/search?k=ABC

那么如何指定 params 参数可以传递，或者不传递呢？其实很简单，就是在配置路由的时候，在占位的后面加上一个问号【 `?` 代表params 可以传递或者不传递】

### 9.3 已经指定 params 参数可以传递也可以不传递，但是如果传递是空串，该如何解决？

可以使用 undefined 来解决

```js
this.$router.push({ path:'/search' }, params: { keyword: '' || undefined }, query: { k:this.keyword.toUpperCase() })
```

### 9.4 路由组件能不能传递 props 数据？

路由组件可以传递 props

有如下 `3` 种写法

1. 布尔值【该传递方法只能传递 params 参数】

配置 search 路由组件时，新增配置字段 `props: true `

```js
{
  path: '/search/:keyword?',
  component: () => import('@/views/Search'),
  meta: { show: true },
  name: 'search',
  props: true
}
```

在 search 路由组件中声明接收

```js
props: ['keyword']
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f78b7d1e5e7a42fda00c43c47fc4f323.png)
这样就可以更方便地使用 params 参数了，而不用 `$route.params.keword`。

2. 对象写法【==额外地给当前路由组件传递一些参数==】

```js
{
  path: '/search/:keyword?',
  component: () => import('@/views/Search'),
  meta: { show: true },
  name: 'search',
  props: { a: 1, b: 2 }
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ee8a2411b8904ec7bd809f71b4b57b1d.png)

3. 函数写法

既可以传递 `params` 参数、也可以传递 `query` 参数，然后通过 `props` 传递给路由组件

```js
{
  path: '/search/:keyword?',
  component: () => import('@/views/Search'),
  meta: { show: true },
  name: 'search',
  props: ($route) => {
    return { keyword: $route.params.keyword, k: $route.query.k }
  }
}
```

## 10. 解决编程式路由跳转到当前路由抛出 NavigationDuplicated 的警告错误
 
路由跳转有两种方式【编程式导航】【声明式导航】，当使用声明式导航时没有这类报错问题，是因为 vue-router 的底层已经将这个问题处理好了，但是使用编程式导航的时候，就会存在这个问题。

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import routes from './routes' // 导入路由规则
Vue.use(VueRouter) // 使用路由插件

// 备份VueRouter.prototype原有的push|replace方法
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace
// 重写VueRouter.prototype的push方法
VueRouter.prototype.push = function (location, resolve, reject) {
  // 函数对象的apply与call的区别?
  // 相同点:都可以改变函数的上下文一次，而且函数会立即执行一次
  // 不同：函数执行的时候，传递参数不同，apply需要的是数组，call传递参数的时候用逗号隔开
  // 原始的push方法可以进行路由跳转，但是需要保证上下文this是VueRouter类的实例
  // 第一种情况：外部在使用push的时候传递成功与失败的回调
  if (resolve && reject) {
    originPush.call(this, location, resolve, reject)
  } else {
    // 第二种情况：外部在使用push方法的时候没有传递成功与失败的回调函数
    originPush.call(this, location, () => { }, () => { })
  }
}
// 重写VueRouter.prototype.replace方法
VueRouter.prototype.replace = function (location, resolve, reject) {
  (resolve && reject) ? originReplace.call(this, location, resolve, reject) : originReplace.call(this, location, () => { }, () => { })
}
const router = new VueRouter({
  // 配置路由
  routes
})

export default router
```

## 11. Home 模块组件初步拆分

三级联动组件、轮播图组件：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e7e7129d5ac5450c8ec6e06a50ad8d0f.png)

今日推荐组件：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a2a0eae630ce49aca77901770790941d.png)

热卖排行组件：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5bbb23034f7241178ad443b68d18a5d7.png)

猜你喜欢组件：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bae9b23ebc53452f996e66b15be97f3c.png)
封装一个复用组件：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c78918dad2c144eea8fafc4ab7493947.png)

Logo展示组件：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ce27c2d39f394bc88a53384cb4da6753.png)

## 12. 完成 Home 模块的静态结构拼装
### 12.1 将三级联动区域注册为全局组件

由于该三级联动组件在多个模块内都是有使用的，所以考虑将其注册为一个全局组件进行使用。好处就是只需要注册一次，就可以在项目的任意位置使用了。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bd20ee9b11234c7db16defbace0b684f.png)
于 App.vue 中注册为全局组件

```js
import TypeNav from '@/components/TypeNav'
// 第一个参数：全局组件名 第二个参数：哪一个组件
Vue.component(TypeNav.name, TypeNav)
```

### 12.2 完成剩余的组件

+ 三级联动组件、轮播图组件
+ 今日推荐组件
+ 热卖排行组件
+ 猜你喜欢组件
+ 猜你喜欢组件
+ Logo展示组件

## 13. axios 二次封装

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6f2b9a7ae3d347df9bc46dbdb82ac79d.png)


为什么要进行 axios 的二次封装呢？主要是为了一件很重要的事，就是请求拦截器和响应拦截器的配置

+ 请求拦截器：发起请求之前处理一些业务
+ 响应拦截器：数据返回之后，可以处理一些业务

如下是一个初步的封装：

```js
// 对于 axios 进行二次封装
import axios from 'axios'

// 1. 利用 axios 对象的方法 create, 去创建一个 axios 实例
let request = axios.create({
    // create 里面实际就是一个配置对象
    // 基础路径，发起网络请求时，路径中会出现 api
    baseURL: "/api",
    // 代表请求超时的时间
    timeout: 5000
})
// 2. 请求拦截器：在发请求之前，请求拦截器可以检测到，可以在请求发出去之前做一些事情
request.interceptors.request.use((config) => {
	// config：配置对象，对象里面有一个属性很重要，headers请求头
	return config
})
// 3. 响应拦截器
request.interceptors.response.use((res) => {
	// 成功的回调函数：服务器响应数据回来之后，响应拦截器可以检测到，可以做一些处理
},(error) => {
	// 响应失败的回调函数
	return Promise.reject(new Error('faile'))
})
```

## 14. 接口统一管理

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8fb80d4cbc354981924c936dd008886c.png)


项目变大之后我们最好将接口进行统一的管理

```js
import request from '@/utils/request'

// 三级联动接口
export const reqCategoryList = () => request({ url: '/product/getBaseCategoryList', method: 'get' })
```

## 15. 代理解决跨域问题

> 跨域的解决方案：JSONP、CROS、代理

vue.config.js

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  // 代理服务器
  devServer: {
    proxy: {
      '/api': {
        target: 'http://gmall-h5-api.atguigu.cn'
      }
    }
  }
})
```

## 16. nprogress进度条的使用

我们的这个进度条在该项目的使用场景是可以在用户发起网络请求的时候就将其利用到。因此可以将该进度条到请求、响应拦截器上去使用。

安装

```bash
yarn add 
```

进度条使用

```js
import axios from 'axios'
// 引入进度条
import nprogress from 'nprogress'
// start 进度条开始
// done 进度条结束
// 引入进度条的样式
import 'nprogress/nprogress.css'
const request = axios.create({
  baseURL: '/api',
  timeout: 5000
})
request.interceptors.request.use((config) => {
  // 进度条开始动
  nprogress.start()
  return config
})
request.interceptors.response.use((res) => {
  // 进度条结束
  nprogress.start()
  console.log(res)
}, (error) => {
  console.log(error)
  return Promise.reject(new Error('faile'))
})

```
## 17. Vuex模块式开发

并不是全部的项目都会要使用到 Vuex，如果项目很小，完全就不需要使用 Vuex，如果项目很大，组件很多，那么对应的数据也很多，维护起来就很费劲了，这个时候可以考虑使用到 Vuex 这个插件。

Vuex 有几个十分核心的概念：
+ state：仓库存储数据的地方
+ mutations：修改 state 的唯一手段
+ actions：书写业务逻辑、也可以处理异步
+ getters：理解为一个计算属性，用于简化仓库数据，让组件获取仓库数据更加方便
+ modules：模块化管理数据 

尚品汇这个项目就用到了 Vuex 插件来对项目的数据进行维护。本项目属于一个中等大小的项目，该项目的组件很多，而且其接口也很多，数据也很多，因此采用 Vuex 的模块化开发，将大仓库拆分为很多个小仓库，每一个小仓库独立管理其对应的数据。

如下是一个简单的模块化的示例：

建立并初始化小仓库

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/eab4b0700edd4788ab3dc4e507fb5fe9.png)
index.js

```js
const state = {}
const mutations = {}
const actions = {}
const getters = {}

export default {
  state,
  mutations,
  actions,
  getters
}
```

导入小仓库

```js
import Vue from 'vue'
import Vuex from 'vuex'
// 引入小仓库
import home from './home'
import search from './search'
Vue.use(Vuex)

export default new Vuex.Store({
  modules: {
    home,
    search
  }
})
```

来看到开发者工具：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ba4d513888514e53a245d0e4099bfea8.png)

这样，便是模块式进行开发，各个模块独立起来了。

## 18. 三级联动的数据请求

结构

```bash
<template>
  <div class="type-nav">
      <div class="container">
          <h2 class="all">全部商品分类</h2>
          <nav class="nav">
              <a href="###">服装城</a>
              <a href="###">美妆馆</a>
              <a href="###">尚品汇超市</a>
              <a href="###">全球购</a>
              <a href="###">闪购</a>
              <a href="###">团购</a>
              <a href="###">有趣</a>
              <a href="###">秒杀</a>
          </nav>
          <div class="sort">
              <div class="all-sort-list2">
                  <div class="item" v-for="(item1, index1) in categoryList" :key="index1">
                      <h3>
                          <a href="">{{ item1.categoryName }}</a>
                      </h3>
                      <div class="item-list clearfix">
                          <div class="subitem" v-for="(item2, index2) in item1.categoryChild" :key="index2">
                              <dl class="fore">
                                  <dt>
                                      <a href="">{{ item2.categoryName }}</a>
                                  </dt>
                                  <dd>
                                      <em v-for="(item3, index3) in item2.categoryChild" :key="index3">
                                          <a href="">{{ item3.categoryName }}</a>
                                      </em>
                                  </dd>
                              </dl>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
      </div>
  </div>
</template>
```

返回的数据

```bash
[
   categoryName
   Array() -childern数组
   [
   		categoryName
   		Array() -childern数组
   		[
   			categoryName
   			Array() -childern数组
   			[]
   		]
   ]
]
```

## 19. 完成一级分类动态添加背景颜色
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ec70277b6f094a26a08edcb24d56393b.gif)

## 20. 卡顿现象
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/171cb9c8fc84496a8c353772716f38bd.png)
+ 正常情况【用户操作很慢】: 鼠标进入，每一个一级分类h3，都会触发鼠标进入事件
+ 非正常情况【用户操作很快】:本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分h3触发，就是由于用户行为过快，导致浏览器反应不过来。如果当前回识函数中有一些大量业务，可能出现卡顿现象。
## 21. 函数的节流与防抖 

为了解决上面的问题，就要引入函数的`节流`与`防抖`

+ 防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发只会执行一次。

+ 节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。

### 21.1 函数防抖的理解

> 前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发只会执行一次。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    请输入：<input type="text">
    <script>
        let input = document.querySelector('input')
        input.oninput = function() {
            console.log('触发搜索的请求')
        }
    </script>
</body>
</html>
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5d4c1c8a72744522b20201dc64739733.gif)
我们可以看见，只要输入框有文本变化，就会触发回调发起网络请求。

现在我们cdn引入 lodash 库：

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
```

lodash这个函数库对外暴露 `_函数`，我们打印一下：

```js
console.log(_)
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/94c5fab5b33f46e39ef4ed47c5a54908.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/dab86b250bb44dd899af810521e4af98.png)

现在我们看到官方文档，看一看其封装的防抖函数该如何调用

[中文文档传送门【_.debounce 函数】](https://www.lodashjs.com/docs/lodash.debounce)

> _.debounce(func, [wait=0], [options=])

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/09b9e20c6d544bc0b9978bc725b2271f.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>
<body>
    请输入：<input type="text">
    <script>
        let input = document.querySelector('input')
        input.oninput = function() {
            console.log('触发搜索的请求')
        }
        let result = _.debounce(function(){

        }, 1000)
        console.log(result)
    </script>
</body>
</html>
```

在控制台，我们看到了返回了一个防抖动函数

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bd01855f66e74258865722e67f1e5183.png)

那么这个防抖函数该如何使用呢？

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>
<body>
    请输入：<input type="text">
    <script>
        let input = document.querySelector('input')
        input.oninput = _.debounce(function() {
        	console.log('发起请求')
        }, 1000)
    </script>
</body>
</html>
```

来，咱们现在来观察，当前的这个请求就在用户停止了最后一次操作后在规定的时间后发起的，这样就比每次输入框有变化就发起请求而言更加合理了：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2159660515de4940b9d768e30fab0168.gif)
### 21.2 函数节流的理解

> 节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。

就比如当前的这个计数器，我只要点击，就会进行自增，但是我目前要的效果是在 3 秒内无论触发多少次，它的结果只能加一，也即是只触发一次。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>
<body>
    <h2>我是计数器<span>0</span></h2>
    <button>点击我+1</button>
    <script>
        let span = document.querySelector('span')
        let btn = document.querySelector('button')
        let count = 0
        btn.onclick = function() {
            count++
            span.innerText = count
        }
    </script>
</body>
</html>
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f44d92269366497183151c74a56b4c3f.gif)

那么我们可以使用节流来进行实现

> _.throttle(func, [wait=0], [options=])

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/39415c0dc43448db83ec477a4a5ef128.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>
<body>
    <h2>我是计数器<span>0</span></h2>
    <button>点击我+1</button>
    <script>
        let span = document.querySelector('span')
        let btn = document.querySelector('button')
        let count = 0
        btn.onclick = _.throttle(function() {
            count++
            span.innerHTML = count
        }, 3000)
    </script>
</body>
</html>
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a160134562f34d62a624d127f76cb7b3.gif)

如上就实现了，在 3 秒内，无论用户触发多少次，在 3 秒内就自增 1，目前这个回调 3 s 执行一次，假如我们这有更多的其它业务，这样我们就可以给浏览器很充裕的时间去解析。

### 21.3 对节流与防抖做一个区别

防抖：用户操作操作很频繁，只执行最后一次操作

节流：用户操作很频繁，但是可以把频繁的操作变为少量的操作【可以给浏览器足够的时间去解析，比如一个轮播图，用户频繁点击，但是我们规定 1 s 内只会执行一次回调，也就是这样，假如在 10s 内，用户他点击了轮播按钮100次，这10s，也只是执行了10次】

## 22. 对三级联动进行节流

```js
import throttle from 'lodash/throttle'

 changeIndex: throttle(function (index) {
   this.currentIndex = index
 }, 50)
```

## 23. 三级联动组件的路由跳转与传递参数

> 三级联动用户可以点击的：一级分类、二级分类、三级分类，当你点击的时候，`Home` 模块跳转到 `Search` 模块，会把用户选中的产品(`产品的名字`、`产品的ID`)在路由跳转的时候，进行传递。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/22cd1d2f1ded4881a58d8157b4b8d350.gif)

这里有一个使用 声明式导航的踩坑点，就是如果使用 `router-link` 来进行跳转的话，会出现卡顿的情况，这是因为每一个 `router-link` 都是是一个组件实例，这个三级导航每次切换的时候，都需要渲染多个组件实例，因此会出现卡顿的现象。因此使用编程式导航会更好。


最好的解决方案是：编程式导航 + 事件委派

但是其也存在一些问题：

+ 事件委派是将全部的子节点【h3、dt、dl、em】的事件委派给父亲节点。
+ 点击相应的div标签才会跳转，那怎么确定点击的是可以跳转的 div 标签
+ 即使能确定点击的是需要跳转的 div 标签，那如何区分是一级、二级、三级分类呢

```js
<template>
  <div class="type-nav">
      <div class="container">
        <div @mouseleave="leaveIndex">
          <h2 class="all">全部商品分类</h2>
          <div class="sort">
              <div class="all-sort-list2" @click="goSearch">
                  <div class="item" v-for="(item1, index1) in categoryList" :key="index1" :class="{cur: currentIndex === index1}">
                      <h3 @mouseenter="changeIndex(index1)">
                          <div :data-categoryName="item1.categoryName" :data-category1Id="item1.categoryId">{{ item1.categoryName }}</div>
                      </h3>
                      <div class="item-list clearfix" :style="{display: currentIndex === index1 ? 'block' : 'none'}">
                          <div class="subitem" v-for="(item2, index2) in item1.categoryChild" :key="index2">
                              <dl class="fore">
                                  <dt>
                                      <div :data-categoryName="item2.categoryName" :data-category2Id="item2.categoryId">{{ item2.categoryName }}</div>
                                  </dt>
                                  <dd>
                                      <em v-for="(item3, index3) in item2.categoryChild" :key="index3">
                                          <div :data-categoryName="item3.categoryName" :data-category3Id="item3.categoryId">{{ item3.categoryName }}</div>
                                      </em>
                                  </dd>
                              </dl>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
        </div>
          <nav class="nav">
              <a href="###">服装城</a>
              <a href="###">美妆馆</a>
              <a href="###">尚品汇超市</a>
              <a href="###">全球购</a>
              <a href="###">闪购</a>
              <a href="###">团购</a>
              <a href="###">有趣</a>
              <a href="###">秒杀</a>
          </nav>
      </div>
  </div>
</template>

<script>
import { mapState } from 'vuex'
import throttle from 'lodash/throttle'
export default {
  name: 'TypeNav',
  data () {
    return {
      currentIndex: null
    }
  },
  mounted () {
    this.$store.dispatch('home/getCategoryList')
  },
  computed: {
    ...mapState({
      categoryList: state => state.home.categoryList.slice(0, 16)
    })
  },
  methods: {
    changeIndex: throttle(function (index) {
      this.currentIndex = index
    }, 50),
    leaveIndex () {
      this.currentIndex = -1
    },
    goSearch (event) {
      this.$router.push('/search')
      const Element = event.target
      const { categoryname, category1id, category2id, category3id } = Element.dataset
      if (categoryname) {
        // 整理路由跳转的参数
        const location = { name: 'search' }
        const query = { categoryName: categoryname }
        if (category1id) {
          query.category1id = category1id
        } else if (category2id) {
          query.category2id = category2id
        } else {
          query.category3id = category3id
        }
        location.query = query
        this.$router.push(location)
      }
    }
  }
}
</script>

<style>
@import url('./TypeNav.less');
</style>

```
## 24. 开发 Search 模块中的 TypeNav

在 Home 模块中，鼠标进入【全部商品分类】，不会出现三级选项卡，在进入 Search 模块后，鼠标进入【全部商品分类】，会出现三级选项卡，如图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/147ce690c6a942b3b307339f3baab99b.gif)
我们的解决方案其实也可以像 ` Footer ` 的显示隐藏一样，使用路由的元信息 `meta`来实现，但是这里我们可以用另外一种解决方式，引入一个响应式的变量 `show` ，每当进入 `Search` 模块后，`TypeNav` 组件实际上又进进入一个新的生命周期进行挂载渲染，此时我们对该响应式变量做出修改便可以了。  

```bash
<template>
  <div class="type-nav">
      <div class="container">
        <!-- 鼠标移入移出事件 -->
        <div @mouseleave="leaveShow" @mouseenter="enterShow">
          <h2 class="all">全部商品分类</h2>
            <div class="sort" v-show="show">
              <div class="all-sort-list2" @click="goSearch">
                <!-- 一级分类 -->
                  <div class="item" v-for="(item1, index1) in categoryList" :key="index1" :class="{cur: currentIndex === index1}">
                      <h3 @mouseenter="changeIndex(index1)">
                          <!-- 一级分类名称 -->
                          <div :data-categoryName="item1.categoryName" :data-category1Id="item1.categoryId">{{ item1.categoryName }}</div>
                      </h3>
                      <div class="item-list clearfix" :style="{display: currentIndex === index1 ? 'block' : 'none'}">
                          <!-- 二级分类 -->
                          <div class="subitem" v-for="(item2, index2) in item1.categoryChild" :key="index2">
                              <dl class="fore">
                                  <dt>
                                      <!-- 二级分类名称 -->
                                      <div :data-categoryName="item2.categoryName" :data-category2Id="item2.categoryId">{{ item2.categoryName }}</div>
                                  </dt>
                                  <dd>
                                      <!-- 三级分类 -->
                                      <em v-for="(item3, index3) in item2.categoryChild" :key="index3">
                                          <!-- 三级分类名称 -->
                                          <div :data-categoryName="item3.categoryName" :data-category3Id="item3.categoryId">{{ item3.categoryName }}</div>
                                      </em>
                                  </dd>
                              </dl>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
        </div>
          <!-- 导航链接 -->
          <nav class="nav">
              <a href="###">服装城</a>
              <a href="###">美妆馆</a>
              <a href="###">尚品汇超市</a>
              <a href="###">全球购</a>
              <a href="###">闪购</a>
              <a href="###">团购</a>
              <a href="###">有趣</a>
              <a href="###">秒杀</a>
          </nav>
      </div>
  </div>
</template>

<script>
import { mapState } from 'vuex'
import throttle from 'lodash/throttle'
export default {
  name: 'TypeNav',
  data () {
    return {
      currentIndex: null, // 当前选中的一级分类索引
      show: true // 是否显示二三级分类
    }
  },
  mounted () {
    this.$store.dispatch('home/getCategoryList') // 获取分类列表数据
    if (this.$route.name === 'search') {
      this.show = false // 在搜索页面隐藏二三级分类
    }
  },
  computed: {
    ...mapState({
      categoryList: state => state.home.categoryList.slice(0, 16) // 获取分类列表的前16个数据
    })
  },
  methods: {
    // 鼠标进入每一个一级分类，进行二三级分类的显示
    changeIndex: throttle(function (index) {
      this.currentIndex = index // 设置当前选中的一级分类索引
    }, 50),
    // 点击一二三级分类，进行路由跳转并携带参数
    goSearch (event) {
      this.$router.push('/search') // 跳转到搜索页面
      const Element = event.target
      const { categoryname, category1id, category2id, category3id } = Element.dataset
      if (categoryname) {
        // 整理路由跳转的参数
        const location = { name: 'search' }
        const query = { categoryName: categoryname }
        if (category1id) {
          query.category1id = category1id
        } else if (category2id) {
          query.category2id = category2id
        } else {
          query.category3id = category3id
        }
        location.query = query
        this.$router.push(location)
      }
    },
    // 鼠标移入的时候让商品分类列表进行展示
    enterShow () {
      this.show = true
    },
    leaveShow () {
      // 鼠标离开整个大的盒子后，二三级才会隐藏
      this.currentIndex = -1 // 重置当前选中的一级分类索引
      if (this.$route.name === 'search') {
        this.show = false // 在搜索页面隐藏二三级分类
      }
    }
  }
}
</script>

<style>
@import url('./TypeNav.less');
</style>
```

## 25. 关于这个 TypeNav 发起数据请求的一个优化点

可以看到，这个三级分类派发的数据的获取的网络请求是写在了 TypeNav 组件内，那么每次我们加载这个组件的时候，都会向服务器发起网络请求，那么我们其实可以在`根组件`发起一次网络请求到 `Vuex` 进行管理就可以了，之后不管路由如何跳转，根组件都只会加载一次，因此可以到根组件的 `mounted` 派发 `action` 就可以了。 

```html
<template>
  <div id="app">
    <!-- 头部 -->
    <ShangHeader></ShangHeader>
    <!-- 一级路由出口 -->
    <router-view></router-view>
    <!-- 底部 -->
    <ShangFooter v-if="$route.meta.show"></ShangFooter>
  </div>
</template>

<script>
import ShangHeader from '@/components/Header'
import ShangFooter from '@/components/Footer'
export default {
  data () {
    return {}
  },
  components: {
    ShangHeader,
    ShangFooter
  },
  mounted () {
    this.$store.dispatch('home/getCategoryList') // 获取TypeNav分类列表数据
  }
}
</script>

<style>

</style>
```

## 26. 关于 params 参数与 query 参数的合并

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/162adbfdd1584fad93cc8375484d6b2e.png)

如上，点击搜索以及点击三级分类的分类名进行跳转时都会携带参数进行跳转，因此我们需要在 Header 组件、TypeNav 组件内做好条件判断来做好 `params` 参数与 `query` 参数的合并。

Header 组件内

```js
goSearch () {
  if (this.$route.query) {
    this.$router.push({ name: 'search', params: { keyword: this.keyword }, query: this.$route.query })
  } else {
	this.$router.push({ name: 'search', params: { keyword: this.keyword } })
	}
}
```

TypeNav 组件内

```js
goSearch (event) {
  const Element = event.target
  const { categoryname, category1id, category2id, category3id } = Element.dataset
  if (categoryname) {
    // 整理路由跳转的参数
    const location = { name: 'search' }
    const query = { categoryName: categoryname }
    if (category1id) {
      query.category1Id = category1id
    } else if (category2id) {
      query.category2Id = category2id
    } else {
      query.category3Id = category3id
    }
    // 如果此时也有 params 参数,那么也将 params 参数携带过去
    if (this.$route.params) {
      location.params = this.$route.params
      location.query = query
      this.$router.push(location)
    } else {
      this.$router.push(location)
    }
  }
}
```

## 27. 使用 Mock.js 插件模拟一些接口

### 27.1 什么是 Mock.js 插件？

[如何使用 Mock.js 来模拟接口](https://blog.csdn.net/zrblue/article/details/135174578)

假如现在后台没有写好这两个模块的接口，这时候，我们就可以使用 `Mock.js` 来模拟这两个模块的接口了。

什么是 `Mock`，我们这样来理解

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3fbf8cee93854d709e3f928380e695f5.png)
生成数据我们知道，那啥是拦截 `Ajax` 请求呢？

我们利用这个插件，不会向服务器发请求，会被拦截到，只要把这个 Mock 返回的数据当作真实数据就可以了。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/baf7010a1f71469b8d4b459ac61f0a5f.png)

### 27.2 webpack 默认对外暴露的模块有哪些？

`图片`、`JSON数据格式`

### 27.3 Mock 实战

#### 27.3.1 初始化配置

安装插件

```bash
yarn add mockjs
```

src 下新建 Mock 文件夹

`Mock` / `index.js`

```js
// 通过mockjs模块实现模拟数据
// 对外暴露的是一个对象
import Mock from 'mockjs'
// 模拟的数据需要引入进来
// 我们最好是封装成方法 将数据  return 出来
import HomeData from './HomeData.js'

// 通过Mock对象模拟出虚拟数据
// Mock依赖包对外暴露的是一个Mock对象，这个对象提供的一个mock方法可以模拟数据
// 参数一：接口地址
// 参数二：接口/请求类型 默认 get
// 参数三：数据处理函数
// 注意:【到时候后端写好后台接口后，我们就可以去除 Mock】
// 第一种: 真实服务器接口 http://39.98.123.211/api/list/xx
// 第二种: mock出来数据接口 xxx/mock/banner
Mock.mock('/mock/banner', 'get', HomeData.getBanner())
Mock.mock('/mock/floor', 'get', HomeData.getFloor())
```

`Mock` / `HomeData.js`

```bash
const bannerList = [
  {
    id: '1',
    imgUrl: '/images/banner1.jpg'
  },
  {
    id: '2',
    imgUrl: '/images/banner2.jpg'
  },
  {
    id: '3',
    imgUrl: '/images/banner3.jpg'
  },
  {
    id: '4',
    imgUrl: '/images/banner4.jpg'
  }
]
const floorList = [
  {
    id: '001',
    name: '家用电器',
    keywords: [
      '节能补贴',
      '4K电视',
      '空气净化器',
      'IH电饭煲',
      '滚筒洗衣机',
      '电热水器'
    ],
    imgUrl: '/images/floor-1-1.png',
    navList: [
      {
        url: '#',
        text: '热门'
      },
      {
        url: '#',
        text: '大家电'
      },
      {
        url: '#',
        text: '生活电器'
      },
      {
        url: '#',
        text: '厨房电器'
      },
      {
        url: '#',
        text: '应季电器'
      },
      {
        url: '#',
        text: '空气/净水'
      },
      {
        url: '#',
        text: '高端电器'
      }
    ],
    carouselList: [
      {
        id: '0011',
        imgUrl: '/images/floor-1-b01.png'
      },
      {
        id: '0012',
        imgUrl: '/images/floor-1-b02.png'
      },
      {
        id: '0013',
        imgUrl: '/images/floor-1-b03.png'
      }
    ],
    recommendList: [
      '/images/floor-1-2.png',
      '/images/floor-1-3.png',
      '/images/floor-1-5.png',
      '/images/floor-1-6.png'
    ],
    bigImg: '/images/floor-1-4.png'
  },
  {
    id: '002',
    name: '手机通讯',
    keywords: [
      '节能补贴2',
      '4K电视2',
      '空气净化器2',
      'IH电饭煲2',
      '滚筒洗衣机2',
      '电热水器2'
    ],
    imgUrl: '/images/floor-1-1.png',
    navList: [
      {
        url: '#',
        text: '热门2'
      },
      {
        url: '#',
        text: '大家电2'
      },
      {
        url: '#',
        text: '生活电器2'
      },
      {
        url: '#',
        text: '厨房电器2'
      },
      {
        url: '#',
        text: '应季电器2'
      },
      {
        url: '#',
        text: '空气/净水2'
      },
      {
        url: '#',
        text: '高端电器2'
      }
    ],
    carouselList: [
      {
        id: '0011',
        imgUrl: '/images/floor-1-b01.png'
      },
      {
        id: '0012',
        imgUrl: '/images/floor-1-b02.png'
      },
      {
        id: '0013',
        imgUrl: '/images/floor-1-b03.png'
      }
    ],
    recommendList: [
      '/images/floor-1-2.png',
      '/images/floor-1-3.png',
      '/images/floor-1-5.png',
      '/images/floor-1-6.png'
    ],
    bigImg: '/images/floor-1-4.png'
  }
]
// 暴露一个对象出去
export default {
  getBannerListData: () => {
    return {
      code: 200,
      data: {
        bannerList
      }
    }
  },
  getFloorListData: () => {
    return {
      code: 200,
      data: {
        floorList
      }
    }
  }
}

```
#### 27.3.2 调用 Mock 数据

`utils` / `MockRequest.js`

二次封装请求 Mock 数据的 axios

```js
// axios进行二次封装
import axios from 'axios'
// 进度条
import nprogress from 'nprogress'
// 因为进度条样式咱们没有引入
import 'nprogress/nprogress.css'
// 创建axios实例[创建出来的实例即为axios，只不过可以配置一些东西]
const instance = axios.create({
  // 可以给请求路径中添加一些参数
  baseURL: '/mock',
  // 设置请求时间（5S）
  timeout: 5000
})

// 请求拦截器:在发请求之前可以检测到，可以干一些事情
instance.interceptors.request.use((config) => {
  // config配置对象，这里面有请求头
  // config，请求拦截器的一个配置对象
  // 检测到程序发请求，请求拦截器可以检测到，进度条开始动
  nprogress.start()
  return config
})

// 响应拦截器：服务器的数据已经返回了，可以干一些事情
instance.interceptors.response.use((res) => {
  // 简化服务器返回的数据格式
  // 服务器数据返回进度条结束
  nprogress.done()
  return res.data
}, (error) => {
  // 终止promise链
  return Promise.reject(error)
})

// 对外暴露二次封装的axios
export default instance
```

`api` / `mockIndex.js`

对 Mock 接口进行统一管理

```js
import instance from '@/utils/MockRequest'

export const reqBannerList = () => instance({ url: 'banner', method: 'get' })
```

Home 模块调用，使得数据存储至 Vuex home 仓库中

`Home` / `ContainerList` / `index.vue`

```js
 mounted () {
 	this.$store.dispatch('/home')
 }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/efee426e13994f38bcb4cd035e80f3d4.png)

## 28. swiper 轮播图

[传送门](https://swiper.com.cn/)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1e416a2037bc4de090928d8590169b92.png)
1. 安装

```bash
yarn add swiper@5
```

2. 导包

在需要使用的组件内导包

```js
import Swiper from 'swiper'
```

这个 Home 模块有多处使用到了 Swiper

因此 Swiper 的样式可以在 main.js 中导入

```js
import "swiper/css/swiper.css"
```

3. 编写结构

```html
<div class="swiper-container" id="mySwiper">
    <div class="swiper-wrapper">
        <div class="swiper-slide" v-for="(item, index) in bannerList" :key="index">
            <img :src="item.imgUrl" />
        </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
</div>
```

4. 创建实例

```js
  mounted () {
    this.$store.dispatch('home/getBannerList')
    const mwSwiper = new Swiper(document.querySelector('.swiper-container'), {
      loop: true,
      // 如果需要分页器
      pagination: {
        el: '.swiper-pagination'
      },
      // 如果需要前后退按钮
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-botton-prev'
      }
    })
    console.log(mwSwiper)
  },
```

这个时候，发现了问题，就是在 new Swiper 创建实例之前，页面的结构必须得要有，而此时这个初始化实例就是在 mounted 【挂载完毕】钩子函数里面的，按理来说，页面结构是会有的，究其原因，是因为存在了动态的数据导致了页面结构不完整

```js
<div class="swiper-slide" v-for="(item, index) in bannerList" :key="index">
    <img :src="item.imgUrl" />
</div>
```

`mounted` 挂载完毕，页面出现结构是没毛病的，但是这个动态的数据要等到服务器返回过来，结构才可以得以渲染，我们如下假如这里的数据是写死的，这该死的效果就出来了

```bash
 <div class="swiper-container" id="mySwiper">
     <div class="swiper-wrapper">
         <div class="swiper-slide">
             <img src="./images/banner1.jpg" />
         </div>
         <div class="swiper-slide">
             <img src="./images/banner2.jpg" />
         </div>
         <div class="swiper-slide">
             <img src="./images/banner3.jpg" />
         </div>
         <div class="swiper-slide">
             <img src="./images/banner4.jpg" />
         </div>
     </div>
     <!-- 如果需要分页器 -->
     <div class="swiper-pagination"></div>

     <!-- 如果需要导航按钮 -->
     <div class="swiper-button-prev"></div>
     <div class="swiper-button-next"></div>
 </div>
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a3c67ff4be3142f5bd3702f2e058fdad.gif)

当 `mounted` 遇到了`异步`、遇到了 `axios` ，那该如何解决这个问题呢？

如下是执行的步骤

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cfe73bb06217400bbabc738e332b2c65.png)


## 29. 解决 Banner 轮播图的第一种方案

换到 `create` 钩子中获取数据就可以了

## 30. 通过 watch + nextTick 解决 Banner 轮播图的问题

[vue.nextTick](https://v2.cn.vuejs.org/v2/api/#Vue-nextTick)

[watch](https://v2.cn.vuejs.org/v2/guide/computed.html)

解决的关键的突破思路就是我们在 watch 中监视了 `bannerList` 属性的变化，但是无法在 `watch` 当中保证 `v-for` 是否将结构渲染完成，因此就引入了 `vue.nextTick` 这个 `API`，这个 API 可以保证页面中的结构一定是有的，其经常和很多插件一起使用【都需要DOM存在了】

```js
  watch: {
    // 监听 BannerList 数据的变化 由 [] 变为 Array(4)
    bannerList: {
      handler (newValue, oldValue) {
        console.log(newValue, oldValue)
        // 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
        Vue.nextTick(() => {
          const mwSwiper = new Swiper(this.$refs.mtSwiper, {
            loop: true,
            // 如果需要分页器
            pagination: {
              el: '.swiper-pagination',
              clickable: true
            },
            // 如果需要前后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-botton-prev'
            }
          })
          console.log(mwSwiper)
        })
      }
    }
  }
```


## 31. 获取 floor 组件的 mock 数据并进行动态展示

结合 `Home` 模块的渲染结构与后台返回的数据结构`【[{},{}]】`，确定派发网络请求 `action` 的位置是 `Home` 组件内，而不是在 `Floor` 组件中派发。这里之后涉及到使用 `props` 进行父子组件通信。

父传

```html
<ShangFloor v-for="(item, index) in floorList" :key="index" :list="item"></ShangFloor>
```

子收

```js
props: ['list']
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fc73af9fce4c4232bfcda203a14dbc18.png)

JSON 数据

```json
const floorList = [
  {
    id: '001',
    name: '家用电器',
    keywords: [
      '节能补贴',
      '4K电视',
      '空气净化器',
      'IH电饭煲',
      '滚筒洗衣机',
      '电热水器'
    ],
    imgUrl: '/images/floor-1-1.png',
    navList: [
      {
        url: '#',
        text: '热门'
      },
      {
        url: '#',
        text: '大家电'
      },
      {
        url: '#',
        text: '生活电器'
      },
      {
        url: '#',
        text: '厨房电器'
      },
      {
        url: '#',
        text: '应季电器'
      },
      {
        url: '#',
        text: '空气/净水'
      },
      {
        url: '#',
        text: '高端电器'
      }
    ],
    carouselList: [
      {
        id: '0011',
        imgUrl: '/images/floor-1-b01.png'
      },
      {
        id: '0012',
        imgUrl: '/images/floor-1-b02.png'
      },
      {
        id: '0013',
        imgUrl: '/images/floor-1-b03.png'
      }
    ],
    recommendList: [
      '/images/floor-1-2.png',
      '/images/floor-1-3.png',
      '/images/floor-1-5.png',
      '/images/floor-1-6.png'
    ],
    bigImg: '/images/floor-1-4.png'
  },
  {
    id: '002',
    name: '手机通讯',
    keywords: [
      '节能补贴2',
      '4K电视2',
      '空气净化器2',
      'IH电饭煲2',
      '滚筒洗衣机2',
      '电热水器2'
    ],
    imgUrl: '/images/floor-1-1.png',
    navList: [
      {
        url: '#',
        text: '热门2'
      },
      {
        url: '#',
        text: '大家电2'
      },
      {
        url: '#',
        text: '生活电器2'
      },
      {
        url: '#',
        text: '厨房电器2'
      },
      {
        url: '#',
        text: '应季电器2'
      },
      {
        url: '#',
        text: '空气/净水2'
      },
      {
        url: '#',
        text: '高端电器2'
      }
    ],
    carouselList: [
      {
        id: '0011',
        imgUrl: '/images/floor-1-b01.png'
      },
      {
        id: '0012',
        imgUrl: '/images/floor-1-b02.png'
      },
      {
        id: '0013',
        imgUrl: '/images/floor-1-b03.png'
      }
    ],
    recommendList: [
      '/images/floor-1-2.png',
      '/images/floor-1-3.png',
      '/images/floor-1-5.png',
      '/images/floor-1-6.png'
    ],
    bigImg: '/images/floor-1-4.png'
  }
]
```

完成渲染

```html
<template>
  <div class="floor">
      <div class="py-container">
        <div class="title clearfix">
          <h3 class="fl">{{ list.name }}</h3>
          <div class="fr">
            <ul class="nav-tabs clearfix">
              <li class="active" v-for="(item, index) in list.navList" :key="index">
                <a :href="item.url" data-toggle="tab">{{ item.text }}</a>
              </li>
            </ul>
          </div>
        </div>
        <div class="tab-content">
          <div class="tab-pane">
            <div class="floor-1">
              <div class="blockgary">
                <ul class="jd-list">
                  <li v-for="(item, index) in list.keywords" :key="index">{{ item }}</li>
                </ul>
                <img :src="list.imgUrl" />
              </div>
              <div class="floorBanner">
                <div class="swiper-container" id="floor1Swiper" ref="cur">
                  <div class="swiper-wrapper">
                    <div class="swiper-slide" v-for="(item, index) in list.carouselList" :key="index">
                      <img :src="item.imgUrl">
                    </div>
                  </div>
                  <!-- 如果需要分页器 -->
                  <div class="swiper-pagination"></div>

                  <!-- 如果需要导航按钮 -->
                  <div class="swiper-button-prev"></div>
                  <div class="swiper-button-next"></div>
                </div>
              </div>
              <div class="split">
                <span class="floor-x-line"></span>
                <div class="floor-conver-pit">
                  <img :src="list.recommendList[0]" />
                </div>
                <div class="floor-conver-pit">
                  <img :src="list.recommendList[1]" />
                </div>
              </div>
              <div class="split center">
                <img :src="list.bigImg" />
              </div>
              <div class="split">
                <span class="floor-x-line"></span>
                <div class="floor-conver-pit">
                  <img :src="list.recommendList[2]" />
                </div>
                <div class="floor-conver-pit">
                  <img :src="list.recommendList[3]" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
  </div>
</template>

<script>
import Swiper from 'swiper'
// import Vue from 'vue'
export default {
  name: 'ShangFloor',
  props: ['list'],
  mounted () {
    const mwSwiper = new Swiper(this.$refs.cur, {
      loop: true,
      // 如果需要分页器
      pagination: {
        el: '.swiper-pagination',
        clickable: true
      },
      // 如果需要前后退按钮
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-botton-prev'
      }
    })
    console.log(mwSwiper)
  }
}
</script>
```

## 32. floor 组件中的轮播图

这里可以直接在 `mounted` 生命周期函数中获取，因为 `floor` 的轮播图的数据是从父组件`home` 中发过来的，且网络请求已经在父组件中派发完了，因此，`floor` 组件在 `new Swiper` 之前，页面结构已经是完整的了。 

```js
  mounted () {
    const mwSwiper = new Swiper(this.$refs.cur, {
      loop: true,
      // 如果需要分页器
      pagination: {
        el: '.swiper-pagination',
        clickable: true
      },
      // 如果需要前后退按钮
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-botton-prev'
      }
    })
    console.log(mwSwiper)
  }
```


## 33. 将 Home 模块中的轮播图拆分为一个全局共用组件

在 Home 首页模块中，我们可以看到这里轮播图在多处使用，且结构都是一样的，功能也是一样的，因此将其封装为一个全局组件。

但是在拆分的过程中，可以看到这两处使用组件的模板方法是有些不同的，那么如何解决这个问题呢 ？

因此为了这次的组件拆分，我们使得这两处的方法写的是基本一致的：

然后拆分为一个全局组件如下：

`ShangCarousel.vue`

```js
<template>
  <div class="floorBanner">
    <div class="swiper-container" id="floor1Swiper" ref="cur">
      <div class="swiper-wrapper">
        <div class="swiper-slide" v-for="(item, index) in list" :key="index">
          <img :src="item.imgUrl">
        </div>
      </div>
      <!-- 如果需要分页器 -->
      <div class="swiper-pagination"></div>

      <!-- 如果需要导航按钮 -->
      <div class="swiper-button-prev"></div>
      <div class="swiper-button-next"></div>
    </div>
  </div>
</template>

<script>
import Swiper from 'swiper'
export default {
  name: 'ShangCarousel',
  props: ['list'],
  watch: {
    list: {
      // 开启立即监听
      immediate: true,
      handler () {
        this.$nextTick(() => {
          const mwSwiper = new Swiper(this.$refs.cur, {
            loop: true,
            // 如果需要分页器
            pagination: {
              el: '.swiper-pagination',
              clickable: true
            },
            // 如果需要前后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-botton-prev'
            }
          })
          console.log(mwSwiper)
        })
      }
    }
  }
}
</script>

<style>

</style>
```

使用该组件：

`Home.vue`

```html
<ShangCarousel :list="bannerList" />
```

`Floor.vue`

```html
<ShangCarousel :list="list.carouselList" />
```

## 34. Search 模块静态组件的拆分及发起网络请求进行动态渲染
### 34.1 静态组件的拆分

+ 面包屑
+ 子组件
+ 商品详情
	+ 价格结构
	+ 销售产品列表
+ 分页器

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c858a7c134ff4fd3a3f84a6463569552.png)

### 34.2 VUEX `3` 连环拿到数据、存储数据

在仓库中声明对应的 `state`、`mutations`、`actions`

```js
import { reqGetSearchInfo } from '@/api'
const state = {
  searchList: {}
}
const mutations = {
  GETSEARCHLIST (state, data) {
    state.searchList = data
  }
}
const actions = {
  // 获取 search 模块的数据
  async getSearchList ({ commit }, params = {}) {
    const res = await reqGetSearchInfo(params)
    console.log(res)
    if (res.code === 200) {
      commit('GETSEARCHLIST', res.data)
    }
  }
}
// 计算属性
// getters 在项目中主要是为了简化仓库中的数据而生 => 将来组件在获取数据的时候就更加方便
const getters = {
  goodsList (state) {
    // state 是当前仓库的 state 并非大仓库的 state
    // 这里如果用户网络不好，还没得到数据，就返回一个空数组，不然就是 undefined 了
    return state.searchList.goodsList || []
  },
  trademarkList (state) {
    return state.searchList.trademarkList || []
  },
  attrsList (state) {
    return state.searchList.attrsList || []
  }
}

export default {
  namespaced: true,
  state,
  mutations,
  actions,
  getters
}

```

于组件中派发 action

```js
import { mapGetters } from 'vuex'
export default {
  name: 'ShangSearch',
  mounted () {
    this.$store.dispatch('search/getSearchList')
  },
  computed: {
    ...mapGetters('search', {
      goodsList: 'goodsList',
      trademarkList: 'trademarkList',
      attrsList: 'attrsList'

    })
  }
}
```
### 34.3 子组件动态展示数据

```html
<template>
  <div class="clearfix selector">
    <div class="type-wrap logo">
      <div class="fl key brand">品牌</div>
      <div class="value logos">
        <ul class="logo-list">
          <li v-for="(item, index) in trademarkList" :key="index">{{ item.tmName }}</li>
        </ul>
      </div>
      <div class="ext">
        <a href="javascript:void(0);" class="sui-btn">多选</a>
        <a href="javascript:void(0);">更多</a>
      </div>
    </div>
    <div class="type-wrap" v-for="(item, index) in attrsList" :key="index">
      <div class="fl key">{{ item.attrName }}</div>
      <div class="fl value">
        <ul class="type-list">
          <li v-for="(item, index) in item.attrValueList" :key="index">
            <a>{{ item }}</a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex'
export default {
  name: 'SearchSelector',
  computed: {
    ...mapGetters('search', {
      trademarkList: 'trademarkList',
      attrsList: 'attrsList'
    })
  }
}
</script>
```

### 34.4 发请求之前进行的参数整理

> 由于该接口可以根据接收参数的的不同，来干很多件事情，因此有必要对该接口做一个参数的整理。

```js
import SearchSelector from './SearchSelector/SearchSelector'
import { mapGetters } from 'vuex'
export default {
  name: 'ShangSearch',
  data () {
    return {
      // 携带给服务器的参数
      searchParams: {
        // 一级分类 id
        category1Id: '',
        // 二级分类 id
        category2Id: '',
        // 三级分类 id
        category3Id: '',
        // 用户选中的分类名
        categoryName: '',
        // 用户搜索携带的关键字
        keyword: '',
        // 排序
        order: '',
        // 分页器参数
        pageNo: 1, // 第几页
        pageSize: 3, // 每一个的展示的数量
        // 平台售卖属性操作携带的参数
        props: [],
        // 品牌
        trademark: ''
      }
    }
  },
  components: {
    SearchSelector
  },
  beforeMount () {
    // 在发起请求之前，将参数进行整理
    const query = this.$route.query
    const params = this.$route.params
    Object.assign(this.searchParams, query, params)
  },
  mounted () {
    this.getData()
  },
  computed: {
    ...mapGetters('search', {
      goodsList: 'goodsList'
    })
  },
  methods: {
    // 将该请求封装为一个函数
    getData () {
      this.$store.dispatch('search/getSearchList', this.searchParams)
    }
  }
}
```
## 35. Search 监听路由的变化，再次发起请求，获取数据
> 之前是将接口的一个调用写在了 `mounted` 钩子里面，在进入 `Search` 模块后，当用户继续搜索关键词时，该组件是已经挂载了的，因此不会执行 `mouted` `beforemounted` 钩子函数了。

此时，应该监视路由的变化，来整理参数，并发起网络请求，这样就可以解决之前的 `bug` 了。

这个时候就可以对 `Vue` 实例身上的 `$route` 进行监视了

> ==注意：== 当对象里面的一个属性在包含一个对象 而这个对象里面的属性发生改变，数据是变了，但对象的存储位置没有发生改变因此如果不开启深度监视，`watch` 就监听不了对象里面包含对象中的属性的变化，但是，对于这个 `$route` ，对于 $route 对象来说，每次路由切换时，`Vue Router` 会创建一个全新的字面量对象来表示新的路由信息。这意味着 $route 对象的引用会发生变化，即使其中的属性没有发生变化，因此可以不对其开启深度监听。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/13792abf316742edbda6edfe9e3f8384.png)

```html
<template>
  <div>
    <TypeNav />
    <div class="main">
      <div class="py-container">
        <!-- 面包屑 -->
        <div class="bread">
          <ul class="fl sui-breadcrumb">
            <li>
              <a href="#">全部结果</a>
            </li>
          </ul>
          <ul class="fl sui-tag">
            <li class="with-x">手机</li>
            <li class="with-x">iphone<i>×</i></li>
            <li class="with-x">华为<i>×</i></li>
            <li class="with-x">OPPO<i>×</i></li>
          </ul>
        </div>

        <SearchSelector />

        <!-- 商品详情 -->
        <div class="details clearfix">
          <div class="sui-navbar">
            <div class="navbar-inner filter">
              <!-- 价格结构 -->
              <ul class="sui-nav">
                <li class="active">
                  <a href="#">综合</a>
                </li>
                <li>
                  <a href="#">销量</a>
                </li>
                <li>
                  <a href="#">新品</a>
                </li>
                <li>
                  <a href="#">评价</a>
                </li>
                <li>
                  <a href="#">价格⬆</a>
                </li>
                <li>
                  <a href="#">价格⬇</a>
                </li>
              </ul>
            </div>
          </div>
          <!-- 销售产品列表 -->
          <div class="goods-list">
            <ul class="yui3-g">
              <li class="yui3-u-1-5" v-for="(item, index) in goodsList" :key="index">
                <div class="list-wrap">
                  <div class="p-img">
                    <a href="item.html" target="_blank">
                      <img :src="item.defaultImg" />
                    </a>
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>{{ item.price }}.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" :title="item.title">
                      {{ item.title }}
                    </a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
            </ul>
          </div>
          <!-- 分页器 -->
          <div class="fr page">
            <div class="sui-pagination clearfix">
              <ul>
                <li class="prev disabled">
                  <a href="#">«上一页</a>
                </li>
                <li class="active">
                  <a href="#">1</a>
                </li>
                <li>
                  <a href="#">2</a>
                </li>
                <li>
                  <a href="#">3</a>
                </li>
                <li>
                  <a href="#">4</a>
                </li>
                <li>
                  <a href="#">5</a>
                </li>
                <li class="dotted"><span>...</span></li>
                <li class="next">
                  <a href="#">下一页»</a>
                </li>
              </ul>
              <div><span>共10页&nbsp;</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import SearchSelector from './SearchSelector/SearchSelector'
import { mapGetters } from 'vuex'
export default {
  name: 'ShangSearch',
  data () {
    return {
      // 携带给服务器的参数
      searchParams: {
        // 一级分类 id
        category1Id: '',
        // 二级分类 id
        category2Id: '',
        // 三级分类 id
        category3Id: '',
        // 用户选中的分类名
        categoryName: '',
        // 用户搜索携带的关键字
        keyword: '',
        // 排序
        order: '',
        // 分页器参数
        pageNo: 1, // 第几页
        pageSize: 3, // 每一个的展示的数量
        // 平台售卖属性操作携带的参数
        props: [],
        // 品牌
        trademark: ''
      }
    }
  },
  components: {
    SearchSelector
  },
  beforeMount () {
    // 在发起请求之前，将参数进行整理
    const query = this.$route.query
    const params = this.$route.params
    Object.assign(this.searchParams, query, params)
  },
  mounted () {
    this.getData()
  },
  computed: {
    ...mapGetters('search', {
      goodsList: 'goodsList'
    })
  },
  // 数据监听：监听组件实例身上的属性的属性值变化
  watch: {
    // 监听路由的信息是否发生变化，如果发生变化，再次发起请求
    $route (newValue) {
      // 再次发请求之前整理带给服务器的参数
      Object.assign(this.searchParams, this.$route.query, this.$route.params)
      // 发起请求
      this.getData()
      // 每一次请求完毕，应该将相应的 1、2、3 级分类的 id 置空，让它接收下一次相应的 1、2、3 级分类的 id
      this.searchParams.category1Id = ''
      this.searchParams.category2Id = ''
      this.searchParams.category3Id = ''
    }
  },
  methods: {
    // 将该请求封装为一个函数
    getData () {
      this.$store.dispatch('search/getSearchList', this.searchParams)
    }
  }
}
</script>
```

如上的

```js
// 每一次请求完毕，应该将相应的 1、2、3 级分类的 id 置空，让它接收下一次相应的 1、2、3 级分类的 id
this.searchParams.category1Id = ''
this.searchParams.category2Id = ''
this.searchParams.category3Id = ''
```

目的其实就是，用户的操作已经带有了 `keyword` `categoryName`，是不需要对这两个请求参数进行一次置空的，只需要对后面几级分类的 `id` 进行一次置空就可以了，因为哪怕用户是在母婴下搜索飞机，那也只是用户的不当搜索行为而已。
## 接口

1. Home 模块获取渲染三级联动
2. Home 模块 Mock 模拟获取 Banner 轮播数据
3. Home 模块 Mock 模拟获取 Floor 楼层数据
4. Search 模块获取数据
# 小结

`“我想我已经足够勇敢了，我只需要保持平常心，不遗余力地做好当下的每一件事，剩下的时间会告诉我答案。”`

![被小何温暖的一天](https://img-blog.csdnimg.cn/direct/ff674f8ae6c047b3868924451beb7f3e.jpeg)